<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="referrer" content="origin" />
  <title>Maroowell 우편번호 검색기</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico?v=2" />

  <style>
    :root {
      --headerH: 52px;
      --bg:#0f1115;
      --card:#161a22;
      --muted:#8b95a7;
      --text:#e6e9ef;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:14px/1.4 system-ui,AppleSDGothicNeo,"Segoe UI",Roboto
    }
    header{
      display:flex;
      gap:8px;
      align-items:center;
      padding:12px 16px;
      height:var(--headerH);
      background:#161a22;
      border-bottom:1px solid #232838;
      position:sticky;
      top:0;
      z-index:5
    }
    header h1{font-size:18px;font-weight:800;letter-spacing:0.2px;margin:0}
    #app{
      display:grid;
      grid-template-columns:360px 1fr;
      min-height:calc(100dvh - var(--headerH));
    }
    #panel{
      padding:14px;
      border-right:1px solid #232838;
      background:#10141b
    }
    #mapWrap{
      position:relative;
      min-height:calc(100dvh - var(--headerH));
      display:flex;
    }
    #map,#roadview{
      flex:1;
      width:100%;
      height:100%;
      min-width:0;
      min-height:0;
    }
    #roadview{display:none}
    /* 로드뷰 "길 선택" 모드에서는 지도를 그대로 두고, 실제 로드뷰는 선택 후에만 표시 */
    #mapWrap.roadview-open #roadview{display:block}

    .map-controls{
      position:absolute;
      top:10px;
      right:10px;
      z-index:10;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .map-controls button{
      background:rgba(15,17,21,0.82);
      border-color:#2a3142;
      backdrop-filter: blur(6px);
    }
    .map-controls .hint{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid #2a3142;
      background:rgba(15,17,21,0.72);
      color:#cbd5e1;
      font-size:12px;
    }

    label{display:block;margin:10px 0 6px;color:#9aa6b2}
    input,textarea,button{font:inherit}
    textarea{
      width:100%;
      background:#0c0f14;
      border:1px solid #2a3142;
      color:var(--text);
      padding:10px;
      border-radius:10px;
      min-height:90px
    }
    button{
      background:#1b2230;
      border:1px solid #2a3142;
      color:var(--text);
      padding:6px 10px;
      border-radius:10px;
      cursor:pointer
    }
    button:hover{border-color:#3a4561}
    button.danger{
      background:#2a1416;
      border-color:#7f1d1d;
      color:#fecaca
    }
    button.danger:hover{
      border-color:#ef4444
    }

    .zip-label{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:4px 10px;
      border-radius:999px;
      font-weight:800;
      font-size:12px;
      letter-spacing:0.2px;
      color:#0b1220;
      background:rgba(255,255,255,0.92);
      border:2px solid rgba(15,23,42,0.28);
      box-shadow:0 2px 10px rgba(0,0,0,0.22);
      user-select:none;
      pointer-events:none;
      transform:translateY(-2px);
      white-space:nowrap;
    }

    .row{display:flex;gap:8px;flex-wrap:wrap}
    .muted{color:#8b95a7;font-size:12px}
    .list{margin-top:10px;display:flex;flex-wrap:wrap;gap:6px}
    .chip{
      border:1px solid #2a3142;
      border-radius:999px;
      padding:6px 10px;
      background:#0c0f14;
      display:inline-flex;
      align-items:center;
      gap:6px
    }
    .chip button{
      border:none;
      background:transparent;
      color:#94a3b8;
      cursor:pointer
    }

    @media (max-width: 900px){
      #app{
        grid-template-columns:1fr;
      }
      #panel{
        order:2;
      }
      #mapWrap{
        min-height:60vh;
      }
      #mapWrap.roadview-open{
        flex-direction:column;
      }
    }
  </style>

  <!-- Daum 우편번호 -->
  <script src="https://t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js"></script>

  <!-- proj4 (5179 -> 4326 변환용) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>

  <!-- Kakao 지도 SDK -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3"></script>
</head>
<body>
  <header>
    <a href="/coupangRouteMap.html" style="display:flex;align-items:center">
      <img src="/favicon.ico" alt="Maroowell Logo" style="width:24px;height:24px;transform:translateY(-2px);cursor:pointer" />
    </a>
    <h1>Maroowell 우편번호 검색기</h1>
    <span class="muted">다중 우편번호 권역 검색기 · Kakao Map</span>
  </header>

  <div id="app">
    <aside id="panel">
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="muted">우편번호 여러 개 동시 조회</div>
          <div class="muted">쉼표/공백/줄바꿈 모두 가능</div>
        </div>
        <button id="openAddr">주소검색 추가</button>
      </div>

      <label style="margin-top:12px">우편번호 목록</label>
      <textarea id="zipInput"
        placeholder="예: 07420, 07421 07422&#10;또는 붙여넣기"></textarea>

      <div class="row" style="margin-top:8px">
        <button id="addBtn">추가</button>
        <button id="searchBtn">지도표시</button>
        <button id="clearBtn" class="danger">초기화</button>
      </div>

      <div class="list" id="zipList"></div>

      <p class="muted" style="margin-top:10px">
        • 잘못된 우편번호나 데이터가 없는 경우 미탑재로 안내됩니다.
      </p>
    </aside>

    <div id="mapWrap">
      <div id="map"></div>
      <div id="roadview"></div>
      <div class="map-controls">
        <button id="toggleMapType" title="일반/위성 전환">위성</button>
        <button id="toggleRoadview" title="로드뷰 보기/종료">로드뷰</button>
        <span id="roadviewHint" class="hint" style="display:none">로드뷰: 파란 길(ROADVIEW) 클릭</span>
      </div>
    </div>
  </div>

  <script>
    // ------- 전역 상태 ------- //
    const state = {
      map: null,
      polygons: new Map(),    // zipcode -> [Polygon, ...]
      labels: new Map(),      // zipcode -> [CustomOverlay, ...]
      selectedZips: new Set(),
      isSatellite: false,
      roadviewOn: false,       // 로드뷰 모드(길 선택 포함) on/off
      roadviewOpen: false,     // 실제 로드뷰 화면 open 여부
      roadview: null,
      roadviewClient: null,
      roadviewClickHandler: null,
      colors: [
        "#ff4b4b","#22c55e","#fbbf24","#3b82f6",
        "#22d3ee","#c084fc","#f472b6","#60a5fa",
        "#34d399","#f97316"
      ]
    };

    // Worker API 엔드포인트 (배포 후 실제 URL로 변경 필요)
    const ZIP_API = "https://zip.maroowell.com/?zipcode=";
    const $ = (sel) => document.querySelector(sel);

    const parseZips = (raw) =>
      [...new Set((raw || "").match(/\d{5}/g) || [])];

    const pickColor = (zip) => {
      let h = 0;
      for (let i = 0; i < zip.length; i++) {
        h = (h * 31 + zip.charCodeAt(i)) >>> 0;
      }
      return state.colors[h % state.colors.length];
    };

    // ------- proj4 세팅 (5179 -> 4326) ------- //
    proj4.defs(
      "EPSG:5179",
      "+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 " +
        "+x_0=1000000 +y_0=2000000 +ellps=GRS80 " +
        "+towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
    );
    proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

    // 5179 → WGS84 변환 (안되면 fallback)
    function convertPoint(x, y) {
      let lon, lat;

      try {
        const out = proj4("EPSG:5179", "EPSG:4326", [x, y]);
        lon = out[0];
        lat = out[1];
      } catch (e) {
        console.warn("proj4 변환 실패, 원본 좌표 사용 시도", x, y, e);
      }

      // 변환값이 말이 안되면 (한국 범위 밖이면) 원본을 WGS84 라고 보고 사용
      if (
        !isFinite(lat) ||
        !isFinite(lon) ||
        lat < 30 ||
        lat > 45 ||
        lon < 120 ||
        lon > 135
      ) {
        lon = x;
        lat = y;
      }

      return { lat, lon };
    }

    // ------- 지도 초기화 ------- //
    function createMap() {
      if (!(window.kakao && kakao.maps)) {
        alert("카카오 지도 SDK 로딩 실패");
        return;
      }
      state.map = new kakao.maps.Map($("#map"), {
        center: new kakao.maps.LatLng(37.5665, 126.978),
        level: 8
      });

      window.addEventListener("resize", () => {
        const c = state.map.getCenter();
        state.map.relayout();
        state.map.setCenter(c);
        if (state.roadviewOn && state.roadview && typeof state.roadview.relayout === "function") {
          state.roadview.relayout();
        }
      });
    }

    // ------- 지도 타입(일반/위성) ------- //
    function setMapTypeSatellite(on) {
      state.isSatellite = !!on;
      if (!state.map) return;
      state.map.setMapTypeId(
        state.isSatellite ? kakao.maps.MapTypeId.HYBRID : kakao.maps.MapTypeId.ROADMAP
      );
      const btn = $("#toggleMapType");
      if (btn) btn.textContent = state.isSatellite ? "일반" : "위성";
    }

    // ------- 로드뷰 ------- //
    function ensureRoadview() {
      if (state.roadview && state.roadviewClient) return;
      const container = $("#roadview");
      if (!container) return;
      state.roadview = new kakao.maps.Roadview(container);
      state.roadviewClient = new kakao.maps.RoadviewClient();
    }

    function setRoadviewOverlay(on) {
      if (!state.map) return;
      // ROADVIEW 오버레이(파란 길) 표시/해제
      try {
        if (on) state.map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
        else state.map.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
      } catch (e) {
        console.warn("ROADVIEW 오버레이 토글 실패", e);
      }
    }

    function setRoadviewAt(latlng) {
      ensureRoadview();
      if (!state.roadviewClient || !state.roadview) return;

      // 반경(m) 내 가장 가까운 로드뷰 pano 찾기 (반경 단계적 확장)
      const radii = [80, 200, 500, 1200];
      const tryFind = (i) => {
        const r = radii[i];
        state.roadviewClient.getNearestPanoId(latlng, r, (panoId) => {
          // panoId가 0일 수도 있어 falsy 체크 금지
          if (panoId === null || panoId === undefined) {
            if (i < radii.length - 1) return tryFind(i + 1);
            alert("이 위치 근처에는 로드뷰가 없습니다.");
            return;
          }
          // pano가 잡히면 그때 로드뷰 화면을 열어준다 (카카오처럼 '길 선택 → 진입')
          state.roadviewOpen = true;
          const wrap = $("#mapWrap");
          if (wrap) wrap.classList.add("roadview-open");
          // display:none → block 전환 후 레이아웃 갱신
          if (state.roadview && typeof state.roadview.relayout === "function") {
            setTimeout(() => state.roadview.relayout(), 0);
          }

          state.roadview.setPanoId(panoId, latlng);
        });
      };
      tryFind(0);
    }

    function setRoadviewOn(on) {
      state.roadviewOn = !!on;
      if (!state.roadviewOn) state.roadviewOpen = false;
      const wrap = $("#mapWrap");
      const hint = $("#roadviewHint");
      const btn = $("#toggleRoadview");

      if (wrap) {
        wrap.classList.toggle("roadview-on", state.roadviewOn);
        // off일 때는 로드뷰 화면도 강제로 닫기
        if (!state.roadviewOn) wrap.classList.remove("roadview-open");
        // on일 때는 아직 '선택' 단계이므로 roadview-open은 setRoadviewAt에서만 켠다
      }
      if (hint) hint.style.display = state.roadviewOn ? "inline-flex" : "none";
      if (btn) btn.textContent = state.roadviewOn ? "로드뷰 종료" : "로드뷰";

      // 레이아웃 변경 후 relayout
      if (state.map) {
        const c = state.map.getCenter();
        state.map.relayout();
        state.map.setCenter(c);
      }
      if (state.roadviewOn) {
        // 카카오처럼: 먼저 '길 선택' 모드(ROADVIEW 오버레이)만 켜고, 선택 시에만 로드뷰를 연다
        setRoadviewOverlay(true);

        // 지도 클릭 시 로드뷰 이동
        if (!state.roadviewClickHandler && state.map) {
          state.roadviewClickHandler = (mouseEvent) => {
            if (!state.roadviewOn) return;
            if (mouseEvent && mouseEvent.latLng) setRoadviewAt(mouseEvent.latLng);
          };
          kakao.maps.event.addListener(state.map, "click", state.roadviewClickHandler);
        }
      } else {
        setRoadviewOverlay(false);
        // 클릭 핸들러 제거
        if (state.roadviewClickHandler && state.map) {
          kakao.maps.event.removeListener(state.map, "click", state.roadviewClickHandler);
        }
        state.roadviewClickHandler = null;
      }

      // roadview-open 상태에서만 relayout
      if (state.roadviewOn && state.roadviewOpen) {
        ensureRoadview();
        if (state.roadview && typeof state.roadview.relayout === "function") state.roadview.relayout();
      }
    }

    // ------- UI 이벤트 ------- //
    function bindUI() {
      $("#addBtn").onclick = () => {
        parseZips($("#zipInput").value).forEach((z) =>
          state.selectedZips.add(z)
        );
        $("#zipInput").value = "";
        renderZipChips();
      };

      $("#clearBtn").onclick = () => {
        state.selectedZips.clear();
        clearPolygons();
        setRoadviewOn(false);
        renderZipChips();
      };

      $("#searchBtn").onclick = async () => {
        await drawSelected();
        fitBoundsAll();
      };

      const mapTypeBtn = $("#toggleMapType");
      if (mapTypeBtn) {
        mapTypeBtn.onclick = () => setMapTypeSatellite(!state.isSatellite);
      }

      const roadviewBtn = $("#toggleRoadview");
      if (roadviewBtn) {
        roadviewBtn.onclick = () => setRoadviewOn(!state.roadviewOn);
      }

      // (옵션) 버튼이 있는 경우에만 바인딩
      const fitBtn = $("#fitBtn");
      if (fitBtn) fitBtn.onclick = fitBoundsAll;

      const shareBtn = $("#shareBtn");
      if (shareBtn) {
        shareBtn.onclick = async () => {
          const u = new URL(location.href);
          u.searchParams.set("zips", [...state.selectedZips].join(","));
          await navigator.clipboard.writeText(u.toString());
          alert("공유 링크 복사됨");
        };
      }

      $("#openAddr").onclick = () => {
        new daum.Postcode({
          oncomplete: (d) => {
            if (d.zonecode) {
              state.selectedZips.add(d.zonecode);
              renderZipChips();
            }
          }
        }).open();
      };

      const preset = parseZips(
        new URLSearchParams(location.search).get("zips")
      );
      preset.forEach((z) => state.selectedZips.add(z));
      renderZipChips();
      if (preset.length) {
        drawSelected().then(fitBoundsAll);
      }
    }

    function renderZipChips() {
      const list = $("#zipList");
      list.innerHTML = "";
      [...state.selectedZips].sort().forEach((z) => {
        const div = document.createElement("div");
        div.className = "chip";
        const color = pickColor(z);
        div.innerHTML =
          `<b>${z}</b>` +
          `<span style="display:inline-block;width:10px;height:10px;border-radius:2px;background:${color}"></span>` +
          `<button title="삭제">✕</button>`;
        div.querySelector("button").onclick = () => {
          state.selectedZips.delete(z);
          removePolygon(z);
          renderZipChips();
        };
        list.appendChild(div);
      });
    }

    // ------- 폴리곤 관리 ------- //
    function clearPolygons() {
      for (const arr of state.polygons.values()) {
        arr.forEach((p) => p.setMap(null));
      }
      state.polygons.clear();

      for (const arr of state.labels.values()) {
        arr.forEach((l) => l.setMap(null));
      }
      state.labels.clear();
    }

    function removePolygon(zip) {
      if (!state.polygons.has(zip)) return;
      state.polygons.get(zip).forEach((p) => p.setMap(null));
      state.polygons.delete(zip);

      if (state.labels.has(zip)) {
        state.labels.get(zip).forEach((l) => l.setMap(null));
        state.labels.delete(zip);
      }
    }

    // ------- 라벨(우편번호) 위치 계산 ------- //
    function centroidOfLatLngRing(latlngs) {
      if (!latlngs || latlngs.length < 3) return null;

      // 평면 근사: x=lng, y=lat
      const pts = latlngs.map((ll) => [ll.getLng(), ll.getLat()]);
      const f = pts[0];
      const l = pts[pts.length - 1];
      if (f[0] !== l[0] || f[1] !== l[1]) pts.push(f);

      let area2 = 0;
      let cx6 = 0;
      let cy6 = 0;
      for (let i = 0; i < pts.length - 1; i++) {
        const x0 = pts[i][0], y0 = pts[i][1];
        const x1 = pts[i + 1][0], y1 = pts[i + 1][1];
        const f2 = x0 * y1 - x1 * y0;
        area2 += f2;
        cx6 += (x0 + x1) * f2;
        cy6 += (y0 + y1) * f2;
      }

      if (!isFinite(area2) || Math.abs(area2) < 1e-14) return null;
      const cx = cx6 / (3 * area2);
      const cy = cy6 / (3 * area2);
      if (!isFinite(cx) || !isFinite(cy)) return null;
      return new kakao.maps.LatLng(cy, cx);
    }

    function boundsCenterOfLatLngs(latlngs) {
      if (!latlngs || !latlngs.length) return null;
      const b = new kakao.maps.LatLngBounds();
      latlngs.forEach((ll) => b.extend(ll));
      return b.getCenter();
    }

    function createZipLabelOverlay(zip, color, pos) {
      const el = document.createElement("div");
      el.className = "zip-label";
      el.textContent = zip;
      el.style.borderColor = color;

      return new kakao.maps.CustomOverlay({
        position: pos,
        content: el,
        yAnchor: 0.5,
        zIndex: 9999
      });
    }

    function addZipLabelsForPolygons(zip, polys, color) {
      const overlays = [];
      for (const poly of polys) {
        const latlngs = collectLatLngsFromPath(poly.getPath());
        if (latlngs.length < 3) continue;

        const center = centroidOfLatLngRing(latlngs) || boundsCenterOfLatLngs(latlngs);
        if (!center) continue;

        const ov = createZipLabelOverlay(zip, color, center);
        ov.setMap(state.map);
        overlays.push(ov);
      }
      if (overlays.length) state.labels.set(zip, overlays);
    }

    // zip API -> Polygon 생성
    function polygonsFrom5179(polygon5179, color, zip) {
      if (!Array.isArray(polygon5179) || !polygon5179.length) return [];

      const polys = [];

      // MultiPolygon 형식 처리: [[[[x,y], ...]]]
      // 각 polygon (외부 배열의 각 요소) 처리
      polygon5179.forEach((polygon, polyIdx) => {
        if (!Array.isArray(polygon)) return;
        
        // 각 polygon의 rings 처리
        polygon.forEach((ring, ringIdx) => {
          if (!Array.isArray(ring)) return;
          
          const path = [];
          ring.forEach((pt, ptIdx) => {
            if (!Array.isArray(pt) || pt.length < 2) return;
            const x = Number(pt[0]);
            const y = Number(pt[1]);
            if (!isFinite(x) || !isFinite(y)) return;

            const { lat, lon } = convertPoint(x, y);
            if (!isFinite(lat) || !isFinite(lon)) return;

            path.push(new kakao.maps.LatLng(lat, lon));

            // 첫 3개 포인트만 로그
            if (polyIdx === 0 && ringIdx === 0 && ptIdx < 3) {
              console.log(`[ZIP ${zip}] sample`, { x, y, lat, lon });
            }
          });

          console.log(`[ZIP ${zip}] polygon ${polyIdx} ring ${ringIdx} path length`, path.length);

          if (path.length < 3) return;

          const poly = new kakao.maps.Polygon({
            map: state.map,
            path,
            strokeWeight: 6,
            strokeColor: color,
            strokeOpacity: 1,
            strokeStyle: "solid",
            fillColor: color,
            fillOpacity: 0.25
          });
          polys.push(poly);
        });
      });

      return polys;
    }

    // Worker API 호출해서 그리기
    async function drawSelected() {
      const targets = [...state.selectedZips].filter(
        (z) => !state.polygons.has(z)
      );
      if (!targets.length) return;

      const notFound = [];

      for (const zip of targets) {
        try {
          const url = `${ZIP_API}${encodeURIComponent(zip)}`;
          const res = await fetch(url, { cache: "no-store" });
          const data = await res.json();
          console.log("[ZIP] 로드 완료", zip, data);

          if (
            !Array.isArray(data.polygon5179) ||
            !data.polygon5179.length
          ) {
            notFound.push(zip);
            continue;
          }

          const color = pickColor(zip);
          const polys = polygonsFrom5179(
            data.polygon5179,
            color,
            zip
          );
          if (!polys.length) {
            console.warn("[ZIP] 폴리곤 생성 실패", zip);
            notFound.push(zip);
            continue;
          }

          state.polygons.set(zip, polys);
          addZipLabelsForPolygons(zip, polys, color);
        } catch (e) {
          console.error("[ZIP] 로드 실패", zip, e);
          notFound.push(zip);
        }
      }

      if (notFound.length) {
        alert(
          `폴리곤을 그리지 못한 우편번호: ${notFound.join(", ")}`
        );
      }
    }

    // ------- path 에서 LatLng 전부 뽑기 ------- //
    function collectLatLngsFromPath(path) {
      const out = [];

      const walk = (p) => {
        if (!p) return;

        // LatLng 한 점
        if (
          p instanceof kakao.maps.LatLng ||
          (typeof p.getLat === "function" &&
            typeof p.getLng === "function")
        ) {
          out.push(p);
          return;
        }

        // MVCArray 스타일
        if (
          typeof p.getLength === "function" &&
          typeof p.getAt === "function"
        ) {
          for (let i = 0; i < p.getLength(); i++) {
            walk(p.getAt(i));
          }
          return;
        }

        // 배열 또는 forEach 가진 객체
        if (Array.isArray(p) || typeof p.forEach === "function") {
          p.forEach(walk);
          return;
        }
      };

      walk(path);
      return out;
    }

    // ------- 화면 영역 맞추기 ------- //
    function fitBoundsAll() {
      if (!state.map) return;

      const b = new kakao.maps.LatLngBounds();
      let has = false;

      for (const arr of state.polygons.values()) {
        for (const poly of arr) {
          const latlngs = collectLatLngsFromPath(poly.getPath());
          latlngs.forEach((ll) => {
            b.extend(ll);
            has = true;
          });
        }
      }

      if (has) {
        state.map.setBounds(b);
      }
    }

    // ------- DOM 로드 시 초기화 ------- //
    document.addEventListener("DOMContentLoaded", () => {
      createMap();
      bindUI();
    });
  </script>
</body>
</html>
