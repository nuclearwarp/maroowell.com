<!doctype html>
<html lang="ko">
<head>
    <script src="/config.js"></script>
<meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="referrer" content="origin" />

  <meta property="og:image" content="https://maroowell.com/assets/og/maroowell-1200x630.png?v=1" />
  <meta property="og:image:secure_url" content="https://maroowell.com/assets/og/maroowell-1200x630.png?v=1" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:image:alt" content="Maroowell" />

  <title>Maroowell 우편번호 검색기</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico?v=2" />

  <style>
    
    html{visibility:hidden}
:root{
      --headerH: 52px;
      --bg:#0f1115;
      --card:#161a22;
      --muted:#8b95a7;
      --text:#e6e9ef;
      --line:#232838;
    }
    *{box-sizing:border-box}
    html,body{height:100%; overflow:hidden;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:14px/1.4 system-ui,AppleSDGothicNeo,"Segoe UI",Roboto;
    }

    header{
      display:flex;
      gap:8px;
      align-items:center;
      padding:12px 16px;
      height:var(--headerH);
      background:#161a22;
      border-bottom:1px solid var(--line);
      position:sticky;
      top:0;
      z-index:50;
    }
    header h1{font-size:18px;font-weight:800;letter-spacing:0.2px;margin:0}
    .muted{color:var(--muted);font-size:12px}
    .spacer{flex:1}

    header a.saveLink{
      color:var(--muted);
      font-size:12px;
      text-decoration:none;
      opacity:.10;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.08);
      user-select:none;
    }
    header a.saveLink:hover{opacity:.22;border-color:rgba(255,255,255,.18)}
    header button.logoutBtn{
      background:transparent;
      color:#fca5a5;
      border:1px solid rgba(252,165,165,.34);
      padding:6px 10px;
      border-radius:10px;
      cursor:pointer;
      display:none;
      font-size:12px;
      font-weight:700;
    }
    header button.logoutBtn:hover{border-color:rgba(252,165,165,.64);background:rgba(127,29,29,.18)}

    #app{
      display:grid;
      grid-template-columns:360px 1fr;
      height:calc(100dvh - var(--headerH));
      min-height:0;
    }

    #panel{
      padding:14px;
      border-right:1px solid var(--line);
      background:#10141b;
      overflow:auto;
      min-height:0;
    }

    #mapWrap{
      position:relative;
      height:100%;
      min-height:0;
      display:flex;
      overscroll-behavior:contain;
      touch-action:none;
    }

    #map,#roadview{
      flex:1;
      width:100%;
      height:100%;
      min-width:0;
      min-height:0;
      overscroll-behavior:contain;
      touch-action:none;
    }
    #roadview{display:none}
    #mapWrap.roadview-open #roadview{display:block}

    .map-controls{
      position:absolute;
      top:10px;
      right:10px;
      z-index:10;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .map-controls button{
      background:rgba(15,17,21,0.82);
      border-color:#2a3142;
      backdrop-filter: blur(6px);
    }
    .map-controls .hint{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid #2a3142;
      background:rgba(15,17,21,0.72);
      color:#cbd5e1;
      font-size:12px;
    }

    label{display:block;margin:10px 0 6px;color:#9aa6b2}
    input,textarea,button{font:inherit}
    textarea{
      width:100%;
      background:#0c0f14;
      border:1px solid #2a3142;
      color:var(--text);
      padding:10px;
      border-radius:10px;
      min-height:90px;
    }
    input{
      width:100%;
      background:#0c0f14;
      border:1px solid #2a3142;
      color:var(--text);
      padding:10px;
      border-radius:10px;
    }

    button{
      background:#1b2230;
      border:1px solid #2a3142;
      color:var(--text);
      padding:6px 10px;
      border-radius:10px;
      cursor:pointer;
    }
    button:hover{border-color:#3a4561}
    button.danger{
      background:#2a1416;
      border-color:#7f1d1d;
      color:#fecaca;
    }
    button.danger:hover{border-color:#ef4444}

    button.merge-on{
      background:#0f2a1f;
      border-color:#22c55e;
      color:#bbf7d0;
    }
    button.merge-on:hover{border-color:#4ade80}

    .zip-label{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:4px 10px;
      border-radius:999px;
      font-weight:800;
      font-size:12px;
      letter-spacing:0.2px;
      color:#0b1220;
      background:rgba(255,255,255,0.92);
      border:2px solid rgba(15,23,42,0.28);
      box-shadow:0 2px 10px rgba(0,0,0,0.22);
      user-select:none;
      pointer-events:none;
      transform:translateY(-2px);
      white-space:nowrap;
    }

    .row{display:flex;gap:8px;flex-wrap:wrap}
    .list{margin-top:10px;display:flex;flex-wrap:wrap;gap:6px}
    .chip{
      border:1px solid #2a3142;
      border-radius:999px;
      padding:6px 10px;
      background:#0c0f14;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .chip button{
      border:none;
      background:transparent;
      color:#94a3b8;
      cursor:pointer;
    }

    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.55);
      z-index:9999;
      padding:16px;
    }
    .modal.open{display:flex}
    .modalCard{
      width:min(520px, 100%);
      background:#0f1626;
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 14px;
      background:#111b2e;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .modalTop b{font-size:14px}
    .modalTop button{
      background:transparent;
      border:1px solid rgba(255,255,255,.12);
      padding:4px 10px;
      border-radius:10px;
      color:#cbd5e1;
    }
    .modalBody{padding:14px}
    .modalBody .row{justify-content:flex-end;margin-top:10px}
    .pill{
      display:inline-flex;
      align-items:flex-start;
      gap:8px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      background:rgba(0,0,0,.22);
      color:#cbd5e1;
      font-size:12px;
      margin-bottom:10px;
      line-height:1.35;
      width:100%;
    }

    @media (max-width: 900px){
      html,body{overflow:auto;}
      #app{grid-template-columns:1fr; height:auto;}
      #panel{order:2; height:auto;}
      #mapWrap{height:60vh;}
      #mapWrap.roadview-open{flex-direction:column;}
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3"></script>
</head>

<body>
  <header>
    <a href="/coupangRouteMap.html" style="display:flex;align-items:center">
      <img src="/favicon.ico" alt="Maroowell Logo" style="width:24px;height:24px;transform:translateY(-2px);cursor:pointer" />
    </a>
    <h1>Maroowell 우편번호 검색기</h1>
    <span class="muted">다중 우편번호 권역 검색기 · Kakao Map</span>
    <span class="spacer"></span>
    <a id="saveLink" class="saveLink" href="https://map.kakao.com" target="_blank" rel="noreferrer">Kakao Map</a>
    <button id="logoutBtn" class="logoutBtn" type="button">로그아웃</button>
  </header>

  <div id="app">
    <aside id="panel">
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="muted">우편번호 여러 개 동시 조회</div>
          <div class="muted">쉼표/공백/줄바꿈 모두 가능</div>
        </div>
        <button id="openAddr">주소검색 추가</button>
      </div>

      <label style="margin-top:12px">우편번호 목록</label>
      <textarea id="zipInput" placeholder="예: 07420, 07421 07422&#10;또는 붙여넣기"></textarea>

      <div class="row" style="margin-top:8px">
        <button id="addBtn">추가</button>
        <button id="searchBtn">지도표시</button>
        <button id="mergeBtn">병합</button>
        <button id="saveBtn">저장</button>
        <button id="clearBtn" class="danger">초기화</button>
      </div>

      <div class="list" id="zipList"></div>

      <p class="muted" style="margin-top:10px">
        • 잘못된 우편번호나 데이터가 없는 경우 미탑재로 안내됩니다.
      </p>
    </aside>

    <div id="mapWrap">
      <div id="map"></div>
      <div id="roadview"></div>
      <div class="map-controls">
        <button id="toggleMapType" title="일반/위성 전환">위성</button>
        <button id="toggleRoadview" title="로드뷰 보기/종료">로드뷰</button>
        <span id="roadviewHint" class="hint" style="display:none">로드뷰: 파란 길(ROADVIEW) 클릭</span>
      </div>
    </div>
  </div>

  <div id="saveModal" class="modal" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-label="폴리곤 저장">
      <div class="modalTop">
        <b>폴리곤 저장</b>
        <button id="saveCloseBtn">닫기</button>
      </div>
      <div class="modalBody">
        <div class="pill">
          • 현재 선택된 우편번호 폴리곤들을 “병합 결과”로 저장합니다.<br/>
          • 저장 시 최종 링은 “원본 면적”으로 클립되어 <b>절대 커지지 않습니다.</b><br/>
          • <b>저장 포맷은 기존 그대로</b> (polygon_wgs84 = Array&lt;ring&gt;).
        </div>

        <label>캠프(camp)</label>
        <input id="saveCampInput" placeholder="예: M익산1 ..." />

        <label style="margin-top:10px">라우트 코드(code)</label>
        <input id="saveCodeInput" placeholder="예: 익산0그룹 ..." />

        <div class="row">
          <button id="saveDoBtn">저장</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    (async function(){
      "use strict";

      
      console.log('[mw] index.html loaded v5');
// =========================
      // ✅ Auth Guard (Supabase)
      // - 로그인 없으면 /login.html 로 강제 이동
      // - next 파라미터로 원래 페이지 복귀
      // =========================
      const { SUPABASE_URL, SUPABASE_ANON_KEY, PATHS } = (window.MARUWELL_CONFIG || {});
      if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
        console.error("[Config Missing] SUPABASE_URL / SUPABASE_ANON_KEY");
      }
      const INDEX_PATH = (PATHS?.index || "/index.html");
      const LOGIN_PATH = (PATHS?.login || "/login.html");
      const authStorage = (() => {
        try { return window.sessionStorage; }
        catch { return null; }
      })();
      const logoutBtnEl = document.getElementById("logoutBtn");

      const supabase = window.supabase?.createClient?.(SUPABASE_URL, SUPABASE_ANON_KEY, {
        auth: {
          persistSession: !!authStorage,
          storage: authStorage || undefined,
          autoRefreshToken: true,
          detectSessionInUrl: true
        }
      });

      function safeNextPath(p) {
        // 외부 오픈리다이렉트 방지: same-origin 상대경로만
        if (!p) return INDEX_PATH;
        if (p.startsWith("http://") || p.startsWith("https://")) return INDEX_PATH;
        if (!p.startsWith("/")) return INDEX_PATH;
        return p;
      }

      async function requireAuthOrRedirect() {
        if (!supabase || !supabase.auth) {
          // SDK가 깨졌거나 CDN 로드 실패일 때 login <-> index 무한 리다이렉트를 피한다.
          console.error("[Auth Guard] Supabase client not initialized");
          alert("Supabase SDK 로딩 실패: 새로고침 후 다시 시도하세요.");
          return false;
        }

        try {
          const { data: { session } } = await supabase.auth.getSession();
          if (session) {
            document.documentElement.style.visibility = "visible";
            if (logoutBtnEl) logoutBtnEl.style.display = "inline-flex";

            // 로그아웃 감지 → 로그인으로
            supabase.auth.onAuthStateChange((_evt, s) => {
              if (!s) {
                const next = safeNextPath(location.pathname + location.search + location.hash);
                location.replace(`${LOGIN_PATH}?next=${encodeURIComponent(next)}`);
              }
            });
            return true;
          }
        } catch (e) {
          console.error("[Auth Guard] getSession failed", e);
        }

        const next = safeNextPath(location.pathname + location.search + location.hash);
        location.replace(`${LOGIN_PATH}?next=${encodeURIComponent(next)}`);
        return false;
      }

      if (!(await requireAuthOrRedirect())) return;


      const ZIP_API_URL = "https://zip.maroowell.com/?zipcode=";
      const ROUTE_ENDPOINT = "https://route.maroowell.com/route";

      const MERGE_SNAP_METERS = 35;
      const MIN_COMPONENT_AREA_SQM = 800;

      const $ = (sel) => document.querySelector(sel);
      const parseZips = (raw) => [...new Set((raw || "").match(/\d{5}/g) || [])];
      const isTouchDevice = () =>
        !!window.matchMedia?.("(pointer: coarse)")?.matches ||
        (navigator.maxTouchPoints || 0) > 0 ||
        "ontouchstart" in window;

      const state = {
        map: null,

        polygons: new Map(), // zip -> [kakao Polygon]
        labels:   new Map(), // zip -> [overlay]
        geoByZip: new Map(), // zip -> turf Feature(MultiPolygon)

        selectedZips: new Set(),

        mergeMode: false,
        mergedPolygons: [],         // fill polygons (no seams)
        mergedOutlinePolylines: [], // outline strokes
        mergedRingsWgs84: null,     // ✅ 저장 포맷 그대로: Array<ring>

        isSatellite: false,
        roadviewOn: false,
        roadviewOpen: false,
        roadview: null,
        roadviewClient: null,
        roadviewClickHandler: null,

        colors: [
          "#ff4b4b","#22c55e","#fbbf24","#3b82f6",
          "#22d3ee","#c084fc","#f472b6","#60a5fa",
          "#34d399","#f97316"
        ]
      };

      function enableMobileMapInteractions() {
        if (!state.map || !isTouchDevice()) return;
        try { state.map.setDraggable(true); } catch {}
        try { state.map.setZoomable(true); } catch {}

        ["mapWrap", "map", "roadview"].forEach((id) => {
          const el = document.getElementById(id);
          if (!el) return;
          el.style.touchAction = "none";
          el.style.overscrollBehavior = "contain";
        });
      }

      function pickColor(seed) {
        let h = 0;
        const s = String(seed);
        for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
        return state.colors[h % state.colors.length];
      }

      function darkenHex(hex, amt=0.18){
        if (!hex || hex[0] !== "#" || hex.length !== 7) return hex;
        const r = Math.max(0, Math.min(255, Math.round(parseInt(hex.slice(1,3),16) * (1-amt))));
        const g = Math.max(0, Math.min(255, Math.round(parseInt(hex.slice(3,5),16) * (1-amt))));
        const b = Math.max(0, Math.min(255, Math.round(parseInt(hex.slice(5,7),16) * (1-amt))));
        return "#" + [r,g,b].map(v=>v.toString(16).padStart(2,"0")).join("");
      }

      // ===== proj4 =====
      proj4.defs(
        "EPSG:5179",
        "+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 " +
          "+x_0=1000000 +y_0=2000000 +ellps=GRS80 " +
          "+towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
      );
      proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

      function convertPoint(x, y) {
        let lon, lat;
        try {
          const out = proj4("EPSG:5179", "EPSG:4326", [x, y]);
          lon = out[0]; lat = out[1];
        } catch {}
        if (!isFinite(lat) || !isFinite(lon) || lat < 30 || lat > 45 || lon < 120 || lon > 135) {
          lon = x; lat = y;
        }
        return { lat, lon };
      }

      // ===== 지도 =====
      function createMap() {
        if (!(window.kakao && kakao.maps)) {
          alert("카카오 지도 SDK 로딩 실패");
          return;
        }
        state.map = new kakao.maps.Map($("#map"), {
          center: new kakao.maps.LatLng(37.5665, 126.978),
          level: 8
        });
        enableMobileMapInteractions();

        window.addEventListener("resize", () => {
          if (!state.map) return;
          const c = state.map.getCenter();
          state.map.relayout();
          state.map.setCenter(c);
          if (state.roadviewOn && state.roadview && typeof state.roadview.relayout === "function") {
            state.roadview.relayout();
          }
          enableMobileMapInteractions();
        });
      }

      function setMapTypeSatellite(on) {
        state.isSatellite = !!on;
        if (!state.map) return;
        state.map.setMapTypeId(
          state.isSatellite ? kakao.maps.MapTypeId.HYBRID : kakao.maps.MapTypeId.ROADMAP
        );
        $("#toggleMapType").textContent = state.isSatellite ? "일반" : "위성";
      }

      // ===== 로드뷰 =====
      function ensureRoadview() {
        if (state.roadview && state.roadviewClient) return;
        state.roadview = new kakao.maps.Roadview($("#roadview"));
        state.roadviewClient = new kakao.maps.RoadviewClient();
      }

      function setRoadviewOverlay(on) {
        if (!state.map) return;
        try {
          if (on) state.map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
          else state.map.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
        } catch {}
      }

      function setRoadviewAt(latlng) {
        ensureRoadview();
        const radii = [80, 200, 500, 1200];
        const tryFind = (i) => {
          state.roadviewClient.getNearestPanoId(latlng, radii[i], (panoId) => {
            if (panoId === null || panoId === undefined) {
              if (i < radii.length - 1) return tryFind(i + 1);
              alert("이 위치 근처에는 로드뷰가 없습니다.");
              return;
            }
            state.roadviewOpen = true;
            $("#mapWrap").classList.add("roadview-open");
            setTimeout(() => state.roadview.relayout(), 0);
            state.roadview.setPanoId(panoId, latlng);
          });
        };
        tryFind(0);
      }

      function setRoadviewOn(on) {
        state.roadviewOn = !!on;
        if (!state.roadviewOn) state.roadviewOpen = false;

        $("#roadviewHint").style.display = state.roadviewOn ? "inline-flex" : "none";
        $("#toggleRoadview").textContent = state.roadviewOn ? "로드뷰 종료" : "로드뷰";

        if (!state.roadviewOn) $("#mapWrap").classList.remove("roadview-open");

        if (state.map) {
          const c = state.map.getCenter();
          state.map.relayout();
          state.map.setCenter(c);
          enableMobileMapInteractions();
        }

        if (state.roadviewOn) {
          setRoadviewOverlay(true);
          if (!state.roadviewClickHandler && state.map) {
            state.roadviewClickHandler = (mouseEvent) => {
              if (!state.roadviewOn) return;
              if (mouseEvent && mouseEvent.latLng) setRoadviewAt(mouseEvent.latLng);
            };
            kakao.maps.event.addListener(state.map, "click", state.roadviewClickHandler);
          }
        } else {
          setRoadviewOverlay(false);
          if (state.roadviewClickHandler && state.map) {
            kakao.maps.event.removeListener(state.map, "click", state.roadviewClickHandler);
          }
          state.roadviewClickHandler = null;
        }
      }

      // ===== UI =====
      function renderZipChips() {
        const list = $("#zipList");
        list.innerHTML = "";

        [...state.selectedZips].sort().forEach((z) => {
          const div = document.createElement("div");
          div.className = "chip";
          const color = pickColor(z);
          div.innerHTML =
            `<b>${z}</b>` +
            `<span style="display:inline-block;width:10px;height:10px;border-radius:2px;background:${color}"></span>` +
            `<button title="삭제">✕</button>`;

          div.querySelector("button").onclick = async () => {
            state.selectedZips.delete(z);
            removeZipData(z);
            renderZipChips();
            if (state.mergeMode) await mergeOn(true);
          };

          list.appendChild(div);
        });
      }

      function removeZipData(zip) {
        if (state.polygons.has(zip)) {
          state.polygons.get(zip).forEach(p => p.setMap(null));
          state.polygons.delete(zip);
        }
        if (state.labels.has(zip)) {
          state.labels.get(zip).forEach(l => l.setMap(null));
          state.labels.delete(zip);
        }
        state.geoByZip.delete(zip);
      }

      function setOriginalVisible(on) {
        const map = on ? state.map : null;
        for (const arr of state.polygons.values()) arr.forEach(p => p.setMap(map));
        for (const arr of state.labels.values())   arr.forEach(l => l.setMap(map));
      }

      // ===== 라벨 =====
      function centroidOfLngLatRing(ringLngLat) {
        if (!ringLngLat || ringLngLat.length < 3) return null;
        const pts = ringLngLat.slice();
        const f = pts[0], l = pts[pts.length - 1];
        if (f[0] !== l[0] || f[1] !== l[1]) pts.push([f[0], f[1]]);

        let area2 = 0, cx6 = 0, cy6 = 0;
        for (let i = 0; i < pts.length - 1; i++) {
          const x0 = pts[i][0], y0 = pts[i][1];
          const x1 = pts[i+1][0], y1 = pts[i+1][1];
          const f2 = x0*y1 - x1*y0;
          area2 += f2;
          cx6 += (x0 + x1) * f2;
          cy6 += (y0 + y1) * f2;
        }
        if (!isFinite(area2) || Math.abs(area2) < 1e-14) return null;
        const cx = cx6 / (3 * area2);
        const cy = cy6 / (3 * area2);
        if (!isFinite(cx) || !isFinite(cy)) return null;
        return new kakao.maps.LatLng(cy, cx);
      }

      function createZipLabelOverlay(zip, color, pos) {
        const el = document.createElement("div");
        el.className = "zip-label";
        el.textContent = zip;
        el.style.borderColor = color;

        return new kakao.maps.CustomOverlay({
          position: pos,
          content: el,
          yAnchor: 0.5,
          zIndex: 9999
        });
      }

      // ===== ZIP 응답 정규화 =====
      function isPoint(v){ return Array.isArray(v) && v.length>=2 && isFinite(v[0]) && isFinite(v[1]); }

      function normalizeToMultiPolygon5179(polygon5179) {
        if (!Array.isArray(polygon5179) || polygon5179.length === 0) return null;

        if (isPoint(polygon5179[0])) return [ [ polygon5179 ] ];

        if (Array.isArray(polygon5179[0]) && polygon5179[0].length && isPoint(polygon5179[0][0])) return [ polygon5179 ];

        if (Array.isArray(polygon5179[0]) && polygon5179[0].length &&
            Array.isArray(polygon5179[0][0]) && polygon5179[0][0].length &&
            isPoint(polygon5179[0][0][0])) return polygon5179;

        return null;
      }

      function closeRingLngLat(ring) {
        if (!ring || ring.length < 3) return ring;
        const f = ring[0], l = ring[ring.length - 1];
        if (f[0] !== l[0] || f[1] !== l[1]) ring.push([f[0], f[1]]);
        return ring;
      }

      function convert5179MultiToWgs84(multi5179) {
        const out = [];
        for (const poly of multi5179) {
          const ringsOut = [];
          for (const ring of poly) {
            const ringOut = [];
            for (const pt of ring) {
              if (!isPoint(pt)) continue;
              const x = Number(pt[0]), y = Number(pt[1]);
              const { lat, lon } = convertPoint(x, y);
              if (!isFinite(lat) || !isFinite(lon)) continue;
              ringOut.push([lon, lat]);
            }
            if (ringOut.length >= 3) {
              closeRingLngLat(ringOut);
              if (ringOut.length >= 4) ringsOut.push(ringOut);
            }
          }
          if (ringsOut.length) out.push(ringsOut);
        }
        return out.length ? out : null;
      }

      function drawZipMultiPolygon(zip, wgsMultiCoords) {
        const color = pickColor(zip);
        const polys = [];
        const overlays = [];

        for (const polyRings of wgsMultiCoords) {
          const ringsLatLng = polyRings.map(ring => {
            const latlngs = ring.map(([lng,lat]) => new kakao.maps.LatLng(lat, lng));
            if (latlngs.length > 1) {
              const f = latlngs[0], l = latlngs[latlngs.length - 1];
              if (f.getLat() === l.getLat() && f.getLng() === l.getLng()) latlngs.pop();
            }
            return latlngs;
          }).filter(r => r.length >= 3);

          if (!ringsLatLng.length) continue;

          const pathForKakao = (ringsLatLng.length === 1) ? ringsLatLng[0] : ringsLatLng;

          const poly = new kakao.maps.Polygon({
            map: state.map,
            path: pathForKakao,
            strokeWeight: 3,
            strokeColor: color,
            strokeOpacity: 1,
            strokeStyle: "solid",
            fillColor: color,
            fillOpacity: 0.25
          });

          polys.push(poly);

          const outerRing = polyRings[0];
          const center = centroidOfLngLatRing(outerRing);
          if (center) {
            const ov = createZipLabelOverlay(zip, color, center);
            ov.setMap(state.map);
            overlays.push(ov);
          }
        }

        if (polys.length) state.polygons.set(zip, polys);
        if (overlays.length) state.labels.set(zip, overlays);
      }

      async function drawSelected() {
        const targets = [...state.selectedZips].filter(z => !state.geoByZip.has(z));
        if (!targets.length) return;

        const notFound = [];
        const reasons = [];

        for (const zip of targets) {
          const url = `${ZIP_API_URL}${encodeURIComponent(zip)}`;
          try {
            const res0 = await fetch(url, { cache: "no-store" });
            const res = res0;
            const resClone = res0.clone();

            if (!res.ok) {
              const t = await res.text().catch(() => "");
              console.warn("[ZIP_API] HTTP error", zip, res.status, t.slice(0, 300));
              reasons.push(`${zip}: HTTP ${res.status}`);
              notFound.push(zip);
              continue;
            }

            let data = null;
            try {
              data = await res.json();
            } catch (e) {
              const t = await resClone.text().catch(() => "");
              console.warn("[ZIP_API] JSON parse fail", zip, String(e), t.slice(0, 300));
              reasons.push(`${zip}: JSON parse fail`);
              notFound.push(zip);
              continue;
            }

            const polyRaw =
              (data && (data.polygon5179 ?? data.polygon_5179 ?? data.polygon)) ?? null;

            if (!Array.isArray(polyRaw) || polyRaw.length === 0) {
              console.warn("[ZIP_API] polygon5179 missing/empty", zip, data);
              reasons.push(`${zip}: polygon missing`);
              notFound.push(zip);
              continue;
            }

            const norm = normalizeToMultiPolygon5179(polyRaw);
            if (!norm) { reasons.push(`${zip}: normalize fail`); notFound.push(zip); continue; }

            const wgs = convert5179MultiToWgs84(norm);
            if (!wgs) { reasons.push(`${zip}: convert fail`); notFound.push(zip); continue; }

            const feature = {
              type: "Feature",
              properties: { zip },
              geometry: { type: "MultiPolygon", coordinates: wgs }
            };
            state.geoByZip.set(zip, feature);

            drawZipMultiPolygon(zip, wgs);
          } catch (err) {
            console.warn("[ZIP_API] fetch failed", zip, String(err));
            reasons.push(`${zip}: fetch failed`);
            notFound.push(zip);
          }
        }

        if (notFound.length) {
          const detail = reasons.length ? `\n\n상세(최대 8개):\n- ${reasons.slice(0, 8).join("\n- ")}` : "";
          alert(`폴리곤을 그리지 못한 우편번호: ${notFound.join(", ")}${detail}`);
        }
      }

      // ===== Bounds =====
      function fitBoundsAllOriginal() {
        if (!state.map) return;
        const b = new kakao.maps.LatLngBounds();
        let has = false;

        for (const arr of state.polygons.values()) {
          for (const poly of arr) {
            const path = poly.getPath();

            if (Array.isArray(path)) {
              path.forEach(ll => { b.extend(ll); has = true; });
              continue;
            }

            if (path && typeof path.getLength === "function" && typeof path.getAt === "function") {
              for (let i = 0; i < path.getLength(); i++) {
                const ring = path.getAt(i);
                if (ring && typeof ring.getLength === "function") {
                  for (let j = 0; j < ring.getLength(); j++) {
                    b.extend(ring.getAt(j));
                    has = true;
                  }
                }
              }
            }
          }
        }
        if (has) {
          state.map.setBounds(b);
          enableMobileMapInteractions();
        }
      }

      function fitBoundsToRings(rings){
        if (!state.map || !Array.isArray(rings) || !rings.length) return;
        const b = new kakao.maps.LatLngBounds();
        let has = false;
        for (const ring of rings) {
          if (!Array.isArray(ring) || ring.length < 2) continue;
          for (const pt of ring) {
            if (!Array.isArray(pt) || pt.length < 2) continue;
            const lng = Number(pt[0]), lat = Number(pt[1]);
            if (!isFinite(lat) || !isFinite(lng)) continue;
            b.extend(new kakao.maps.LatLng(lat, lng));
            has = true;
          }
        }
        if (has) {
          state.map.setBounds(b);
          enableMobileMapInteractions();
        }
      }

      // ===== 병합 =====
      function setMergeUI(on){
        state.mergeMode = !!on;
        const btn = $("#mergeBtn");
        btn.textContent = state.mergeMode ? "해제" : "병합";
        btn.classList.toggle("merge-on", state.mergeMode);
      }

      function clearMerged(){
        state.mergedPolygons.forEach(p => p.setMap(null));
        state.mergedOutlinePolylines.forEach(l => l.setMap(null));
        state.mergedPolygons = [];
        state.mergedOutlinePolylines = [];
        state.mergedRingsWgs84 = null;
      }

      function flattenToPolygonFeatures(feature) {
        try {
          const fc = turf.flatten(feature);
          return (fc && fc.features) ? fc.features.filter(f => f?.geometry?.type === "Polygon") : [];
        } catch { return []; }
      }

      function stabilizeFeature(f){
        let out = f;
        try { out = turf.truncate(out, { precision: 6, mutate: false }); } catch {}
        try { out = turf.cleanCoords(out); } catch {}
        try { out = turf.rewind(out, { reverse: false }); } catch {}
        return out;
      }

      function safeBuffer(f, meters){
        if (!meters || meters === 0) return f;
        try {
          return turf.buffer(f, meters, { units: "meters", steps: 16 });
        } catch (e) {
          console.warn("[merge] buffer fail -> use original", e);
          return f;
        }
      }

      function safeUnion(a, b){
        try { return turf.union(a, b); } catch (e) {
          console.warn("[merge] union fail", e);
          return null;
        }
      }

      function safeIntersect(a, b){
        try {
          const out = turf.intersect(a, b);
          return out || null;
        } catch (e) {
          console.warn("[merge] intersect fail", e);
          return null;
        }
      }

      function mergeFeaturesWithSnap(features, snapMeters) {
        if (!features.length) return null;

        const leftovers = [];
        let merged = null;

        for (const raw of features) {
          const f0 = stabilizeFeature(raw);
          const fb = stabilizeFeature(safeBuffer(f0, snapMeters));

          if (!merged) { merged = fb; continue; }

          let u = safeUnion(merged, fb);

          if (!u) {
            const m2 = stabilizeFeature(merged);
            const f2 = stabilizeFeature(raw);
            u = safeUnion(m2, f2);
          }

          if (!u) { leftovers.push(fb); continue; }

          merged = stabilizeFeature(u);
        }

        if (leftovers.length) {
          try {
            const fc = turf.featureCollection([merged, ...leftovers].filter(Boolean));
            const combined = turf.combine(fc);
            if (combined?.features?.[0]) merged = combined.features[0];
          } catch (e) {
            console.warn("[merge] combine fail", e);
          }
        }

        return merged;
      }

      function getSelectedFeatures(){
        const feats = [];
        for (const z of state.selectedZips) {
          const f = state.geoByZip.get(z);
          if (f) feats.push(f);
        }
        return feats;
      }

      // ===== ✅ 홀(구멍) 처리하면서도 "기존 저장 포맷(Array<ring>)" 유지 =====
      function _cloneRing(ring){
        return ring.map(p => [Number(p[0]), Number(p[1])]).filter(p => isFinite(p[0]) && isFinite(p[1]));
      }

      function _closeRingCopy(ring){
        const r = _cloneRing(ring);
        if (r.length < 3) return null;
        const f = r[0], l = r[r.length - 1];
        if (f[0] !== l[0] || f[1] !== l[1]) r.push([f[0], f[1]]);
        return (r.length >= 4) ? r : null;
      }

      function _polyToLineStringFeatures(polyFeature){
        const ls = [];
        try {
          const out = turf.polygonToLine(polyFeature);
          if (!out || !out.geometry) return ls;

          if (out.geometry.type === "LineString") {
            ls.push(out);
          } else if (out.geometry.type === "MultiLineString") {
            for (const coords of out.geometry.coordinates) {
              ls.push(turf.lineString(coords));
            }
          }
        } catch (e) {
          console.warn("[merge] polygonToLine fail", e);
        }
        return ls;
      }

      function _nearestOuterVertex(outerRing, holePoint){
        let best = null;
        let bestD = Infinity;
        for (const pt of outerRing) {
          const dx = pt[0] - holePoint[0];
          const dy = pt[1] - holePoint[1];
          const d2 = dx*dx + dy*dy;
          if (d2 < bestD) { bestD = d2; best = pt; }
        }
        return best;
      }

      // 홀 링과 외곽 링을 연결하는 "컷 라인" (폴리곤 분해용)
      function _buildCutLine(outerRing, holeRing){
        const hp = holeRing[0];
        const op = _nearestOuterVertex(outerRing, hp);
        if (!op) return null;
        return turf.lineString([hp, op]);
      }

      // Polygon(holes 포함)을 holes 없는 여러 Polygon으로 분해 -> outer rings만 반환
      function _deholeToFillRings(polyFeature){
        const coords = polyFeature?.geometry?.coordinates;
        if (!Array.isArray(coords) || !coords.length) return [];

        // holes 없음: 그냥 outer
        if (coords.length === 1) {
          const r = _closeRingCopy(coords[0]);
          return r ? [r] : [];
        }

        const outer = _closeRingCopy(coords[0]);
        if (!outer) return [];

        const holes = coords.slice(1).map(_closeRingCopy).filter(Boolean);
        if (!holes.length) return [outer];

        // linework = boundary + cut lines
        const lineFeatures = _polyToLineStringFeatures(polyFeature);
        const cuts = [];
        for (const h of holes) {
          const cut = _buildCutLine(outer, h);
          if (cut) cuts.push(cut);
        }

        const fc = turf.featureCollection([...lineFeatures, ...cuts].filter(Boolean));

        let polys = [];
        try {
          const polyFC = turf.polygonize(fc);
          polys = (polyFC?.features || []).filter(f => f?.geometry?.type === "Polygon");
        } catch (e) {
          console.warn("[merge] polygonize fail -> fallback outer only", e);
          return [outer]; // fallback
        }

        // donut 영역(holes 제외) 안에 있는 폴리곤만 채택 (hole 폴리곤은 제외됨)
        const outRings = [];
        for (const p of polys) {
          try {
            const pt = turf.pointOnFeature(p);
            const inside = turf.booleanPointInPolygon(pt, polyFeature); // holes는 false로 처리됨
            if (!inside) continue;

            const area = turf.area(p);
            if (isFinite(area) && area < MIN_COMPONENT_AREA_SQM) continue;

            const r0 = _closeRingCopy(p.geometry.coordinates[0]);
            if (r0 && r0.length >= 4) outRings.push(r0);
          } catch {}
        }

        // 혹시 실패하면 최소 outer라도
        return outRings.length ? outRings : [outer];
      }

      // ✅ 반환:
      // - fillRings: holes 없는 링들(저장/표시용)  => 기존 저장 포맷 그대로
      // - outlineRings: 외곽선(holes 경계 포함) 폴리라인용
      async function computeMergedResult(){
        await drawSelected();

        const feats = getSelectedFeatures().map(stabilizeFeature).filter(Boolean);
        if (!feats.length) return null;

        const mergedSnap = mergeFeaturesWithSnap(feats, MERGE_SNAP_METERS);
        if (!mergedSnap) return null;

        // ✅ 원본 면적 마스크는 "union(스냅 없음)"으로 (combine 아님)
        const origMask = mergeFeaturesWithSnap(feats, 0);

        const mergedClipped =
          (origMask ? safeIntersect(mergedSnap, origMask) : null) || origMask || mergedSnap;

        const mergedStable = stabilizeFeature(mergedClipped);

        let polys = flattenToPolygonFeatures(mergedStable);
        polys = polys.filter(p => { try { return turf.area(p) >= MIN_COMPONENT_AREA_SQM; } catch { return true; }});

        const fillRings = [];
        const outlineRings = [];

        for (const pf of polys) {
          const coords = pf?.geometry?.coordinates;
          if (!Array.isArray(coords) || !coords.length) continue;

          // outline: outer + holes 모두 (폴리라인으로 그릴 거라 저장에는 안 씀)
          for (const ring of coords) {
            const rr = _closeRingCopy(ring);
            if (rr) outlineRings.push(rr);
          }

          // fill: holes 없는 폴리곤들로 분해해서 outer rings만 (✅ 저장 포맷 유지 + hole 안 칠해짐)
          const rings = _deholeToFillRings(pf);
          for (const r of rings) fillRings.push(r);
        }

        return (fillRings.length ? { fillRings, outlineRings } : null);
      }

      function _ringToLatLngs(ring){
        const latlngs = [];
        for (const p of ring) {
          if (!Array.isArray(p) || p.length < 2) continue;
          const lng = Number(p[0]), lat = Number(p[1]);
          if (!isFinite(lat) || !isFinite(lng)) continue;
          latlngs.push(new kakao.maps.LatLng(lat, lng));
        }
        // 닫힌 점 제거
        if (latlngs.length > 1) {
          const f = latlngs[0], l = latlngs[latlngs.length - 1];
          if (f.getLat() === l.getLat() && f.getLng() === l.getLng()) latlngs.pop();
        }
        return latlngs;
      }

      async function mergeOn(rebuildOnly=false){
        try {
          const res = await computeMergedResult();
          if (!res) { if(!rebuildOnly) alert("병합 결과가 없습니다."); return; }

          clearMerged();

          // ✅ 저장 포맷 그대로 보관
          state.mergedRingsWgs84 = res.fillRings;

          const mergedColor = darkenHex(pickColor("merged"), 0.18);

          // 1) fill: stroke 0 (조각 seam 안 보이게)
          for (const ring of res.fillRings) {
            const latlngs = _ringToLatLngs(ring);
            if (latlngs.length < 3) continue;

            const poly = new kakao.maps.Polygon({
              map: state.map,
              path: latlngs,
              strokeOpacity: 0,
              strokeWeight: 0,
              fillColor: mergedColor,
              fillOpacity: 0.20
            });
            state.mergedPolygons.push(poly);
          }

          // 2) outline: 전체 경계선(holes 경계 포함)만 굵게
          for (const ring of res.outlineRings) {
            const latlngs = _ringToLatLngs(ring);
            if (latlngs.length < 2) continue;

            const line = new kakao.maps.Polyline({
              map: state.map,
              path: latlngs,
              strokeWeight: 6,
              strokeColor: mergedColor,
              strokeOpacity: 1,
              strokeStyle: "solid"
            });
            state.mergedOutlinePolylines.push(line);
          }

          setOriginalVisible(false);
          setMergeUI(true);
          fitBoundsToRings(res.fillRings);
        } catch (e) {
          console.warn("[merge] mergeOn crashed:", e);
          clearMerged();
          setOriginalVisible(true);
          setMergeUI(false);
          if (!rebuildOnly) alert("병합 실패(지오메트리 오류).");
        }
      }

      function mergeOff(){
        clearMerged();
        setOriginalVisible(true);
        setMergeUI(false);
        fitBoundsAllOriginal();
      }

      async function toggleMerge(){
        if (state.mergeMode) mergeOff();
        else await mergeOn(false);
      }

      // ===== 저장 =====
      function openSaveModal(){
        $("#saveCampInput").value = localStorage.getItem("mw_save_camp") || "";
        $("#saveCodeInput").value = localStorage.getItem("mw_save_code") || "";
        $("#saveModal").classList.add("open");
        $("#saveModal").setAttribute("aria-hidden","false");
        setTimeout(() => { $("#saveCampInput").focus(); }, 0);
      }

      function closeSaveModal(){
        $("#saveBtn")?.focus?.();
        $("#saveModal").classList.remove("open");
        $("#saveModal").setAttribute("aria-hidden","true");
      }

      async function saveMergedToDB(){
        const camp = ($("#saveCampInput").value || "").trim();
        const code = ($("#saveCodeInput").value || "").trim();
        if (!camp) return alert("camp를 입력하세요");
        if (!code) return alert("code(라우트 코드)를 입력하세요");

        // ✅ 저장용: 기존 포맷(Array<ring>) 그대로
        let rings = state.mergedRingsWgs84;

        if (!rings || !rings.length) {
          const res = await computeMergedResult();
          rings = res?.fillRings || null;
        }

        if (!rings || !rings.length) {
          alert("저장할 병합 결과가 없습니다.");
          return;
        }

        const payload = { camp, code, polygon_wgs84: rings };

        const res = await fetch(ROUTE_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify(payload)
        });

        const text = await res.text();
        let j = null;
        try { j = text ? JSON.parse(text) : null; } catch {}

        if (!res.ok) {
          const msg = j?.error || j?.message || text || `HTTP ${res.status}`;
          alert("저장 실패: " + msg);
          return;
        }

        localStorage.setItem("mw_save_camp", camp);
        localStorage.setItem("mw_save_code", code);

        closeSaveModal();
        alert("저장 완료");
      }

      // ===== 초기화 =====
      function clearAll(){
        for (const arr of state.polygons.values()) arr.forEach(p => p.setMap(null));
        for (const arr of state.labels.values())   arr.forEach(l => l.setMap(null));
        state.polygons.clear();
        state.labels.clear();
        state.geoByZip.clear();

        clearMerged();
        setMergeUI(false);

        state.selectedZips.clear();
        renderZipChips();

        setRoadviewOn(false);
      }

      // ===== 바인딩 =====
      function bindUI(){
        $("#addBtn").onclick = async () => {
          parseZips($("#zipInput").value).forEach(z => state.selectedZips.add(z));
          $("#zipInput").value = "";
          renderZipChips();
          if (state.mergeMode) await mergeOn(true);
        };

        $("#searchBtn").onclick = async () => {
          await drawSelected();
          if (state.mergeMode) await mergeOn(true);
          else fitBoundsAllOriginal();
          enableMobileMapInteractions();
        };

        $("#mergeBtn").onclick = async () => { await toggleMerge(); };

        $("#saveBtn").onclick = openSaveModal;
        $("#clearBtn").onclick = clearAll;

        $("#toggleMapType").onclick = () => setMapTypeSatellite(!state.isSatellite);
        $("#toggleRoadview").onclick = () => setRoadviewOn(!state.roadviewOn);

        $("#openAddr").onclick = () => {
          new daum.Postcode({
            oncomplete: (d) => {
              if (d.zonecode) {
                state.selectedZips.add(d.zonecode);
                renderZipChips();
                enableMobileMapInteractions();
              }
            }
          }).open();
        };

        $("#saveLink").onclick = (e) => { e.preventDefault(); openSaveModal(); };
        if (logoutBtnEl) {
          logoutBtnEl.onclick = async () => {
            if (!supabase?.auth) return;
            logoutBtnEl.disabled = true;
            try {
              await supabase.auth.signOut();
            } catch (e) {
              console.error("[Auth] signOut failed", e);
              alert("로그아웃 중 오류가 발생했습니다.");
              logoutBtnEl.disabled = false;
              return;
            }
            location.replace(LOGIN_PATH);
          };
        }

        $("#saveCloseBtn").onclick = closeSaveModal;
        $("#saveDoBtn").onclick = saveMergedToDB;

        const preset = parseZips(new URLSearchParams(location.search).get("zips"));
        preset.forEach(z => state.selectedZips.add(z));
        renderZipChips();
        if (preset.length) {
          drawSelected().then(() => fitBoundsAllOriginal());
        }

        setMergeUI(false);
      }

      function initApp() {
        createMap();
        bindUI();
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initApp, { once: true });
      } else {
        initApp();
      }
    })();
  </script>
</body>
</html>
