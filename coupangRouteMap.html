<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ë§ˆë£¨ì›° ë¼ìš°íŠ¸ í¸ì§‘ê¸°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico?v=2" />

  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a2d;
      --panel2:#0c1627;
      --txt:#e6eefc;
      --muted:#93a4c7;
      --line:rgba(255,255,255,.08);
      --btn:#162744;
      --btn2:#1a2f55;
      --danger:#6b1b1b;
      --ok:#1a5a3a;
      --warn:#6a4b13;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; background:#0a0f1a;}
    .wrap{display:flex; height:100%;}
    .left{
      width:360px; min-width:340px; max-width:420px;
      background:linear-gradient(180deg,var(--bg),#070b13);
      color:var(--txt);
      border-right:1px solid var(--line);
      padding:14px 14px 10px 14px;
      overflow:auto;
    }
    .title{font-size:18px; font-weight:800; letter-spacing:.2px; margin:2px 0 10px; display:flex; align-items:center; gap:6px;}
    .subtitle{font-size:12px; color:var(--muted); margin:-6px 0 14px;}
    .group{background:rgba(255,255,255,.03); border:1px solid var(--line); border-radius:12px; padding:10px; margin:10px 0;}
    .label{font-size:12px; color:var(--muted); margin:6px 0 6px;}
    input[type="text"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
    }
    input[type="text"]:focus{border-color:rgba(255,255,255,.25)}
    .row{display:flex; gap:8px; align-items:center;}
    .row > *{flex:1}
    .btn{
      padding:10px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:var(--btn);
      color:var(--txt);
      cursor:pointer;
      font-weight:700;
      font-size:13px;
      white-space:nowrap;
    }
    .btn:hover{background:var(--btn2)}
    .btn.danger{background:rgba(107,27,27,.35); border-color:rgba(255,60,60,.22)}
    .btn.danger:hover{background:rgba(107,27,27,.55)}
    .btn.ok{background:rgba(26,90,58,.35); border-color:rgba(0,255,140,.18)}
    .btn.ok:hover{background:rgba(26,90,58,.55)}
    .btn.warn{background:rgba(106,75,19,.35); border-color:rgba(255,180,0,.18)}
    .btn.warn:hover{background:rgba(106,75,19,.55)}
    .help{font-size:12px; color:var(--muted); line-height:1.5; margin-top:8px;}
    .logWrap{
      border-radius:12px;
      border:1px solid var(--line);
      overflow:hidden;
      background:rgba(0,0,0,.25);
      margin-top:10px;
    }
    .logHeader{
      padding:8px 10px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between;
      font-size:12px; color:var(--muted);
    }
    .log{
      height:170px;
      overflow:auto;
      padding:8px 10px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      white-space:pre-wrap;
      color:#d9e5ff;
    }
    .pill{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      font-size:12px;
      color:var(--muted);
    }
    .map{flex:1; position:relative;}
    #map{position:absolute; inset:0;}
    .floatingHint{
      position:absolute;
      top:10px; left:10px;
      background:rgba(0,0,0,.55);
      color:#fff;
      border:1px solid rgba(255,255,255,.14);
      border-radius:10px;
      padding:8px 10px;
      font-size:12px;
      max-width:520px;
      display:none;
      z-index:20;
    }
    .sep{height:1px; background:var(--line); margin:10px 0;}
    .small{font-size:11px; color:var(--muted);}
  </style>

  <!-- Kakao Maps (Drawing ë¼ì´ë¸ŒëŸ¬ë¦¬ ì œê±°: a.e is not a function ê·¼ì› ì°¨ë‹¨) -->
  <!-- ë³¸ì¸ ì•±í‚¤ë¡œ êµì²´ -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&autoload=false&libraries=services"></script>
</head>

<body>
<div class="wrap">
  <div class="left">
    <div class="title">
      <img src="/favicon.ico" alt="Maroowell Logo" style="width:18px;height:18px" />
      <span>ë§ˆë£¨ì›° ë¼ìš°íŠ¸ í¸ì§‘ê¸°</span>
    </div>

    <div class="group">
      <div class="label">ìº í”„ ì´ë¦„ (ì˜ˆ: í‰ì–‘1)</div>
      <input id="campInput" type="text" value="" />

      <div class="label">ë¼ìš°íŠ¸ ì½”ë“œ (ì˜ˆ: 101, 101A) â€” ë¹„ìš°ë©´ camp ì „ì²´ í‘œì‹œ</div>
      <input id="codeInput" type="text" value="" />

      <div class="sep"></div>

      <div class="label">ë²¤ë” ì •ë³´(ì„œë¸Œë¼ìš°íŠ¸ ë‹¨ìœ„)</div>
      <input id="vendorNameInput" type="text" placeholder="ë²¤ë” ì´ë¦„" />
      <div style="height:8px"></div>
      <input id="vendorBizInput" type="text" placeholder="ì‚¬ì—…ìë²ˆí˜¸ (ì˜ˆ: 123-45-67890)" />

      <div style="height:10px"></div>
      <div class="row">
        <button id="vendorSaveBtn" class="btn ok">ë²¤ë” ì €ì¥</button>
        <button id="vendorClearBtn" class="btn danger">ë²¤ë” ë¹„ìš°ê¸°</button>
      </div>

      <div class="help">
        - ì„ íƒëœ ë¼ìš°íŠ¸ì˜ ë²¤ë” ì •ë³´ë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
      </div>

      <div class="sep"></div>

      <div class="label">ì…ì°¨ì§€ ì •ë³´(ì„œë¸Œë¼ìš°íŠ¸ ë‹¨ìœ„)</div>
      <input id="deliveryNameInput" type="text" placeholder="ì…ì°¨ì§€ ì´ë¦„ (ì˜ˆ: ë³¸ìº í”„, ì‹ì‚¬ë™MB)" />
      <div style="height:8px"></div>
      <input id="deliveryAddrInput" type="text" placeholder="ì…ì°¨ì§€ ì£¼ì†Œ (ì˜ˆ: ê²½ê¸° ê¹€í¬ì‹œ ì–‘ì´Œì ëŒ€í¬ì‚°ë‹¨ë¡œ 73)" />

      <div style="height:10px"></div>
      <div class="row">
        <button id="deliveryNaviBtn" class="btn warn">ì¹´ì¹´ì˜¤ë‚´ë¹„</button>
        <button id="deliverySaveBtn" class="btn ok">ì…ì°¨ì§€ ì €ì¥</button>
        <button id="deliveryClearBtn" class="btn danger">ì…ì°¨ì§€ ë¹„ìš°ê¸°</button>
      </div>

      <div class="help">
        - ì¹´ì¹´ì˜¤ë‚´ë¹„: ì…ë ¥í•œ ì£¼ì†Œë¡œ ì¹´ì¹´ì˜¤ë§µ/ë‚´ë¹„ ì‹¤í–‰<br/>
        - ì„ íƒëœ ë¼ìš°íŠ¸ì˜ ì…ì°¨ì§€ ì •ë³´ë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
      </div>
    </div>

    <div class="group" id="addressListGroup" style="display:none">
      <div class="label">ë°°ì†¡ì§€ ëª©ë¡ (ì…ì°¨ì§€â†’ë°°ì†¡ì§€ ë„¤ë¹„)</div>
      <div id="addressList" style="max-height:300px; overflow-y:auto; margin-top:8px;"></div>
      <div class="help small" style="margin-top:8px;">
        ê° ë°°ì†¡ì§€ë¡œ ê°€ëŠ” ê²½ë¡œë¥¼ ì¹´ì¹´ì˜¤ë‚´ë¹„ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
      </div>
    </div>

    <div class="group">
      <div class="row">
        <button id="loadBtn" class="btn">ë¶ˆëŸ¬ì˜¤ê¸°</button>
        <button id="drawNewBtn" class="btn warn">ìƒˆë¡œ ê·¸ë¦¬ê¸°</button>
        <button id="drawAddBtn" class="btn warn">êµ¬ì—­ ì¶”ê°€</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="saveBtn" class="btn ok">ì €ì¥</button>
        <button id="deletePolyBtn" class="btn danger">í´ë¦¬ê³¤ ì‚­ì œ</button>
        <button id="alignBtn" class="btn">ì§€ë„ ì •ë ¬</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="addrBtn" class="btn">ì£¼ì†Œê²€ìƒ‰</button>
        <button id="labelToggleBtn" class="btn">ë¼ìš°íŠ¸ ë¼ë²¨ ON</button>
        <button id="resetBtn" class="btn">ì§€ë„ ì´ˆê¸°í™”</button>
      </div>

      <div class="help">
        - í¸ì§‘: í´ë¦¬ê³¤ í´ë¦­ â†’ ê¼­ì§“ì  ë“œë˜ê·¸ë¡œ ìˆ˜ì •, ìš°í´ë¦­ìœ¼ë¡œ ì  ì‚­ì œ<br/>
        - ìƒˆë¡œ ê·¸ë¦¬ê¸°: Enterë¡œ ì™„ë£Œ, ìš°í´ë¦­ìœ¼ë¡œ ì·¨ì†Œ, ESCë¡œ ë‚˜ê°€ê¸°<br/>
        - êµ¬ì—­ ì¶”ê°€: ê°™ì€ ì½”ë“œì— í´ë¦¬ê³¤ ì¶”ê°€ (ë‹¤êµ¬ì—­ ì§€ì›)<br/>
        - ì§€ë„ ì •ë ¬: OSM ë„ë¡œ/ê±´ë¬¼ ì˜¤ë²„ë ˆì´ í‘œì‹œ
      </div>
    </div>

    <div class="logWrap">
      <div class="logHeader">
        <span class="pill" id="statusPill">READY</span>
        <span class="small" id="selectedInfo">ì„ íƒ: ì—†ìŒ</span>
      </div>
      <div class="log" id="log"></div>
    </div>

    <div class="help small" style="margin-top:10px;">
      ğŸ’¡ íŒ: ì¤‘ê°„ ì (íšŒìƒ‰)ì„ í´ë¦­í•˜ë©´ ìƒˆ ê¼­ì§“ì  ì¶”ê°€, ê¼­ì§“ì  ìš°í´ë¦­ìœ¼ë¡œ ì‚­ì œ
    </div>
  </div>

  <div class="map">
    <div id="map"></div>
    <div class="floatingHint" id="hint"></div>
  </div>
</div>

<script>
(() => {
  // ====== í™˜ê²½ ì„¤ì • ======
  const API_BASE = "https://route.maroowell.com"; // í•„ìš”ì‹œ ë³€ê²½
  const ROUTE_ENDPOINT = `${API_BASE}/route`;
  const OSM_ENDPOINT = `${API_BASE}/osm`;
  const ADDRESS_ENDPOINT = `${API_BASE}/addresses`;

  // ====== DOM ======
  const $ = (id) => document.getElementById(id);
  const campInput = $("campInput");
  const codeInput = $("codeInput");
  const vendorNameInput = $("vendorNameInput");
  const vendorBizInput = $("vendorBizInput");
  const deliveryNameInput = $("deliveryNameInput");
  const deliveryAddrInput = $("deliveryAddrInput");

  const loadBtn = $("loadBtn");
  const drawNewBtn = $("drawNewBtn");
  const drawAddBtn = $("drawAddBtn");
  const addrBtn = $("addrBtn");
  const saveBtn = $("saveBtn");
  const deletePolyBtn = $("deletePolyBtn");
  const alignBtn = $("alignBtn");
  const labelToggleBtn = $("labelToggleBtn");
  const resetBtn = $("resetBtn");
  const vendorSaveBtn = $("vendorSaveBtn");
  const vendorClearBtn = $("vendorClearBtn");
  const deliveryNaviBtn = $("deliveryNaviBtn");
  const deliverySaveBtn = $("deliverySaveBtn");
  const deliveryClearBtn = $("deliveryClearBtn");

  const logEl = $("log");
  const statusPill = $("statusPill");
  const selectedInfo = $("selectedInfo");
  const hintEl = $("hint");

  // ====== ë¡œê·¸ ======
  const ts = () => {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    const ss = String(d.getSeconds()).padStart(2,"0");
    return `[${hh}:${mm}:${ss}]`;
  };
  function setStatus(t, kind="READY") {
    statusPill.textContent = kind;
    statusPill.style.borderColor =
      kind === "ERR" ? "rgba(255,60,60,.35)" :
      kind === "WARN" ? "rgba(255,180,0,.30)" :
      kind === "OK" ? "rgba(0,255,140,.22)" :
      "rgba(255,255,255,.10)";
    statusPill.style.background =
      kind === "ERR" ? "rgba(255,60,60,.12)" :
      kind === "WARN" ? "rgba(255,180,0,.10)" :
      kind === "OK" ? "rgba(0,255,140,.08)" :
      "rgba(255,255,255,.04)";
    if (t) log(`${kind} ${t}`);
  }
  function log(msg) {
    logEl.textContent += `${ts()} ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function hint(msg, show=true) {
    hintEl.textContent = msg;
    hintEl.style.display = show ? "block" : "none";
  }

  // ====== ìƒíƒœ ======
  let map, geocoder;

  /** @type {Array<any>} */
  let routeRows = []; // APIì—ì„œ ë°›ì€ rowë“¤
  let addressRows = []; // ë°°ì†¡ì§€ ëª©ë¡

  /**
   * rowId -> { row, polygons: kakao.maps.Polygon[], labels: kakao.maps.CustomOverlay[] }
   */
  const overlayById = new Map();

  // í¸ì§‘(ë²„í…ìŠ¤ í•¸ë“¤) ìƒíƒœ
  let selectedRouteId = null;
  let editHandles = []; // kakao.maps.Marker[]
  let editPolygons = []; // kakao.maps.Polygon[]
  let labelOn = true;
  
  // ì»¤ìŠ¤í…€ ë“œë˜ê·¸ ìƒíƒœ
  let draggingVertex = null; // { marker, polygon, index }

  // ê·¸ë¦¬ê¸° ìƒíƒœ
  let drawMode = null; // "new" | "add" | null
  let drawPoints = []; // kakao.maps.LatLng[]
  let drawMarkers = []; // kakao.maps.Marker[]
  let drawLine = null; // kakao.maps.Polyline

  // OSM ì˜¤ë²„ë ˆì´
  let osmOverlays = [];

  // ====== ì»¬ëŸ¬ íŒ”ë ˆíŠ¸(ì¸ì ‘ ìƒ‰ êµ¬ë¶„ ê°•í™”) ======
  // (Hue ê· ë“± + ëŒ€ë¹„ í° íŒ”ë ˆíŠ¸)
  const COLOR_PALETTE = [
    "#00C2FF", "#FF4D6D", "#FFD166", "#06D6A0", "#A78BFA",
    "#F97316", "#22C55E", "#E11D48", "#3B82F6", "#F59E0B",
    "#14B8A6", "#8B5CF6", "#84CC16", "#EC4899", "#0EA5E9",
    "#EF4444", "#10B981", "#FBBF24", "#6366F1", "#FB7185"
  ];
  function hashCode(str) {
    let h = 0;
    for (let i=0;i<str.length;i++){
      h = (h<<5) - h + str.charCodeAt(i);
      h |= 0;
    }
    return Math.abs(h);
  }
  function colorFor(code) {
    const idx = hashCode(code) % COLOR_PALETTE.length;
    return COLOR_PALETTE[idx];
  }

  // ====== API ======
  async function apiGet(url) {
    const res = await fetch(url, { method:"GET" });
    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}
    if (!res.ok) {
      const msg = json?.error || text || `HTTP ${res.status}`;
      throw new Error(msg);
    }
    return json;
  }
  async function apiJson(method, url, body) {
    const res = await fetch(url, {
      method,
      headers: { "Content-Type":"application/json" },
      body: body ? JSON.stringify(body) : undefined
    });
    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}
    if (!res.ok) {
      const msg = json?.error || text || `HTTP ${res.status}`;
      throw new Error(msg);
    }
    return json;
  }

  // ====== ìœ í‹¸: polygon_wgs84 íŒŒì‹± ======
  function parsePolygonWgs84(v, debugId = "") {
    if (!v) return null;
    if (Array.isArray(v)) return v;
    if (typeof v === "string") {
      try {
        const p = JSON.parse(v);
        if (Array.isArray(p)) return p;
      } catch (e) {
        if (debugId) log(`âš  í´ë¦¬ê³¤ íŒŒì‹± ì‹¤íŒ¨: ${debugId}`);
      }
    }
    return null;
  }

  // ====== ì§€ë„ ì˜¤ë²„ë ˆì´ ì •ë¦¬ ======
  function clearAllOverlays() {
    stopEditing();
    stopDraw(true);
    clearOsm();

    for (const {polygons, labels} of overlayById.values()) {
      polygons.forEach(p => p.setMap(null));
      labels.forEach(l => l.setMap(null));
    }
    overlayById.clear();
    routeRows = [];
    selectedRouteId = null;
    selectedInfo.textContent = "ì„ íƒ: ì—†ìŒ";
  }

  function clearOsm() {
    osmOverlays.forEach(o => o.setMap(null));
    osmOverlays = [];
  }

  // ====== ë¼ë²¨ ======
  function centroidOfLatLngs(latlngs) {
    let latSum=0, lngSum=0;
    for (const ll of latlngs) { latSum += ll.getLat(); lngSum += ll.getLng(); }
    return new kakao.maps.LatLng(latSum/latlngs.length, lngSum/latlngs.length);
  }
  function createLabelOverlay(text, position, color) {
    const el = document.createElement("div");
    el.style.padding = "4px 8px";
    el.style.borderRadius = "999px";
    el.style.background = "rgba(0,0,0,.55)";
    el.style.color = "#fff";
    el.style.fontSize = "12px";
    el.style.border = "1px solid rgba(255,255,255,.18)";
    el.style.whiteSpace = "nowrap";
    el.style.boxShadow = "0 2px 10px rgba(0,0,0,.35)";
    el.style.transform = "translateY(-2px)";
    el.innerHTML = `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color};margin-right:6px;vertical-align:middle;"></span>${escapeHtml(text)}`;

    return new kakao.maps.CustomOverlay({
      position,
      content: el,
      yAnchor: 1.0,
      zIndex: 10
    });
  }
  function escapeHtml(s) {
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ====== í´ë¦¬ê³¤ ìƒì„± ======
  function makePolygon(latlngs, strokeColor, fillColor, zIndex=1) {
    return new kakao.maps.Polygon({
      path: latlngs, // ë°˜ë“œì‹œ LatLng[]
      strokeWeight: 6,
      strokeColor,
      strokeOpacity: 1.0,
      strokeStyle: "solid",
      fillColor,
      fillOpacity: 0.15,
      zIndex
    });
  }

  // ====== ë°ì´í„° í‘œì‹œ ======
  function renderRoutes(rows) {
    clearAllOverlays();
    routeRows = rows || [];

    if (!routeRows.length) {
      setStatus("í‘œì‹œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.", "WARN");
      return;
    }

    let bounds = new kakao.maps.LatLngBounds();
    let any = false;

    for (const row of routeRows) {
      const id = row.id;
      const code = row.full_code || row.code || row.route_code || "";
      const camp = row.camp || row.camp_name || "";
      const color = row.color || colorFor(code);
      const debugId = `${camp}/${code}(id=${id})`;
      
      const poly = parsePolygonWgs84(row.polygon_wgs84, debugId);

      const polygons = [];
      const labels = [];

      if (poly && Array.isArray(poly) && poly.length > 0) {
        // ë°ì´í„° í˜•ì‹ ìë™ ê°ì§€:
        // 1. [ [{lat,lng}, ...], [{lat,lng}, ...] ] - ë‹¤ì¤‘ ë§ (ë§ ë°°ì—´)
        // 2. [ {lat,lng}, {lat,lng}, ... ] - ë‹¨ì¼ ë§ (ì  ë°°ì—´)
        // 3. [ [[lng,lat], ...], [[lng,lat], ...] ] - ë‹¤ì¤‘ ë§ (GeoJSON ìŠ¤íƒ€ì¼)
        // 4. [ [lng,lat], [lng,lat], ... ] - ë‹¨ì¼ ë§ (GeoJSON ìŠ¤íƒ€ì¼)
        
        let rings = [];
        
        // ì²« ë²ˆì§¸ ìš”ì†Œë¡œ í˜•ì‹ íŒë‹¨
        const first = poly[0];
        if (first && typeof first === 'object' && 'lat' in first && 'lng' in first) {
          rings = [poly];
        } else if (Array.isArray(first)) {
          const firstOfFirst = first[0];
          if (firstOfFirst && typeof firstOfFirst === 'object' && 'lat' in firstOfFirst) {
            rings = poly;
          } else if (Array.isArray(firstOfFirst) && firstOfFirst.length >= 2) {
            rings = poly;
          } else if (typeof firstOfFirst === 'number') {
            rings = [poly];
          }
        }

        for (let i=0; i<rings.length; i++) {
          const ring = rings[i];
          if (!Array.isArray(ring) || ring.length < 3) continue;

          // ë‘ í˜•ì‹ ëª¨ë‘ ì§€ì›: [lng, lat] ë°°ì—´ ë˜ëŠ” {lat, lng} ê°ì²´
          const latlngs = ring.map(pt => {
            if (pt && typeof pt === 'object' && 'lat' in pt && 'lng' in pt) {
              return new kakao.maps.LatLng(pt.lat, pt.lng);
            } else if (Array.isArray(pt) && pt.length >= 2) {
              return new kakao.maps.LatLng(pt[1], pt[0]);
            }
            return null;
          }).filter(ll => ll !== null);

          if (latlngs.length < 3) continue;
          const p = makePolygon(latlngs, color, color, 1);
          p.setMap(map);

          // í´ë¦­ìœ¼ë¡œ í¸ì§‘ ì§„ì… (ê·¸ë¦¬ê¸° ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ)
          kakao.maps.event.addListener(p, "click", () => {
            if (!drawMode) startEditing(id);
          });

          polygons.push(p);
          any = true;
          latlngs.forEach(ll => bounds.extend(ll));

          if (labelOn) {
            const c = centroidOfLatLngs(latlngs);
            const label = createLabelOverlay(code, c, color);
            label.setMap(map);
            labels.push(label);
          }
        }
      }

      overlayById.set(id, { row, polygons, labels });
    }

    const totalPolygons = Array.from(overlayById.values()).reduce((sum, pack) => sum + pack.polygons.length, 0);
    
    if (any) {
      map.setBounds(bounds);
      setStatus(`${routeRows.length}ê°œ ë¼ìš°íŠ¸ ë¡œë“œ ì™„ë£Œ`, "OK");
    } else {
      setStatus(`í´ë¦¬ê³¤ ë°ì´í„° ì—†ìŒ. ìƒˆë¡œ ê·¸ë¦¬ê¸°ë¡œ ìƒì„±í•˜ì„¸ìš”.`, "WARN");
    }
  }

  // ====== í¸ì§‘(ë²„í…ìŠ¤ í•¸ë“¤) ======
  let VERTEX_IMG = null;
  let MID_IMG = null;

  function makeHandleImage(fill="#ffffff", stroke="#111827") {
    // SVG ë°ì´í„° URI (ì‘ì€ í¬ê¸°)
    const svg =
      `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12">
        <circle cx="6" cy="6" r="5" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
      </svg>`;
    const uri = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    return new kakao.maps.MarkerImage(uri, new kakao.maps.Size(12,12), { offset: new kakao.maps.Point(6,6) });
  }

  function stopEditing() {
    editHandles.forEach(m => m.setMap(null));
    editHandles = [];
    editPolygons = [];
    draggingVertex = null; // ë“œë˜ê·¸ ìƒíƒœ ì´ˆê¸°í™”
    map.setDraggable(true); // ì§€ë„ ë“œë˜ê·¸ ì¬í™œì„±í™”

    // ì„ íƒ ê°•ì¡° í•´ì œ(ì›ë³µ)
    for (const {row, polygons} of overlayById.values()) {
      const base = row.color || colorFor(row.full_code || "");
      polygons.forEach(p => {
        p.setOptions({
          strokeColor: base,
          fillColor: base,
          strokeWeight: 6,
          fillOpacity: 0.15,
          zIndex: 1
        });
      });
    }
  }

  function startEditing(routeId) {
    if (!overlayById.has(routeId)) return;

    stopDraw(true); // ê·¸ë¦¬ê¸° ì¤‘ì´ë©´ ì¤‘ë‹¨
    stopEditing();

    selectedRouteId = routeId;
    const pack = overlayById.get(routeId);
    const { row, polygons } = pack;

    const code = row.full_code || "";
    const camp = row.camp || "";
    selectedInfo.textContent = `ì„ íƒ: ${camp} / ${code} (id=${routeId})`;
    
    // ì„ íƒí•œ ë¼ìš°íŠ¸ì˜ ë°°ì†¡ì§€ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
    campInput.value = camp;
    codeInput.value = code;
    loadAddresses().catch(err => log(`ë°°ì†¡ì§€ ë¡œë“œ ì‹¤íŒ¨: ${err.message}`));

    // ë²¤ë” UI ë¡œë“œ
    vendorNameInput.value = row.vendor_name || "";
    vendorBizInput.value = row.vendor_business_number || "";

    // ì…ì°¨ì§€ UI ë¡œë“œ
    deliveryNameInput.value = row.delivery_location_name || "";
    deliveryAddrInput.value = row.delivery_location_address || "";

    // ì„ íƒ í´ë¦¬ê³¤ì´ ì—†ìœ¼ë©´(= polygon_wgs84 null) í¸ì§‘í•  ê²Œ ì—†ìŒ â†’ ìƒˆë¡œ ê·¸ë¦¬ê¸° ìœ ë„
    if (!polygons || polygons.length === 0) {
      setStatus(`ì„ íƒ ëŒ€ìƒ ${code}ëŠ” polygonì´ ì—†ìŠµë‹ˆë‹¤. "ìƒˆë¡œ ê·¸ë¦¬ê¸°"ë¡œ ìƒì„±í•˜ì„¸ìš”.`, "WARN");
      return;
    }

    // ê°•ì¡°
    polygons.forEach(p => {
      p.setOptions({ strokeWeight: 8, fillOpacity: 0.25, zIndex: 5 });
    });

    editPolygons = polygons.slice();

    // ê° í´ë¦¬ê³¤ë³„ë¡œ í•¸ë“¤ ìƒì„±
    rebuildHandles();
    setStatus(`í¸ì§‘ ëª¨ë“œ: ${code} (ê¼­ì§“ì  ë“œë˜ê·¸ë¡œ ìˆ˜ì •)`, "OK");
  }

  function rebuildHandles() {
    // ê¸°ì¡´ ì œê±°
    editHandles.forEach(m => m.setMap(null));
    editHandles = [];

    for (const polygon of editPolygons) {
      const rawPath = polygon.getPath();
      if (!rawPath) {
        log(`âš  rebuildHandles: polygon.getPath()ê°€ null`);
        continue;
      }
      
      // ë°°ì—´ë¡œ ë³€í™˜ (MVCArrayë“  Arrayë“ )
      const path = [];
      const len = Array.isArray(rawPath) ? rawPath.length : (rawPath.getLength ? rawPath.getLength() : 0);
      for (let i = 0; i < len; i++) {
        path.push(Array.isArray(rawPath) ? rawPath[i] : rawPath.getAt(i));
      }
      
      if (path.length < 3) continue;

      // Vertex handles (ì»¤ìŠ¤í…€ ë“œë˜ê·¸ êµ¬í˜„)
      for (let i=0;i<path.length;i++) {
        ((index, polygon) => {
          const vMarker = new kakao.maps.Marker({
            position: path[index],
            image: VERTEX_IMG,
            clickable: true,
            zIndex: 20
          });
          
          vMarker.setMap(map);

          // ë§ˆìš°ìŠ¤ ë‹¤ìš´: ë“œë˜ê·¸ ì‹œì‘
          kakao.maps.event.addListener(vMarker, "mousedown", (e) => {
            draggingVertex = { marker: vMarker, polygon, index };
            map.setDraggable(false); // ì§€ë„ ë“œë˜ê·¸ ë¹„í™œì„±í™”
            
            // ê¸°ë³¸ ë™ì‘ ë°©ì§€
            if (e && e.domEvent) {
              e.domEvent.preventDefault();
              e.domEvent.stopPropagation();
            }
          });

          // ìš°í´ë¦­: ì  ì‚­ì œ(ìµœì†Œ 3ê°œ ìœ ì§€)
          kakao.maps.event.addListener(vMarker, "rightclick", () => {
            const pth = polygon.getPath();
            const len = Array.isArray(pth) ? pth.length : (pth.getLength ? pth.getLength() : 0);
            if (len <= 3) {
              setStatus("ì  ì‚­ì œ ë¶ˆê°€: ìµœì†Œ 3ê°œ ê¼­ì§“ì  ìœ ì§€ í•„ìš”", "WARN");
              return;
            }
            // ë°°ì—´ë¡œ ë³€í™˜ í›„ ì  ì‚­ì œ
            const pathArray = [];
            for (let j = 0; j < len; j++) {
              if (j !== index) {
                pathArray.push(Array.isArray(pth) ? pth[j] : pth.getAt(j));
              }
            }
            polygon.setPath(pathArray);
            updateSelectedLabels();
            rebuildHandles();
          });

          editHandles.push(vMarker);
        })(i, polygon);
      }

      // Midpoint handles (ì  ì¶”ê°€)
      for (let i=0;i<path.length;i++) {
        ((index, polygon) => {
          const a = path[index];
          const b = path[(index+1)%path.length];

          const mid = new kakao.maps.LatLng(
            (a.getLat()+b.getLat())/2,
            (a.getLng()+b.getLng())/2
          );

          const midMarker = new kakao.maps.Marker({
            position: mid,
            clickable: true,
            image: MID_IMG,
            zIndex: 19
          });
          midMarker.setMap(map);

          kakao.maps.event.addListener(midMarker, "click", () => {
            const pth = polygon.getPath();
            const len = Array.isArray(pth) ? pth.length : (pth.getLength ? pth.getLength() : 0);
            // ë°°ì—´ë¡œ ë³€í™˜ í›„ ì  ì¶”ê°€
            const pathArray = [];
            for (let j = 0; j < len; j++) {
              pathArray.push(Array.isArray(pth) ? pth[j] : pth.getAt(j));
              if (j === index) {
                pathArray.push(mid);
              }
            }
            polygon.setPath(pathArray);
            updateSelectedLabels();
            rebuildHandles();
          });

          editHandles.push(midMarker);
        })(i, polygon);
      }
    }
  }

  function updateSelectedLabels() {
    if (!selectedRouteId) return;
    const pack = overlayById.get(selectedRouteId);
    if (!pack) return;
    const { row, polygons, labels } = pack;
    if (!labelOn) return;

    // ë¼ë²¨ ì œê±° í›„ ì¬ìƒì„±
    labels.forEach(l => l.setMap(null));
    pack.labels = [];

    const code = row.full_code || "";
    const color = row.color || colorFor(code);

    for (const p of polygons) {
      const rawPath = p.getPath();
      // MVCArrayë“  ë°°ì—´ì´ë“  ì¼ë°˜ ë°°ì—´ë¡œ ë³€í™˜
      const path = [];
      if (rawPath && typeof rawPath.getLength === 'function') {
        for (let i = 0; i < rawPath.getLength(); i++) {
          path.push(rawPath.getAt(i));
        }
      } else if (Array.isArray(rawPath)) {
        path.push(...rawPath);
      }
      
      if (path.length < 3) continue;
      const c = centroidOfLatLngs(path);
      const label = createLabelOverlay(code, c, color);
      label.setMap(map);
      pack.labels.push(label);
    }
  }

  // ====== ê·¸ë¦¬ê¸° ëª¨ë“œ ======
  function stopDraw(silent=false) {
    drawMode = null;
    drawPoints = [];
    drawMarkers.forEach(m => m.setMap(null));
    drawMarkers = [];
    if (drawLine) { drawLine.setMap(null); drawLine = null; }
    if (!silent) hint("", false);
  }

  function beginDraw(mode) {
    const camp = campInput.value.trim();
    const code = codeInput.value.trim();
    if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }
    if (!code) { setStatus("codeê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤. (ìƒˆë¡œ ê·¸ë¦¬ê¸°/êµ¬ì—­ ì¶”ê°€ëŠ” code í•„ìˆ˜)", "ERR"); return; }

    stopEditing();
    stopDraw(true);

    drawMode = mode; // new | add
    drawPoints = [];
    drawMarkers = [];

    if (drawLine) drawLine.setMap(null);
    drawLine = new kakao.maps.Polyline({
      path: [],
      strokeWeight: 3,
      strokeColor: "#00C2FF",
      strokeOpacity: 0.9,
      strokeStyle: "shortdash"
    });
    drawLine.setMap(map);

    hint("ê·¸ë¦¬ê¸° ëª¨ë“œ: ì§€ë„ í´ë¦­ìœ¼ë¡œ ì  ì¶”ê°€ Â· Enterí‚¤ë¡œ ì™„ë£Œ Â· ìš°í´ë¦­ìœ¼ë¡œ ë§ˆì§€ë§‰ ì  ì·¨ì†Œ Â· ESCë¡œ ì·¨ì†Œ", true);
    setStatus(mode === "new" ? "ìƒˆë¡œ ê·¸ë¦¬ê¸° ì‹œì‘" : "êµ¬ì—­ ì¶”ê°€ ì‹œì‘", "OK");
  }

  function addDrawPoint(latlng) {
    drawPoints.push(latlng);

    // ì‘ì€ ì  ë§ˆì»¤ ìƒì„± (ë°”ë‹¤ìƒ‰)
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
      <circle cx="5" cy="5" r="4" fill="#00C2FF" stroke="#0b1220" stroke-width="1.5"/>
    </svg>`;
    const markerImageSrc = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    const markerImage = new kakao.maps.MarkerImage(markerImageSrc, new kakao.maps.Size(10, 10), {
      offset: new kakao.maps.Point(5, 5)
    });

    const m = new kakao.maps.Marker({
      position: latlng,
      image: markerImage,
      zIndex: 30
    });
    m.setMap(map);
    drawMarkers.push(m);

    drawLine.setPath(drawPoints);
  }

  function popDrawPoint() {
    if (drawPoints.length === 0) return;
    drawPoints.pop();
    const m = drawMarkers.pop();
    if (m) m.setMap(null);
    drawLine.setPath(drawPoints);
  }

  function finishDraw() {
    if (drawPoints.length < 3) {
      setStatus("í´ë¦¬ê³¤ ìƒì„± ì‹¤íŒ¨: ì ì´ 3ê°œ ì´ìƒ í•„ìš”", "WARN");
      return;
    }

    const camp = campInput.value.trim();
    const code = codeInput.value.trim();
    const color = colorFor(code);

    // ì„ íƒ ë¼ìš°íŠ¸ rowê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ê¸°ì¤€ìœ¼ë¡œ. ì—†ìœ¼ë©´ camp+codeë¡œ ê°€ìƒì˜ rowë¥¼ ë§Œë“ ë‹¤ê³  ìƒê°(ì €ì¥ ì‹œ ì—…ì„œíŠ¸)
    let rowId = selectedRouteId;
    let row = null;

    if (rowId && overlayById.has(rowId)) {
      row = overlayById.get(rowId).row;
      // ì„ íƒëœ rowê°€ ë‹¤ë¥¸ ì½”ë“œë©´(ì…ë ¥ ë°”ê¿¨ëŠ”ë°) í˜¼ë™ ë°©ì§€: ì…ë ¥ code ìš°ì„ 
    }

    // ê¸°ì¡´ í´ë¦¬ê³¤ ì œê±°(ìƒˆë¡œ ê·¸ë¦¬ê¸°)
    if (drawMode === "new") {
      if (rowId && overlayById.has(rowId)) {
        const pack = overlayById.get(rowId);
        pack.polygons.forEach(p => p.setMap(null));
        pack.labels.forEach(l => l.setMap(null));
        pack.polygons = [];
        pack.labels = [];
      } else {
        // ì„ íƒì´ ì—†ëŠ”ë° ìƒˆë¡œ ê·¸ë¦¬ê¸°ë©´: í˜„ì¬ camp+codeì™€ ë§¤ì¹­ë˜ëŠ” rowê°€ ì´ë¯¸ ë¡œë“œë˜ì–´ ìˆìœ¼ë©´ ê·¸ê±¸ ì°¾ì•„ ì œê±°
        for (const [id, pack] of overlayById.entries()) {
          const r = pack.row;
          if ((r.camp||"") === camp && (r.full_code||"") === code) {
            rowId = id;
            pack.polygons.forEach(p => p.setMap(null));
            pack.labels.forEach(l => l.setMap(null));
            pack.polygons = [];
            pack.labels = [];
            break;
          }
        }
      }
    }

    // í´ë¦¬ê³¤ ìƒì„±
    const poly = makePolygon(drawPoints.slice(), color, color, 5);
    poly.setMap(map);
    kakao.maps.event.addListener(poly, "click", () => {
      // í´ë¦­í•˜ë©´ í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ìœ ì§€ (ê·¸ë¦¬ê¸° ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ)
      if (rowId && !drawMode) startEditing(rowId);
    });

    // rowIdê°€ ì—†ìœ¼ë©´ ì„ì‹œë¡œ ìƒì„±(ì €ì¥í•˜ë©´ ì‹¤ì œ row ìƒê¹€). ì´ ê²½ìš° id ë§µí•‘ì´ ì—†ì–´ì„œ í¸ì§‘ ìƒíƒœ ê´€ë¦¬ë¥¼ ìœ„í•´ ì„ì‹œ IDë¥¼ ë¶€ì—¬.
    if (!rowId) {
      rowId = `tmp_${camp}_${code}`;
      // overlayByIdëŠ” id keyê°€ stringì´ì–´ë„ ë¨(ë§µ ê¸°ì¤€)
      overlayById.set(rowId, {
        row: { 
          id: rowId, 
          camp, 
          full_code: code, 
          color, 
          polygon_wgs84: null, 
          vendor_name: vendorNameInput.value.trim(), 
          vendor_business_number: vendorBizInput.value.trim(),
          delivery_location_name: deliveryNameInput.value.trim(),
          delivery_location_address: deliveryAddrInput.value.trim()
        },
        polygons: [],
        labels: []
      });
    }

    const pack = overlayById.get(rowId);
    pack.row.camp = camp;
    pack.row.full_code = code;
    pack.row.color = color;

    pack.polygons.push(poly);

    if (labelOn) {
      const c = centroidOfLatLngs(drawPoints);
      const label = createLabelOverlay(code, c, color);
      label.setMap(map);
      pack.labels.push(label);
    }

    // ê·¸ë¦¬ê¸° ì¢…ë£Œ -> ì¦‰ì‹œ í¸ì§‘ ëª¨ë“œë¡œ ì „í™˜
    stopDraw(true);
    selectedRouteId = rowId;
    selectedInfo.textContent = `ì„ íƒ: ${camp} / ${code} (id=${rowId})`;
    editPolygons = pack.polygons.slice();
    rebuildHandles();
    hint("", false);

    setStatus(`í´ë¦¬ê³¤ ìƒì„± ì™„ë£Œ: ${drawMode === "new" ? "êµì²´" : "ì¶”ê°€"} 1ê°œ`, "OK");
  }

  // ====== ì €ì¥ ë°ì´í„° ë§Œë“¤ê¸° ======
  function getCurrentEditedPolygonWgs84ById(id) {
    const pack = overlayById.get(id);
    if (!pack) return null;
    const polys = pack.polygons;
    if (!polys || polys.length === 0) return null;

    // return: [ [ [lng,lat], ... ], [ [lng,lat], ... ] ]
    const out = [];
    for (const p of polys) {
      const path = p.getPath();
      if (!path || path.length < 3) continue;
      const ring = [];
      for (let i=0;i<path.length;i++) {
        const ll = path[i];
        ring.push([ ll.getLng(), ll.getLat() ]);
      }
      out.push(ring);
    }
    return out.length ? out : null;
  }

  // ====== ë°°ì†¡ì§€ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ======
  async function loadAddresses() {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) return;

      const url = new URL(ADDRESS_ENDPOINT);
      url.searchParams.set("camp", camp);
      if (code) url.searchParams.set("code", code);

      const data = await apiGet(url.toString());
      addressRows = data?.rows || [];
      
      renderAddressList();
      log(`ë°°ì†¡ì§€ ${addressRows.length}ê°œ ë¡œë“œ ì™„ë£Œ`);
    } catch (e) {
      console.error('ë°°ì†¡ì§€ ë¡œë“œ ì‹¤íŒ¨:', e);
      addressRows = [];
      renderAddressList();
    }
  }

  // ====== ë°°ì†¡ì§€ ëª©ë¡ ë Œë”ë§ ======
  function renderAddressList() {
    const container = document.getElementById("addressList");
    const group = document.getElementById("addressListGroup");
    
    if (!addressRows || addressRows.length === 0) {
      group.style.display = "none";
      container.innerHTML = "";
      return;
    }

    group.style.display = "block";
    container.innerHTML = "";

    addressRows.forEach((addr, idx) => {
      const item = document.createElement("div");
      item.style.cssText = `
        padding: 8px;
        margin-bottom: 6px;
        background: rgba(0,0,0,0.15);
        border: 1px solid var(--line);
        border-radius: 8px;
        font-size: 12px;
      `;

      const addressText = addr.address || addr.full_address || "ì£¼ì†Œ ì—†ìŒ";
      const dong = addr.dong ? `<span style="color:var(--muted)">(${addr.dong})</span>` : "";
      
      item.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
          <div style="flex:1; min-width:0;">
            <div style="font-weight:600; color:var(--txt); margin-bottom:2px;">
              ${idx + 1}. ${addressText} ${dong}
            </div>
            <div style="color:var(--muted); font-size:11px;">
              ${addr.zipcode ? `ìš°í¸ë²ˆí˜¸: ${addr.zipcode}` : ""}
            </div>
          </div>
          <button class="btn" style="padding:6px 12px; font-size:11px; white-space:nowrap;" 
                  data-addr-id="${addr.id}">
            ë„¤ë¹„
          </button>
        </div>
      `;

      const naviBtn = item.querySelector("button");
      naviBtn.onclick = () => openNaviToAddress(addr);

      container.appendChild(item);
    });
  }

  // ====== ë°°ì†¡ì§€ë¡œ ë„¤ë¹„ ì‹¤í–‰ ======
  async function openNaviToAddress(addr) {
    const deliveryAddr = deliveryAddrInput.value.trim();
    
    if (!deliveryAddr) {
      setStatus("ì…ì°¨ì§€ ì£¼ì†Œë¥¼ ë¨¼ì € ì…ë ¥í•´ì£¼ì„¸ìš”.", "WARN");
      return;
    }

    if (!addr.center_wgs84) {
      setStatus("ë°°ì†¡ì§€ ì¢Œí‘œ(center_wgs84)ê°€ ì—†ìŠµë‹ˆë‹¤.", "ERR");
      return;
    }

    setStatus(`ê²½ë¡œ ê³„ì‚° ì¤‘: ì…ì°¨ì§€ â†’ ${addr.address || "ë°°ì†¡ì§€"}`, "OK");

    // 1. ì…ì°¨ì§€ ì£¼ì†Œë¥¼ ì¢Œí‘œë¡œ ë³€í™˜
    geocoder.addressSearch(deliveryAddr, (result, status) => {
      if (status !== kakao.maps.services.Status.OK || !result?.length) {
        setStatus("ì…ì°¨ì§€ ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", "ERR");
        return;
      }

      const startLat = Number(result[0].y);
      const startLng = Number(result[0].x);

      // 2. ë°°ì†¡ì§€ ì¢Œí‘œ ì¶”ì¶œ
      let endLat, endLng;
      
      if (typeof addr.center_wgs84 === 'object') {
        // {lat, lng} ë˜ëŠ” {latitude, longitude} í˜•ì‹
        endLat = addr.center_wgs84.lat || addr.center_wgs84.latitude;
        endLng = addr.center_wgs84.lng || addr.center_wgs84.lon || addr.center_wgs84.longitude;
      } else if (Array.isArray(addr.center_wgs84) && addr.center_wgs84.length >= 2) {
        // [lng, lat] ë˜ëŠ” [lat, lng] í˜•ì‹ (GeoJSONì€ [lng, lat])
        // ì¼ë°˜ì ìœ¼ë¡œ ê²½ë„ê°€ ë” í¬ë¯€ë¡œ íŒë³„
        const [first, second] = addr.center_wgs84;
        if (Math.abs(first) > Math.abs(second)) {
          // firstê°€ ê²½ë„ (126.x > 37.x)
          endLng = first;
          endLat = second;
        } else {
          // firstê°€ ìœ„ë„
          endLat = first;
          endLng = second;
        }
      }

      if (!endLat || !endLng || !isFinite(endLat) || !isFinite(endLng)) {
        setStatus("ë°°ì†¡ì§€ ì¢Œí‘œ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.", "ERR");
        log(`center_wgs84: ${JSON.stringify(addr.center_wgs84)}`);
        return;
      }

      const deliveryName = deliveryNameInput.value.trim() || "ì…ì°¨ì§€";
      const addressName = addr.address || "ë°°ì†¡ì§€";

      // 3. ì¹´ì¹´ì˜¤ë‚´ë¹„ URL ìƒì„±
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      
      let naviUrl;
      if (isMobile) {
        // ëª¨ë°”ì¼: ì¹´ì¹´ì˜¤ë§µ ì•± URL ìŠ¤í‚´ (ìë™ì°¨ ê²½ë¡œ)
        naviUrl = `kakaomap://route?sp=${startLat},${startLng}&ep=${endLat},${endLng}&by=CAR`;
      } else {
        // PC: ì¹´ì¹´ì˜¤ë§µ ì›¹ ê¸¸ì°¾ê¸° (ì˜¬ë°”ë¥¸ URL í˜•ì‹)
        // í˜•ì‹: https://map.kakao.com/link/from/ì¶œë°œì§€ëª…,ìœ„ë„,ê²½ë„/to/ëª©ì ì§€ëª…,ìœ„ë„,ê²½ë„
        naviUrl = `https://map.kakao.com/link/from/${encodeURIComponent(deliveryName)},${startLat},${startLng}/to/${encodeURIComponent(addressName)},${endLat},${endLng}`;
      }

      window.open(naviUrl, "_blank");
      setStatus(`ë„¤ë¹„ ì‹¤í–‰: ${deliveryName} â†’ ${addressName}`, "OK");
      log(`ê²½ë¡œ: (${startLat.toFixed(4)}, ${startLng.toFixed(4)}) â†’ (${endLat.toFixed(4)}, ${endLng.toFixed(4)})`);
    });
  }

  // ====== ë¶ˆëŸ¬ì˜¤ê¸° ======
  async function loadRoutes() {
    try {
      stopEditing();
      stopDraw(true);
      clearOsm();

      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }

      // ì—¬ëŸ¬ ì½”ë“œë¥¼ ì‰¼í‘œë¡œ êµ¬ë¶„í•´ì„œ ì…ë ¥í•œ ê²½ìš° ì²˜ë¦¬
      const codes = code ? code.split(/[,\s]+/).map(c => c.trim()).filter(c => c) : [];
      
      let allRows = [];
      
      if (codes.length === 0) {
        // ì½”ë“œê°€ ì—†ìœ¼ë©´ camp ì „ì²´ ì¡°íšŒ
        const url = new URL(ROUTE_ENDPOINT);
        url.searchParams.set("camp", camp);
        url.searchParams.set("mode", "prefix");
        
        const data = await apiGet(url.toString());
        
        if (!data || !data.rows) {
          setStatus("ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜", "ERR");
          return;
        }
        
        allRows = data.rows;
      } else if (codes.length === 1) {
        // ë‹¨ì¼ ì½”ë“œ
        const url = new URL(ROUTE_ENDPOINT);
        url.searchParams.set("camp", camp);
        url.searchParams.set("mode", "prefix");
        url.searchParams.set("code", codes[0]);
        
        const data = await apiGet(url.toString());
        
        if (!data || !data.rows) {
          setStatus("ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜", "ERR");
          return;
        }
        
        allRows = data.rows;
      } else {
        // ì—¬ëŸ¬ ì½”ë“œë¥¼ ê°ê° ì¡°íšŒí•´ì„œ ë³‘í•©
        setStatus(`${codes.length}ê°œ ë¼ìš°íŠ¸ ì¡°íšŒ ì¤‘...`, "OK");
        
        for (const singleCode of codes) {
          try {
            const url = new URL(ROUTE_ENDPOINT);
            url.searchParams.set("camp", camp);
            url.searchParams.set("mode", "prefix");
            url.searchParams.set("code", singleCode);
            
            const data = await apiGet(url.toString());
            
            if (data && data.rows && data.rows.length > 0) {
              allRows.push(...data.rows);
              log(`${singleCode}: ${data.rows.length}ê°œ ë°œê²¬`);
            } else {
              log(`${singleCode}: ë°ì´í„° ì—†ìŒ`);
            }
          } catch (err) {
            log(`${singleCode}: ì¡°íšŒ ì‹¤íŒ¨ - ${err.message}`);
          }
        }
      }
      
      if (allRows.length === 0) {
        setStatus("ì¡°íšŒëœ ë¼ìš°íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.", "WARN");
        clearAllOverlays();
        return;
      }
      
      renderRoutes(allRows);
      
      // ë°°ì†¡ì§€ ëª©ë¡ë„ ìë™ìœ¼ë¡œ ë¶ˆëŸ¬ì˜¤ê¸°
      await loadAddresses();
    } catch (e) {
      console.error(e);
      const errMsg = e.message || String(e);
      if (errMsg.includes("column") && errMsg.includes("does not exist")) {
        setStatus(`ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì˜¤ë¥˜: ${errMsg}. ë°±ì—”ë“œ APIë¥¼ í™•ì¸í•˜ì„¸ìš”.`, "ERR");
        log("íŒíŠ¸: ë°±ì—”ë“œì—ì„œ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì»¬ëŸ¼ì„ ì°¸ì¡°í•˜ê³  ìˆìŠµë‹ˆë‹¤.");
        log("ë°±ì—”ë“œ ì„œë²„ì˜ SQL ì¿¼ë¦¬ì™€ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆë¥¼ í™•ì¸í•˜ì„¸ìš”.");
      } else {
        setStatus(`ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${errMsg}`, "ERR");
      }
    }
  }

  // ====== ì €ì¥(POST) ======
  async function saveCurrent() {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }
      if (!code) { setStatus("codeê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }

      // ì„ íƒëœ id ê¸°ì¤€ìœ¼ë¡œ í´ë¦¬ê³¤ ì·¨í•©. ì„ íƒì´ ì—†ìœ¼ë©´ camp+codeë¡œ ì°¾ê¸°
      let id = selectedRouteId;
      if (!id || !overlayById.has(id)) {
        // camp+codeë¡œ ê²€ìƒ‰
        for (const [rid, pack] of overlayById.entries()) {
          if ((pack.row.camp||"") === camp && (pack.row.full_code||"") === code) {
            id = rid;
            break;
          }
        }
      }

      // í´ë¦¬ê³¤ ë°ì´í„° ìˆ˜ì§‘ (ì„ì‹œ ID ë˜ëŠ” ì‹¤ì œ ID ëª¨ë‘ ì‚¬ìš©)
      const polygonSourceId = id; // í´ë¦¬ê³¤ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ID ë³´ê´€
      let actualId = id; // ë°±ì—”ë“œì— ì „ì†¡í•  ì‹¤ì œ ID
      
      // actualIdê°€ ì„ì‹œ ID(ë¬¸ìì—´)ì¸ ê²½ìš°, routeRowsì—ì„œ ì‹¤ì œ ID ì°¾ê¸°
      if (actualId && typeof actualId === "string" && actualId.startsWith("tmp_")) {
        const actualRow = routeRows.find(r => 
          (r.camp||"") === camp && (r.full_code||"") === code
        );
        if (actualRow && typeof actualRow.id === "number") {
          actualId = actualRow.id;
          log(`ì„ì‹œ IDë¥¼ ì‹¤ì œ IDë¡œ ë³€í™˜: ${polygonSourceId} â†’ ${actualId}`);
        } else {
          // ì‹¤ì œ rowê°€ ì—†ìœ¼ë©´ actualIdë¥¼ undefinedë¡œ (ìƒˆë¡œ ìƒì„±)
          actualId = undefined;
          log(`ì‹¤ì œ rowê°€ ì—†ìŒ. ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.`);
        }
      }

      // í´ë¦¬ê³¤ ë°ì´í„°ëŠ” polygonSourceIdë¡œ ê°€ì ¸ì˜¤ê¸° (ì„ì‹œ IDë“  ì‹¤ì œ IDë“  overlayByIdì— ìˆëŠ” í‚¤)
      const polygon_wgs84 = polygonSourceId ? getCurrentEditedPolygonWgs84ById(polygonSourceId) : null;

      // IDê°€ ì—†ìœ¼ë©´ ë¨¼ì € í•´ë‹¹ camp+codeê°€ ì¡´ì¬í•˜ëŠ”ì§€ GETìœ¼ë¡œ í™•ì¸
      if (!actualId) {
        // routeRowsì—ì„œ ë™ì¼í•œ camp+codeë¥¼ ì°¾ì•„ì„œ ID ì‚¬ìš© (í•„ë“œëª… ì—¬ëŸ¬ ê°œ ì‹œë„)
        const existingRow = routeRows.find(r => {
          const rCamp = r.camp || r.camp_name || "";
          const rCode = r.full_code || r.code || r.route_code || "";
          return rCamp === camp && rCode === code;
        });
        if (existingRow && typeof existingRow.id === "number") {
          actualId = existingRow.id;
        } else {
          try {
            const url = new URL(ROUTE_ENDPOINT);
            url.searchParams.set("camp", camp);
            url.searchParams.set("code", code);
            url.searchParams.set("mode", "exact");
            const checkData = await apiGet(url.toString());
            if (checkData && checkData.rows && checkData.rows.length > 0) {
              actualId = checkData.rows[0].id;
            }
          } catch (checkErr) {
            // ì‹ ê·œ ìƒì„±
          }
        }
      }
      
      // payload êµ¬ì„±
      const payload = {
        camp,
        code,
        polygon_wgs84,
        vendor_name: vendorNameInput.value.trim() || null,
        vendor_business_number: vendorBizInput.value.trim() || null,
        delivery_location_name: deliveryNameInput.value.trim() || null,
        delivery_location_address: deliveryAddrInput.value.trim() || null
      };
      
      if (typeof actualId === "number") {
        payload.id = actualId;
      }

      const res = await apiJson("POST", ROUTE_ENDPOINT, payload);
      setStatus(`ì €ì¥ ì™„ë£Œ`, "OK");

      // ì €ì¥ í›„ ì¬ì¡°íšŒ(ì‹¤ì œ id ë°˜ì˜)
      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`ì €ì¥ ì‹¤íŒ¨: ${e.message}`, "ERR");
    }
  }

  // ====== í´ë¦¬ê³¤ ì‚­ì œ (polygon_wgs84=null) ======
  async function deletePolygon() {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }
      if (!code) { setStatus("codeê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }

      // ìš°ì„  ì„ íƒ idê°€ ìˆ«ìë©´ idë¡œ, ì•„ë‹ˆë©´ camp+codeë¡œ
      let id = selectedRouteId;
      const payload = (typeof id === "number") ? { id } : { camp, code };

      setStatus("DELETE /route ìš”ì²­ (polygon_wgs84=null)", "OK");
      await apiJson("DELETE", ROUTE_ENDPOINT, payload);
      setStatus("í´ë¦¬ê³¤ ì‚­ì œ ì™„ë£Œ", "OK");

      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`í´ë¦¬ê³¤ ì‚­ì œ ì‹¤íŒ¨: ${e.message}`, "ERR");
    }
  }

  // ====== ë²¤ë” ì €ì¥/ë¹„ìš°ê¸° ======
  async function saveVendorOnly(clear=false) {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }
      if (!code) { setStatus("codeê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }

      let id = selectedRouteId;
      
      // ì„ì‹œ IDë¥¼ ì‹¤ì œ IDë¡œ ë³€í™˜ ì‹œë„
      if (id && typeof id === "string" && id.startsWith("tmp_")) {
        const actualRow = routeRows.find(r => 
          (r.camp||"") === camp && (r.full_code||"") === code
        );
        if (actualRow && typeof actualRow.id === "number") {
          id = actualRow.id;
        } else {
          id = undefined;
        }
      }
      
      const payload = {
        camp,
        code,
        vendor_name: clear ? null : (vendorNameInput.value.trim() || null),
        vendor_business_number: clear ? null : (vendorBizInput.value.trim() || null),
        // polygonì€ ê±´ë“œë¦¬ì§€ ì•ŠìŒ (ëª…ì‹œì ìœ¼ë¡œ ì œì™¸)
        // ì…ì°¨ì§€ë„ ê±´ë“œë¦¬ì§€ ì•ŠìŒ
      };
      
      if (typeof id === "number") {
        payload.id = id;
      }

      setStatus(clear ? "ë²¤ë” ë¹„ìš°ê¸° ì €ì¥" : "ë²¤ë” ì €ì¥", "OK");
      await apiJson("POST", ROUTE_ENDPOINT, payload);
      setStatus(clear ? "ë²¤ë” ë¹„ìš°ê¸° ì™„ë£Œ" : "ë²¤ë” ì €ì¥ ì™„ë£Œ", "OK");
      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`ë²¤ë” ì €ì¥ ì‹¤íŒ¨: ${e.message}`, "ERR");
    }
  }

  // ====== í´ë¦¬ê³¤ ì¤‘ì‹¬ì  ê³„ì‚° ======
  function getRouteCenter() {
    if (!selectedRouteId || !overlayById.has(selectedRouteId)) return null;
    
    const pack = overlayById.get(selectedRouteId);
    const polygons = pack.polygons;
    
    if (!polygons || polygons.length === 0) return null;
    
    // ëª¨ë“  í´ë¦¬ê³¤ì˜ ì ë“¤ì„ ëª¨ì•„ì„œ ì „ì²´ ì¤‘ì‹¬ì  ê³„ì‚°
    const allPoints = [];
    for (const poly of polygons) {
      const path = poly.getPath();
      if (!path) continue;
      
      const len = Array.isArray(path) ? path.length : (path.getLength ? path.getLength() : 0);
      for (let i = 0; i < len; i++) {
        const pt = Array.isArray(path) ? path[i] : path.getAt(i);
        if (pt) allPoints.push(pt);
      }
    }
    
    if (allPoints.length === 0) return null;
    
    return centroidOfLatLngs(allPoints);
  }

  // ====== ì¹´ì¹´ì˜¤ë‚´ë¹„ ì—°ë™ (ì¶œë°œì§€â†’ë„ì°©ì§€ ê²½ë¡œ ì•ˆë‚´) ======
  async function openKakaoNavi() {
    const deliveryName = deliveryNameInput.value.trim() || "ì…ì°¨ì§€";
    const deliveryAddr = deliveryAddrInput.value.trim();
    
    if (!deliveryAddr) {
      setStatus("ì…ì°¨ì§€ ì£¼ì†Œë¥¼ ë¨¼ì € ì…ë ¥í•´ì£¼ì„¸ìš”.", "WARN");
      return;
    }
    
    if (!selectedRouteId) {
      setStatus("ë¼ìš°íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.", "WARN");
      return;
    }
    
    setStatus("ê²½ë¡œ ê³„ì‚° ì¤‘...", "OK");
    
    // 1. ì…ì°¨ì§€ ì£¼ì†Œë¥¼ ì¢Œí‘œë¡œ ë³€í™˜
    geocoder.addressSearch(deliveryAddr, (result, status) => {
      if (status !== kakao.maps.services.Status.OK || !result?.length) {
        setStatus("ì…ì°¨ì§€ ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì •í™•í•œ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.", "ERR");
        return;
      }
      
      const startLat = Number(result[0].y);
      const startLng = Number(result[0].x);
      
      // 2. ë¼ìš°íŠ¸ ì¤‘ì‹¬ì  ê³„ì‚°
      const routeCenter = getRouteCenter();
      if (!routeCenter) {
        setStatus("ë¼ìš°íŠ¸ í´ë¦¬ê³¤ì´ ì—†ìŠµë‹ˆë‹¤.", "ERR");
        return;
      }
      
      const endLat = routeCenter.getLat();
      const endLng = routeCenter.getLng();
      
      const pack = overlayById.get(selectedRouteId);
      const routeName = pack.row.full_code || "ë¼ìš°íŠ¸";
      
      // 3. ì¹´ì¹´ì˜¤ë‚´ë¹„ URL ìƒì„± (ì¶œë°œì§€â†’ë„ì°©ì§€ ê²½ë¡œ ì•ˆë‚´)
      // ëª¨ë°”ì¼: kakaomap://route ìŠ¤í‚´
      // ì›¹: ì¹´ì¹´ì˜¤ë§µ ê¸¸ì°¾ê¸° URL (ì¶œë°œì§€ + ë„ì°©ì§€)
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      
      let naviUrl;
      if (isMobile) {
        // ëª¨ë°”ì¼: ì¹´ì¹´ì˜¤ë§µ ì•± URL ìŠ¤í‚´ (ì¶œë°œì§€, ë„ì°©ì§€)
        naviUrl = `kakaomap://route?sp=${startLat},${startLng}&ep=${endLat},${endLng}&by=CAR`;
      } else {
        // PC: ì¹´ì¹´ì˜¤ë§µ ì›¹ ê¸¸ì°¾ê¸° (ì˜¬ë°”ë¥¸ URL í˜•ì‹)
        // í˜•ì‹: https://map.kakao.com/link/from/ì¶œë°œì§€ëª…,ìœ„ë„,ê²½ë„/to/ëª©ì ì§€ëª…,ìœ„ë„,ê²½ë„
        naviUrl = `https://map.kakao.com/link/from/${encodeURIComponent(deliveryName)},${startLat},${startLng}/to/${encodeURIComponent(routeName)},${endLat},${endLng}`;
      }
      
      window.open(naviUrl, "_blank");
      setStatus(`ì¹´ì¹´ì˜¤ë‚´ë¹„ ì‹¤í–‰: ${deliveryName} â†’ ${routeName}`, "OK");
      log(`ê²½ë¡œ ì•ˆë‚´: ${deliveryName} (${startLat.toFixed(4)}, ${startLng.toFixed(4)}) â†’ ${routeName} (${endLat.toFixed(4)}, ${endLng.toFixed(4)})`);
    });
  }

  // ====== ì…ì°¨ì§€ ì €ì¥/ë¹„ìš°ê¸° ======
  async function saveDeliveryOnly(clear=false) {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }
      if (!code) { setStatus("codeê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }

      let id = selectedRouteId;
      
      // ì„ì‹œ IDë¥¼ ì‹¤ì œ IDë¡œ ë³€í™˜ ì‹œë„
      if (id && typeof id === "string" && id.startsWith("tmp_")) {
        const actualRow = routeRows.find(r => 
          (r.camp||"") === camp && (r.full_code||"") === code
        );
        if (actualRow && typeof actualRow.id === "number") {
          id = actualRow.id;
        } else {
          id = undefined;
        }
      }
      
      const payload = {
        camp,
        code,
        delivery_location_name: clear ? null : (deliveryNameInput.value.trim() || null),
        delivery_location_address: clear ? null : (deliveryAddrInput.value.trim() || null),
        // polygonê³¼ vendorëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ
      };
      
      if (typeof id === "number") {
        payload.id = id;
      }

      setStatus(clear ? "ì…ì°¨ì§€ ë¹„ìš°ê¸° ì €ì¥" : "ì…ì°¨ì§€ ì €ì¥", "OK");
      await apiJson("POST", ROUTE_ENDPOINT, payload);
      setStatus(clear ? "ì…ì°¨ì§€ ë¹„ìš°ê¸° ì™„ë£Œ" : "ì…ì°¨ì§€ ì €ì¥ ì™„ë£Œ", "OK");
      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`ì…ì°¨ì§€ ì €ì¥ ì‹¤íŒ¨: ${e.message}`, "ERR");
    }
  }

  // ====== ì£¼ì†Œ ê²€ìƒ‰ ======
  function searchAddress() {
    const q = prompt("ì£¼ì†Œ ë˜ëŠ” í‚¤ì›Œë“œ ì…ë ¥");
    if (!q) return;
    geocoder.addressSearch(q, (result, status) => {
      if (status !== kakao.maps.services.Status.OK || !result?.length) {
        setStatus("ì£¼ì†Œ ê²€ìƒ‰ ì‹¤íŒ¨", "WARN");
        return;
      }
      const r = result[0];
      const lat = Number(r.y);
      const lng = Number(r.x);
      const pos = new kakao.maps.LatLng(lat, lng);
      map.setCenter(pos);
      map.setLevel(4);
      setStatus(`ì£¼ì†Œ ê²€ìƒ‰: ${q} (ì´ë™ ì™„ë£Œ)`, "OK");
    });
  }

  // ====== OSM ì •ë ¬(Overpass) ======
  async function alignWithOsm() {
    try {
      clearOsm();

      const b = map.getBounds();
      const sw = b.getSouthWest();
      const ne = b.getNorthEast();

      const bbox = `${sw.getLng()},${sw.getLat()},${ne.getLng()},${ne.getLat()}`;
      const url = new URL(OSM_ENDPOINT);
      url.searchParams.set("bbox", bbox);

      setStatus(`GET /osm ìš”ì²­: ${url.toString()}`, "OK");
      const data = await apiGet(url.toString());

      const roads = data?.roads || [];
      const buildings = data?.buildings || [];

      // roads: polyline
      for (const r of roads) {
        if (!r.coords || r.coords.length < 2) continue;
        const path = r.coords.map(([lng,lat]) => new kakao.maps.LatLng(lat,lng));
        const pl = new kakao.maps.Polyline({
          path,
          strokeWeight: 2,
          strokeColor: "#ffffff",
          strokeOpacity: 0.35,
          strokeStyle: "solid",
          zIndex: 0
        });
        pl.setMap(map);
        osmOverlays.push(pl);
      }

      // buildings: polygon (outline)
      for (const g of buildings) {
        if (!g.coords || g.coords.length < 3) continue;
        const path = g.coords.map(([lng,lat]) => new kakao.maps.LatLng(lat,lng));
        const pg = new kakao.maps.Polygon({
          path,
          strokeWeight: 1,
          strokeColor: "#ffffff",
          strokeOpacity: 0.18,
          strokeStyle: "solid",
          fillColor: "#ffffff",
          fillOpacity: 0.05,
          zIndex: 0
        });
        pg.setMap(map);
        osmOverlays.push(pg);
      }

      setStatus(`OSM í‘œì‹œ ì™„ë£Œ: roads ${roads.length}, buildings ${buildings.length}`, "OK");
    } catch (e) {
      console.error(e);
      setStatus(`OSM ì •ë ¬ ì‹¤íŒ¨: ${e.message}`, "ERR");
    }
  }

  // ====== ë¼ë²¨ í† ê¸€ ======
  function toggleLabels() {
    labelOn = !labelOn;
    labelToggleBtn.textContent = labelOn ? "ë¼ìš°íŠ¸ ë¼ë²¨ ON" : "ë¼ìš°íŠ¸ ë¼ë²¨ OFF";

    // ì „ì²´ ë¼ë²¨ ì¬êµ¬ì„±
    for (const [id, pack] of overlayById.entries()) {
      pack.labels.forEach(l => l.setMap(null));
      pack.labels = [];

      if (!labelOn) continue;

      const row = pack.row;
      const code = row.full_code || "";
      const color = row.color || colorFor(code);

      for (const p of pack.polygons) {
        const path = p.getPath();
        if (!path || path.length < 3) continue;
        const c = centroidOfLatLngs(path);
        const label = createLabelOverlay(code, c, color);
        label.setMap(map);
        pack.labels.push(label);
      }
    }
  }

  // ====== ì´ˆê¸°í™” ======
  function resetMap() {
    clearAllOverlays();
    clearOsm();
    stopDraw(true);
    hint("", false);
    setStatus("ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ.", "OK");
  }

  // ====== ì§€ë„ ì´ë²¤íŠ¸(ê·¸ë¦¬ê¸° ëª¨ë“œ + ì»¤ìŠ¤í…€ ë“œë˜ê·¸) ======
  function attachMapEvents() {
    // í´ë¦­: ì  ì¶”ê°€
    kakao.maps.event.addListener(map, "click", (mouseEvent) => {
      if (!drawMode) return;
      const latlng = mouseEvent.latLng;
      addDrawPoint(latlng);
    });

    // ìš°í´ë¦­: ë§ˆì§€ë§‰ ì  ì·¨ì†Œ
    kakao.maps.event.addListener(map, "rightclick", () => {
      if (!drawMode) return;
      popDrawPoint();
    });
    
    // ë§ˆìš°ìŠ¤ ì´ë™: ì»¤ìŠ¤í…€ ë“œë˜ê·¸ ì²˜ë¦¬ (ì „ì—­)
    const handleMouseMove = (e) => {
      if (!draggingVertex) return;
      
      // í™”ë©´ ì¢Œí‘œë¥¼ ì§€ë„ ì¢Œí‘œë¡œ ë³€í™˜
      const mapDiv = map.getNode();
      const rect = mapDiv.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Projectionì„ ì‚¬ìš©í•´ í”½ì…€ â†’ LatLng ë³€í™˜
      const proj = map.getProjection();
      const point = new kakao.maps.Point(x, y);
      const newPos = proj.coordsFromContainerPoint(point);
      
      const { marker, polygon, index } = draggingVertex;
      
      // ë§ˆì»¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
      marker.setPosition(newPos);
      
      // í´ë¦¬ê³¤ ê²½ë¡œ ì—…ë°ì´íŠ¸
      const currentPath = polygon.getPath();
      const pathArray = [];
      if (currentPath && typeof currentPath.getLength === 'function') {
        for (let j = 0; j < currentPath.getLength(); j++) {
          pathArray.push(j === index ? newPos : currentPath.getAt(j));
        }
      } else if (Array.isArray(currentPath)) {
        for (let j = 0; j < currentPath.length; j++) {
          pathArray.push(j === index ? newPos : currentPath[j]);
        }
      }
      polygon.setPath(pathArray);
      
      // ë¼ë²¨ ì—…ë°ì´íŠ¸
      updateSelectedLabels();
    };
    
    const handleMouseUp = () => {
      if (!draggingVertex) return;
      
      draggingVertex = null;
      map.setDraggable(true); // ì§€ë„ ë“œë˜ê·¸ ì¬í™œì„±í™”
      rebuildHandles(); // ë¯¸ë“œí¬ì¸íŠ¸ ì¬ìƒì„±
    };
    
    // ì „ì—­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);

    // ESC: ì·¨ì†Œ, Enter: ì™„ë£Œ
    window.addEventListener("keydown", (e) => {
      if (drawMode) {
        if (e.key === "Escape") {
          stopDraw();
          setStatus("ê·¸ë¦¬ê¸° ì·¨ì†Œ", "WARN");
        } else if (e.key === "Enter") {
          finishDraw();
        }
      } else if (e.key === "Escape") {
        // í¸ì§‘ëª¨ë“œì—ì„œ ESC ëˆ„ë¥´ë©´ í¸ì§‘ í•´ì œ
        if (selectedRouteId) {
          stopEditing();
          selectedRouteId = null;
          selectedInfo.textContent = "ì„ íƒ: ì—†ìŒ";
          setStatus("í¸ì§‘ ëª¨ë“œ í•´ì œ", "OK");
        }
      }
    });
  }

  // ====== ì´ˆê¸° êµ¬ë™ ======
  function init() {
    kakao.maps.load(() => {
      const center = new kakao.maps.LatLng(37.4936, 126.9019); // ëŒ€ëµ ëŒ€ë¦¼ì—­ ê·¼ì²˜
      map = new kakao.maps.Map($("map"), { center, level: 6 });
      geocoder = new kakao.maps.services.Geocoder();

      // í•¸ë“¤ ì´ë¯¸ì§€ ì´ˆê¸°í™” (kakao.maps.load ì´í›„ì—ë§Œ ê°€ëŠ¥)
      VERTEX_IMG = makeHandleImage("#ffffff", "#0b1220");
      MID_IMG = makeHandleImage("#93a4c7", "#0b1220");

      attachMapEvents();

      // ë²„íŠ¼ ë°”ì¸ë”©
      loadBtn.addEventListener("click", loadRoutes);
      drawNewBtn.addEventListener("click", () => beginDraw("new"));
      drawAddBtn.addEventListener("click", () => beginDraw("add"));
      addrBtn.addEventListener("click", searchAddress);
      saveBtn.addEventListener("click", saveCurrent);
      deletePolyBtn.addEventListener("click", deletePolygon);
      alignBtn.addEventListener("click", alignWithOsm);
      labelToggleBtn.addEventListener("click", toggleLabels);
      resetBtn.addEventListener("click", resetMap);

      vendorSaveBtn.addEventListener("click", () => saveVendorOnly(false));
      vendorClearBtn.addEventListener("click", () => saveVendorOnly(true));

      deliveryNaviBtn.addEventListener("click", openKakaoNavi);
      deliverySaveBtn.addEventListener("click", () => saveDeliveryOnly(false));
      deliveryClearBtn.addEventListener("click", () => saveDeliveryOnly(true));

      setStatus("ì§€ë„ ë¡œë“œ ì™„ë£Œ", "OK");

      // ìë™ ë¡œë“œ (ì‹¤íŒ¨ ì‹œ ì‚¬ìš©ìì—ê²Œ ì•ˆë‚´)
      loadRoutes().catch((err) => {
        log("ìë™ ë¡œë“œ ì‹¤íŒ¨. ë°±ì—”ë“œ API í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
        setStatus("ìë™ ë¡œë“œ ì‹¤íŒ¨ (ë°±ì—”ë“œ API ì˜¤ë¥˜). ìƒˆë¡œ ê·¸ë¦¬ê¸°ëŠ” ê°€ëŠ¥í•©ë‹ˆë‹¤.", "WARN");
      });
    });
  }

  // ì „ì—­ ì—ëŸ¬ ë¡œê¹…(ì¹´ì¹´ì˜¤ ë‚´ë¶€ Script errorë„ ìµœì†Œí•œ í‘œë©´í™”)
  window.addEventListener("error", (ev) => {
    const msg = ev?.message || "Script error.";
    log(`ERR window.error: ${msg}`);
  });

  init();
})();
</script>
</body>
</html>
