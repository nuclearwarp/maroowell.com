<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>CoupangLand (프론트 임시 MVP)</title>

  <!-- Kakao 지도 SDK -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3"></script>

  <style>
    :root{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --line:#e5e7eb;
      --brand:#6d28d9;
      --danger:#ef4444;

      --poly-stroke:#2563eb;
      --poly-fill:rgba(37,99,235,.12);
      --poly-hover-fill:rgba(37,99,235,.18);
      --poly-selected-fill:rgba(109,40,217,.18);
      --poly-stroke-weight:3;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    .wrap{
      max-width: 1400px;
      margin: 0 auto;
      padding: 18px 18px 28px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px 14px;
      box-shadow: 0 6px 18px rgba(15,23,42,.06);
    }

    .brandbox{
      display:flex;
      gap:12px;
      align-items:flex-start;
      min-width: 280px;
    }
    .dot{
      width:9px; height:9px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, #a78bfa 0%, #6d28d9 60%, #4c1d95 100%);
      margin-top:6px;
      flex:0 0 auto;
    }
    .titleline{
      display:flex;
      align-items:baseline;
      gap:10px;
      flex-wrap:wrap;
    }
    .title{
      font-weight:900;
      letter-spacing:-.2px;
      font-size:20px;
      line-height:1;
    }
    .pill{
      font-size:12px;
      padding:4px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      color:var(--muted);
      background:#fff;
    }
    .desc{
      margin-top:6px;
      font-size:13px;
      color:var(--muted);
      line-height:1.35;
    }

    /* coupang colored letters */
    .coupang span{ font-weight:900; letter-spacing:-.4px; }
    .coupang .c{ color: rgb(80,16,16); }
    .coupang .o{ color: rgb(80,16,16); }
    .coupang .u{ color: rgb(208,48,32); }
    .coupang .p{ color: rgb(224,144,32); }
    .coupang .a{ color: rgb(144,176,48); }
    .coupang .n{ color: rgb(80,160,208); }
    .coupang .g{ color: rgb(80,160,208); }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .btn{
      border:1px solid var(--line);
      background:#fff;
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      font-size:13px;
      cursor:pointer;
    }
    .btn:hover{ border-color:#cbd5e1; }
    .btn.primary{
      background: #f5f3ff;
      border-color: #ddd6fe;
      color: #4c1d95;
    }
    .btn.danger{
      background: #fff1f2;
      border-color: #fecdd3;
      color: #9f1239;
    }

    .grid{
      margin-top:14px;
      display:grid;
      grid-template-columns: 520px 1fr;
      gap:14px;
      align-items:start;
    }

    .card{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow: 0 6px 18px rgba(15,23,42,.06);
      overflow:hidden;
    }
    .card .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card .hd .h{
      font-weight:900;
      font-size:15px;
      letter-spacing:-.2px;
    }
    .badge{
      font-size:12px;
      font-weight:800;
      padding:5px 10px;
      border-radius:999px;
      background:#f1f5f9;
      color:#0f172a;
      border:1px solid var(--line);
      white-space:nowrap;
    }
    .bd{
      padding:14px;
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .search{
      flex:1;
      display:flex;
      gap:10px;
      align-items:center;
    }
    input[type="text"]{
      width:100%;
      padding:11px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      outline:none;
      font-size:14px;
      background:#fff;
    }
    input[type="text"]:focus{
      border-color:#c4b5fd;
      box-shadow: 0 0 0 3px rgba(109,40,217,.12);
    }

    .chips{
      margin-top:10px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:#fff;
      font-size:13px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
    }
    .chip:hover{ border-color:#cbd5e1; }
    .chip.active{
      border-color:#c4b5fd;
      background:#f5f3ff;
      color:#4c1d95;
    }
    .chip .mini{
      font-weight:900;
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      background:#0f172a;
      color:#fff;
    }

    #map{
      margin-top:12px;
      width:100%;
      height: 560px; /* 지도 크게 */
      border-radius:14px;
      border:1px solid var(--line);
      overflow:hidden;
    }

    .listbox{
      margin-top:12px;
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background:#fff;
    }
    .listbox .lh{
      padding:10px 12px;
      background:#f8fafc;
      border-bottom:1px solid var(--line);
      font-weight:900;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .listbox .lh small{
      color:var(--muted);
      font-weight:800;
    }
    .list{
      max-height: 220px;
      overflow:auto;
    }
    .item{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      cursor:pointer;
    }
    .item:last-child{ border-bottom:none; }
    .item:hover{ background:#f8fafc; }
    .item .nm{
      font-weight:900;
      letter-spacing:-.2px;
      color:#111827;
    }
    .item .ct{
      font-weight:900;
      color:#4b5563;
      background:#f1f5f9;
      border:1px solid var(--line);
      padding:3px 10px;
      border-radius:999px;
      font-size:12px;
      white-space:nowrap;
    }

    .admin{
      margin-top:12px;
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background:#fff;
    }
    .admin .ah{
      padding:10px 12px;
      background:#f8fafc;
      border-bottom:1px solid var(--line);
      font-weight:900;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    textarea{
      width:100%;
      min-height: 160px;
      border:none;
      outline:none;
      padding:12px;
      font-size:13px;
      line-height:1.45;
      resize:vertical;
    }
    .admin .ab{
      padding:10px 12px 12px;
      border-top:1px solid var(--line);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-start;
    }

    .right .bd{
      min-height: 840px;
    }
    .kvs{
      display:grid;
      grid-template-columns: 140px 1fr;
      gap:8px 12px;
      margin-top:4px;
      padding-top:4px;
    }
    .k{
      color:var(--muted);
      font-weight:900;
      font-size:13px;
    }
    .v{
      font-weight:900;
      font-size:13px;
      color:#111827;
    }

    .sep{
      margin:14px 0;
      height:1px;
      background:var(--line);
    }

    .note{
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
    }

    /* overlay badge */
    .ov{
      background:#111827;
      color:#fff;
      font-weight:900;
      font-size:12px;
      padding:5px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 6px 14px rgba(0,0,0,.18);
      white-space:nowrap;
      cursor:pointer;
      user-select:none;
    }
    .ov.light{
      background:#2563eb;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brandbox">
        <div class="dot"></div>
        <div>
          <div class="titleline">
            <div class="title">
              <span class="coupang">
                <span class="c">c</span><span class="o">o</span><span class="u">u</span><span class="p">p</span><span class="a">a</span><span class="n">n</span><span class="g">g</span>
              </span>Land
            </div>
            <span class="pill">프론트 임시 MVP</span>
          </div>
          <div class="desc">시/도 → 시군구 → 동(행정동) 단위로 대리점/라우트 현황을 조회합니다. (백엔드 없음 / localStorage 저장)</div>
        </div>
      </div>

      <div class="actions">
        <button class="btn primary" id="btnAll">전체 보기</button>
        <button class="btn" id="btnCopy">현재 화면 요약 복사</button>
        <button class="btn danger" id="btnReset">데이터 초기화</button>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT -->
      <div class="card left">
        <div class="hd">
          <div class="h">지도 기반 조회</div>
          <div class="badge" id="badgeCount">데이터: 0건</div>
        </div>
        <div class="bd">
          <div class="row">
            <div class="search">
              <input id="q" type="text" placeholder="검색: 예) 대구 / 중구 / 칠성동 / 영등포구 / 마루웰" />
              <button class="btn" id="btnSearch">검색</button>
            </div>
          </div>

          <div class="chips" id="pathChips"></div>
          <div class="chips" id="vendorChips"></div>

          <div id="map"></div>

          <div class="listbox">
            <div class="lh">
              <div id="listTitle">목록</div>
              <small id="listHint">클릭해서 단계 이동</small>
            </div>
            <div class="list" id="list"></div>
          </div>

          <div class="admin">
            <div class="ah">
              <div>데이터 입력/수정 (관리용)</div>
              <div class="badge" id="badgeUnique">유니크: 0</div>
            </div>
            <textarea id="ta" spellcheck="false" placeholder="입력 포맷(권장):
[시/도] [시군구] [동] [업체명]
예) 대구광역시 중구 칠성동 마루웰

- [시/도]가 빠져도 시군구로 유추 가능한 경우 자동 보정합니다.
- 마지막 토큰이 업체명으로 인식됩니다."></textarea>
            <div class="ab">
              <button class="btn primary" id="btnApply">파싱/적용</button>
              <button class="btn" id="btnSample">샘플 로드</button>
              <button class="btn" id="btnExport">유니크 목록 내보내기</button>
            </div>
          </div>

          <div class="note" style="margin-top:10px">
            표시 규칙(줌 레벨):
            시/도 선택 후 기본은 <b>시군구(구/군)</b>를 먼저 보여주고,
            더 확대(줌 인)하면 <b>동</b>이 나타납니다.
          </div>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card right">
        <div class="hd">
          <div class="h">현재 선택 상세</div>
          <div class="badge" id="badgeSel">전체</div>
        </div>
        <div class="bd">
          <div class="kvs">
            <div class="k">선택 범위</div><div class="v" id="kvScope">전체</div>
            <div class="k">업체 필터</div><div class="v" id="kvVendor">전체</div>
            <div class="k">유니크(업체+지역)</div><div class="v" id="kvUnique">0</div>
          </div>

          <div class="sep"></div>

          <div style="font-weight:900; margin-bottom:8px;">업체 분포</div>
          <div id="vendorDist" class="note"></div>

          <div class="sep"></div>

          <div style="font-weight:900; margin-bottom:8px;">상위 동(Top 12)</div>
          <div id="topDong" class="note"></div>

          <div class="sep"></div>

          <div class="note">
            - 검색이 동까지 바로 내려가면 화면이 “동 레이어”로 전환되어 복잡해 보일 수 있어서,<br/>
            이 버전은 <b>줌 레벨</b>이 충분히 내려가지 않으면 동 레이어를 먼저 띄우지 않습니다.<br/>
            - “검색 후 폴리곤/데이터 사라짐” 이슈는 <b>검색 로직이 레이어/캐시를 초기화</b>하던 구조를 제거하고,<br/>
            selection/필터만 변경하도록 분리해서 해결했습니다.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /********************
     * Config / Storage
     ********************/
    const LS = {
      RECORDS: "coupangland_records_v2",
      LAST_TEXT: "coupangland_last_text_v2",
    };

    // Zoom level in Kakao: 1(가장 확대) ~ 14(가장 축소)
    // "대구(광역시)" 같은 시/도 선택 시, 이 레벨에서는 구(시군구)부터 보여주고 싶음.
    const ZOOM = {
      SHOW_SIDO_AT_OR_ABOVE: 10,   // 전국 스케일
      SHOW_SIGUNGU_AT_OR_ABOVE: 7, // 시/도 스케일에서는 구를 기본
      SHOW_DONG_AT_OR_BELOW: 6,    // 더 확대되면 동 노출
    };

    const BOUNDARY_URLS = {
      sido: [
        "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2013/json/skorea_provinces_geo_simple.json",
        "https://cdn.jsdelivr.net/gh/southkorea/southkorea-maps@master/kostat/2013/json/skorea_provinces_geo_simple.json"
      ],
      sigungu: [
        "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2013/json/skorea_municipalities_geo_simple.json",
        "https://cdn.jsdelivr.net/gh/southkorea/southkorea-maps@master/kostat/2013/json/skorea_municipalities_geo_simple.json"
      ],
      // dong은 시/도별로 (raqoon886/Local_HangJeongDong)
      dongBaseRaw: "https://raw.githubusercontent.com/raqoon886/Local_HangJeongDong/master/",
      dongBaseJsdelivr: "https://cdn.jsdelivr.net/gh/raqoon886/Local_HangJeongDong@master/",
      dongFilePrefix: "hangjeongdong_",
      dongFileSuffix: ".geojson"
    };

    /********************
     * Utilities
     ********************/
    function safeText(s){ return (s ?? "").toString().trim(); }

    function normalizeSpace(s){
      return safeText(s).replace(/\s+/g, " ").trim();
    }

    // 행정구역 명칭 보정(핵심: 대구시/대구 -> 대구광역시 등)
    const SIDO_ALIAS = new Map([
      ["서울", "서울특별시"], ["서울시", "서울특별시"], ["서울특별시", "서울특별시"],
      ["부산", "부산광역시"], ["부산시", "부산광역시"], ["부산광역시", "부산광역시"],
      ["대구", "대구광역시"], ["대구시", "대구광역시"], ["대구광역시", "대구광역시"],
      ["인천", "인천광역시"], ["인천시", "인천광역시"], ["인천광역시", "인천광역시"],
      ["광주", "광주광역시"], ["광주시", "광주광역시"], ["광주광역시", "광주광역시"],
      ["대전", "대전광역시"], ["대전시", "대전광역시"], ["대전광역시", "대전광역시"],
      ["울산", "울산광역시"], ["울산시", "울산광역시"], ["울산광역시", "울산광역시"],
      ["세종", "세종특별자치시"], ["세종시", "세종특별자치시"], ["세종특별자치시", "세종특별자치시"],
      ["경기", "경기도"], ["강원", "강원특별자치도"], ["강원도", "강원특별자치도"], ["강원특별자치도", "강원특별자치도"],
      ["충북", "충청북도"], ["충청북도", "충청북도"],
      ["충남", "충청남도"], ["충청남도", "충청남도"],
      ["전북", "전북특별자치도"], ["전라북도", "전북특별자치도"], ["전북특별자치도", "전북특별자치도"],
      ["전남", "전라남도"], ["전라남도", "전라남도"],
      ["경북", "경상북도"], ["경상북도", "경상북도"],
      ["경남", "경상남도"], ["경상남도", "경상남도"],
      ["제주", "제주특별자치도"], ["제주도", "제주특별자치도"], ["제주특별자치도", "제주특별자치도"],
    ]);

    function normalizeSidoName(s){
      s = normalizeSpace(s);
      if (!s) return "";
      return SIDO_ALIAS.get(s) || s;
    }

    function normalizeKey(s){
      // 비교용: 공백 제거 + 소문자 + 일부 기호 제거
      return normalizeSpace(s).toLowerCase().replace(/[()]/g,"");
    }

    async function fetchJsonWithFallback(urls){
      let lastErr = null;
      for (const url of urls){
        try{
          const res = await fetch(url, { cache: "force-cache" });
          if (!res.ok) throw new Error("HTTP " + res.status);
          return await res.json();
        }catch(e){
          lastErr = e;
        }
      }
      throw lastErr || new Error("fetch failed");
    }

    function getProp(obj, keys){
      if (!obj) return "";
      for (const k of keys){
        if (obj[k] !== undefined && obj[k] !== null && String(obj[k]).trim() !== ""){
          return String(obj[k]).trim();
        }
      }
      return "";
    }

    function featureNameKOR(f){
      const p = f?.properties || {};
      return getProp(p, ["name","NAME","NAME_1","NAME_2","CTP_KOR_NM","CTPRVN_NM","SIG_KOR_NM","EMD_KOR_NM","adm_nm","admName"]);
    }

    function featureCode(f){
      const p = f?.properties || {};
      const raw = getProp(p, ["code","CODE","CTPRVN_CD","CTP_CD","SIDO_CD","SIG_CD","EMD_CD","adm_cd","id"]);
      const onlyNum = String(raw).replace(/\D/g,"");
      return onlyNum;
    }

    function coordsToLatLngPath(ring){
      // ring: [[lon,lat],...]
      return ring.map(pt => new kakao.maps.LatLng(pt[1], pt[0]));
    }

    function geometryToPolygonPaths(geom){
      // returns array of "paths" suitable for kakao.maps.Polygon
      // each "paths" can be [outerRing, hole1, hole2...]
      if (!geom) return [];
      const t = geom.type;
      const c = geom.coordinates;

      if (t === "Polygon"){
        const rings = c.map(ring => coordsToLatLngPath(ring));
        return [rings];
      }
      if (t === "MultiPolygon"){
        const polys = [];
        for (const poly of c){
          const rings = poly.map(ring => coordsToLatLngPath(ring));
          polys.push(rings);
        }
        return polys;
      }
      return [];
    }

    function boundsFromPolygonPaths(paths){
      const b = new kakao.maps.LatLngBounds();
      for (const rings of paths){
        for (const ring of rings){
          for (const ll of ring){
            b.extend(ll);
          }
        }
      }
      return b;
    }

    function centerFromBounds(b){
      return b.getSouthWest() && b.getNorthEast()
        ? new kakao.maps.LatLng(
            (b.getSouthWest().getLat() + b.getNorthEast().getLat())/2,
            (b.getSouthWest().getLng() + b.getNorthEast().getLng())/2
          )
        : null;
    }

    function uniqBy(arr, keyFn){
      const m = new Map();
      for (const x of arr){
        const k = keyFn(x);
        if (!m.has(k)) m.set(k, x);
      }
      return [...m.values()];
    }

    function copyToClipboard(text){
      return navigator.clipboard?.writeText(text);
    }

    /********************
     * State
     ********************/
    let map;

    const state = {
      selection: { sido:"", sigungu:"", dong:"" },
      vendorFilter: "",

      // data records: {sido, sigungu, dong, vendor, raw}
      records: [],

      // boundary geojson
      geo: {
        sido: null,
        sigungu: null,
        dongBySido: new Map(), // sido -> geojson
      },

      // derived indices
      idx: {
        sidoNames: [],                // [sidoName]
        sidoByCodePrefix: new Map(),  // "11" -> "서울특별시"
        sigunguBySido: new Map(),     // sido -> [{name, feature}]
        sigunguToSido: new Map(),     // sigungu -> Set(sido)
        dongBySidoSigungu: new Map(), // `${sido}||${sigungu}` -> [{dong, feature}]
      },

      // drawn layers
      layer: {
        polygons: [],   // kakao.maps.Polygon
        overlays: [],   // kakao.maps.CustomOverlay
        currentType: "" // "sido"|"sigungu"|"dong"
      },

      // last query
      lastQuery: ""
    };

    /********************
     * UI Elements
     ********************/
    const el = {
      badgeCount: document.getElementById("badgeCount"),
      badgeUnique: document.getElementById("badgeUnique"),
      badgeSel: document.getElementById("badgeSel"),
      q: document.getElementById("q"),
      btnSearch: document.getElementById("btnSearch"),
      btnAll: document.getElementById("btnAll"),
      btnCopy: document.getElementById("btnCopy"),
      btnReset: document.getElementById("btnReset"),

      pathChips: document.getElementById("pathChips"),
      vendorChips: document.getElementById("vendorChips"),

      listTitle: document.getElementById("listTitle"),
      list: document.getElementById("list"),

      ta: document.getElementById("ta"),
      btnApply: document.getElementById("btnApply"),
      btnSample: document.getElementById("btnSample"),
      btnExport: document.getElementById("btnExport"),

      kvScope: document.getElementById("kvScope"),
      kvVendor: document.getElementById("kvVendor"),
      kvUnique: document.getElementById("kvUnique"),
      vendorDist: document.getElementById("vendorDist"),
      topDong: document.getElementById("topDong"),
    };

    /********************
     * Data Parsing
     ********************/
    function parseLines(text){
      const lines = normalizeSpace(text).split("\n").map(x => x.trim()).filter(Boolean);

      const out = [];
      for (const rawLine of lines){
        const line = normalizeSpace(rawLine);
        if (!line) continue;

        // 공백 분해
        const parts = line.split(" ").filter(Boolean);

        // 마지막 토큰: 업체명(가정)
        // 다만 마지막이 "동/구/시/군/면/읍/리"로 끝나면 업체명이 없다고 판단
        let vendor = "";
        const last = parts[parts.length - 1] || "";
        const isAdminToken = /(특별시|광역시|특별자치시|특별자치도|도|시|군|구|읍|면|동|리)$/.test(last);
        if (!isAdminToken && parts.length >= 2){
          vendor = last;
          parts.pop();
        } else {
          vendor = "미지정";
        }

        // 남은 parts는 [시도?] [시군구?] [동?] 형태로 유연 처리
        let sido = "";
        let sigungu = "";
        let dong = "";

        if (parts.length === 3){
          sido = normalizeSidoName(parts[0]);
          sigungu = parts[1];
          dong = parts[2];
        } else if (parts.length === 2){
          // 시도 누락일 수 있음: [시군구] [동]
          sigungu = parts[0];
          dong = parts[1];
        } else if (parts.length === 1){
          // 하나만 들어오면 시군구로 가정
          sigungu = parts[0];
        } else if (parts.length >= 4){
          // 혹시 "서울특별시 강서구 염창동 투네스트" 같은 케이스에서 vendor 이미 pop 됐고,
          // 앞에 토큰이 더 많으면 앞 1~3개만 사용
          sido = normalizeSidoName(parts[0]);
          sigungu = parts[1];
          dong = parts[2];
        }

        out.push({
          sido: normalizeSidoName(sido),
          sigungu: safeText(sigungu),
          dong: safeText(dong),
          vendor: safeText(vendor) || "미지정",
          raw: line
        });
      }

      return out;
    }

    /********************
     * Boundary Load + Index Build
     ********************/
    async function ensureBoundaries(){
      if (!state.geo.sido) state.geo.sido = await fetchJsonWithFallback(BOUNDARY_URLS.sido);
      if (!state.geo.sigungu) state.geo.sigungu = await fetchJsonWithFallback(BOUNDARY_URLS.sigungu);
      buildIndices();
    }

    function buildIndices(){
      // reset
      state.idx.sidoNames = [];
      state.idx.sidoByCodePrefix = new Map();
      state.idx.sigunguBySido = new Map();
      state.idx.sigunguToSido = new Map();

      // provinces
      const sidoFeatures = state.geo.sido?.features || [];
      for (const f of sidoFeatures){
        const nm = normalizeSidoName(featureNameKOR(f));
        if (nm) state.idx.sidoNames.push(nm);

        const cd = featureCode(f);
        if (cd && cd.length >= 2){
          state.idx.sidoByCodePrefix.set(cd.slice(0,2), nm);
        }
      }
      state.idx.sidoNames = [...new Set(state.idx.sidoNames)].sort((a,b)=>a.localeCompare(b,"ko"));

      // municipalities
      const sigFeatures = state.geo.sigungu?.features || [];
      for (const f of sigFeatures){
        const sigName = featureNameKOR(f);
        const sig = safeText(sigName);
        if (!sig) continue;

        let sido = "";
        // best effort: code prefix
        const cd = featureCode(f);
        if (cd && cd.length >= 2){
          sido = state.idx.sidoByCodePrefix.get(cd.slice(0,2)) || "";
        }
        // fallback: properties may have province name
        if (!sido){
          const p = f.properties || {};
          sido = normalizeSidoName(getProp(p, ["province","prov","CTPRVN_NM","CTP_KOR_NM","sido","SIDO_NM"]));
        }
        // fallback: full name like "서울특별시 강남구"
        if (!sido){
          const full = getProp(f.properties||{}, ["adm_nm","name"]);
          if (full.includes(" ")){
            const first = full.split(" ")[0];
            sido = normalizeSidoName(first);
          }
        }

        if (!sido) continue;

        if (!state.idx.sigunguBySido.has(sido)) state.idx.sigunguBySido.set(sido, []);
        state.idx.sigunguBySido.get(sido).push({ name: sig, feature: f });

        // sigungu -> sido inference map (중복 가능)
        if (!state.idx.sigunguToSido.has(sig)) state.idx.sigunguToSido.set(sig, new Set());
        state.idx.sigunguToSido.get(sig).add(sido);
      }

      // sort sigungu lists
      for (const [sido, arr] of state.idx.sigunguBySido.entries()){
        arr.sort((a,b)=>a.name.localeCompare(b.name,"ko"));
      }
    }

    async function ensureDongForSido(sido){
      sido = normalizeSidoName(sido);
      if (!sido) return;
      if (state.geo.dongBySido.has(sido)) return;

      const filename = BOUNDARY_URLS.dongFilePrefix + encodeURIComponent(sido) + BOUNDARY_URLS.dongFileSuffix;

      const urls = [
        BOUNDARY_URLS.dongBaseRaw + filename,
        BOUNDARY_URLS.dongBaseJsdelivr + filename
      ];

      const geo = await fetchJsonWithFallback(urls);
      state.geo.dongBySido.set(sido, geo);

      // build dong index for that sido
      const feats = geo?.features || [];
      for (const f of feats){
        const p = f.properties || {};
        const full = getProp(p, ["adm_nm","ADM_NM","name","full_name","admName"]);
        let sigungu = "";
        let dong = "";

        if (full && full.includes(" ")){
          const sp = full.split(" ").filter(Boolean);
          // 일반적으로: [시도, 시군구, 동]
          // 일부는 [시도, 시군구, 읍면동] or [시도, 시군구, 동, 리...] 케이스도 있어 마지막을 dong으로
          if (sp.length >= 3){
            sigungu = sp[1];
            dong = sp[sp.length-1];
          }
        }

        if (!sigungu) sigungu = getProp(p, ["SIG_KOR_NM","sgg_nm","sigungu","SIGUNGU"]);
        if (!dong) dong = getProp(p, ["EMD_KOR_NM","emd_nm","dong","DONG"]);

        sigungu = safeText(sigungu);
        dong = safeText(dong);
        if (!sigungu || !dong) continue;

        const key = `${sido}||${sigungu}`;
        if (!state.idx.dongBySidoSigungu.has(key)) state.idx.dongBySidoSigungu.set(key, []);
        state.idx.dongBySidoSigungu.get(key).push({ dong, feature: f });
      }

      // sort for all sigungu in this sido
      for (const [k, arr] of state.idx.dongBySidoSigungu.entries()){
        if (k.startsWith(sido + "||")) arr.sort((a,b)=>a.dong.localeCompare(b.dong,"ko"));
      }
    }

    function inferMissingSidoFromSigungu(){
      // records에 sido가 비어 있고 sigungu가 있는 경우,
      // sigunguToSido에서 유일하게 매칭되면 자동 보정
      for (const r of state.records){
        if (r.sido) continue;
        const sig = r.sigungu;
        if (!sig) continue;
        const set = state.idx.sigunguToSido.get(sig);
        if (set && set.size === 1){
          r.sido = normalizeSidoName([...set][0]);
        }
      }
    }

    /********************
     * Aggregations
     ********************/
    function filteredRecords(){
      const sel = state.selection;
      const vf = state.vendorFilter;

      return state.records.filter(r => {
        if (vf && r.vendor !== vf) return false;
        if (sel.sido && normalizeSidoName(r.sido) !== normalizeSidoName(sel.sido)) return false;
        if (sel.sigungu && r.sigungu !== sel.sigungu) return false;
        if (sel.dong && r.dong !== sel.dong) return false;
        return true;
      });
    }

    function countByKey(records, keyFn){
      const m = new Map();
      for (const r of records){
        const k = keyFn(r);
        if (!k) continue;
        m.set(k, (m.get(k)||0) + 1);
      }
      return m;
    }

    /********************
     * Map Drawing
     ********************/
    function clearMapLayer(){
      for (const p of state.layer.polygons) p.setMap(null);
      for (const o of state.layer.overlays) o.setMap(null);
      state.layer.polygons = [];
      state.layer.overlays = [];
      state.layer.currentType = "";
    }

    function polygonStyle(base={}){
      return Object.assign({
        strokeWeight: parseInt(getComputedStyle(document.documentElement).getPropertyValue("--poly-stroke-weight")) || 3,
        strokeColor: getComputedStyle(document.documentElement).getPropertyValue("--poly-stroke").trim() || "#2563eb",
        strokeOpacity: 0.92,
        fillColor: "#2563eb",
        fillOpacity: 0.12,
      }, base);
    }

    function drawFeatures(type){
      clearMapLayer();

      const sel = state.selection;
      const lv = map.getLevel();

      const recs = filteredRecords();

      // 현재 단계에서 카운트 표시용
      let cntMap = new Map();

      // 1) 어떤 레이어를 보여줄지 결정
      // - 선택 없음 => sido
      // - sido 선택 => 기본 sigungu (대구 문제 해결 포인트)
      // - sigungu 선택 + 충분히 확대 => dong
      let showType = "sido";

      if (!sel.sido){
        showType = "sido";
      } else {
        // sido 선택이 있으면 기본은 sigungu
        showType = "sigungu";

        // sigungu까지 선택했고, 확대(줌 인)되면 dong로 전환
        if (sel.sigungu && lv <= ZOOM.SHOW_DONG_AT_OR_BELOW){
          showType = "dong";
        }
      }

      // 강제로 type 요청이 들어오면 반영(옵션)
      if (type) showType = type;
      state.layer.currentType = showType;

      if (showType === "sido"){
        const feats = state.geo.sido?.features || [];
        cntMap = countByKey(recs, r => normalizeSidoName(r.sido));
        drawGeoFeatures(feats, {
          getName: (f)=> normalizeSidoName(featureNameKOR(f)),
          getCount: (nm)=> cntMap.get(nm)||0,
          onClick: (nm, f)=> selectSido(nm, f),
        });

      } else if (showType === "sigungu"){
        const feats = (state.geo.sigungu?.features || []).filter(f => {
          const nm = featureNameKOR(f);
          if (!nm) return false;

          // 이 sigungu가 어떤 sido인지 추정해서 filter
          let sido = "";
          const cd = featureCode(f);
          if (cd && cd.length>=2) sido = state.idx.sidoByCodePrefix.get(cd.slice(0,2)) || "";
          if (!sido){
            sido = normalizeSidoName(getProp(f.properties||{}, ["province","CTPRVN_NM","CTP_KOR_NM","sido"]));
          }
          if (!sido){
            const full = getProp(f.properties||{}, ["adm_nm","name"]);
            if (full.includes(" ")) sido = normalizeSidoName(full.split(" ")[0]);
          }
          return normalizeSidoName(sido) === normalizeSidoName(sel.sido);
        });

        cntMap = countByKey(recs, r => r.sigungu);
        drawGeoFeatures(feats, {
          getName: (f)=> featureNameKOR(f),
          getCount: (nm)=> cntMap.get(nm)||0,
          onClick: (nm, f)=> selectSigungu(nm, f),
        });

      } else if (showType === "dong"){
        // dong은 시도별 파일을 로드해야 함
        const key = `${sel.sido}||${sel.sigungu}`;
        const list = state.idx.dongBySidoSigungu.get(key) || [];
        const feats = list.map(x => x.feature);

        cntMap = countByKey(recs, r => r.dong);
        drawGeoFeatures(feats, {
          getName: (f)=> {
            const p = f.properties||{};
            const full = getProp(p, ["adm_nm","name"]);
            if (full.includes(" ")){
              const sp = full.split(" ").filter(Boolean);
              return sp[sp.length-1];
            }
            return getProp(p, ["EMD_KOR_NM","emd_nm","dong"]) || featureNameKOR(f);
          },
          getCount: (nm)=> cntMap.get(nm)||0,
          onClick: (nm, f)=> selectDong(nm, f),
          overlayLimit: 70
        });
      }
    }

    function drawGeoFeatures(features, opt){
      const getName = opt.getName;
      const getCount = opt.getCount;
      const onClick = opt.onClick;
      const overlayLimit = opt.overlayLimit ?? 40;

      // overlay는 너무 많으면 난잡하니 count 높은 것 위주로 제한
      const items = [];

      for (const f of features){
        const nm = safeText(getName(f));
        if (!nm) continue;
        const ct = getCount(nm) || 0;
        items.push({ nm, ct, f });
      }

      // 폴리곤은 모두 그리되, 라벨 오버레이는 상위 N개만
      const topForOverlay = [...items].sort((a,b)=>b.ct-a.ct).slice(0, overlayLimit);

      for (const it of items){
        const pathsList = geometryToPolygonPaths(it.f.geometry);
        for (const rings of pathsList){
          const poly = new kakao.maps.Polygon({
            path: rings,
            ...polygonStyle({
              fillOpacity: it.ct > 0 ? 0.14 : 0.06
            })
          });

          // hover
          kakao.maps.event.addListener(poly, "mouseover", ()=> {
            poly.setOptions(polygonStyle({ fillOpacity: 0.18 }));
          });
          kakao.maps.event.addListener(poly, "mouseout", ()=> {
            poly.setOptions(polygonStyle({ fillOpacity: it.ct > 0 ? 0.14 : 0.06 }));
          });

          // click
          kakao.maps.event.addListener(poly, "click", ()=> onClick(it.nm, it.f));

          poly.setMap(map);
          state.layer.polygons.push(poly);
        }
      }

      // overlay labels
      for (const it of topForOverlay){
        if (!it.ct) continue;
        const pathsList = geometryToPolygonPaths(it.f.geometry);
        if (!pathsList.length) continue;
        const b = boundsFromPolygonPaths(pathsList);
        const center = centerFromBounds(b);
        if (!center) continue;

        const div = document.createElement("div");
        div.className = "ov light";
        div.textContent = `${it.nm} ${it.ct}`;
        div.onclick = () => onClick(it.nm, it.f);

        const ov = new kakao.maps.CustomOverlay({
          position: center,
          content: div,
          yAnchor: 1,
        });
        ov.setMap(map);
        state.layer.overlays.push(ov);
      }
    }

    function fitFeature(f){
      const pathsList = geometryToPolygonPaths(f.geometry);
      if (!pathsList.length) return;
      const b = boundsFromPolygonPaths(pathsList);
      map.setBounds(b);
    }

    /********************
     * Selection Control
     ********************/
    async function selectSido(sido, feature){
      state.selection = { sido: normalizeSidoName(sido), sigungu:"", dong:"" };
      state.lastQuery = "";
      el.q.value = "";

      if (feature) fitFeature(feature);

      // "대구 누르면 구가 먼저 보이게"
      // 선택 직후 너무 확대돼 있으면 적당히 내려 구 레이어가 안정적으로 보이도록 보정
      if (map.getLevel() < ZOOM.SHOW_SIGUNGU_AT_OR_ABOVE) {
        map.setLevel(ZOOM.SHOW_SIGUNGU_AT_OR_ABOVE);
      }

      // dong은 나중(구 선택 + 확대)에서 로드해도 되지만,
      // 사용자 체감상 구->동 전환을 빠르게 하려면 시도 선택 시 미리 로드해도 됨(옵션)
      // 여기서는 "구 선택 전"에는 굳이 로드하지 않음.

      refreshUI();
      drawFeatures();
    }

    async function selectSigungu(sigungu, feature){
      state.selection.sigungu = sigungu;
      state.selection.dong = "";
      state.lastQuery = "";
      el.q.value = "";

      // dong geojson 확보
      await ensureDongForSido(state.selection.sido);

      if (feature) fitFeature(feature);

      // 구 선택하면 조금 더 확대(동 전환 직전 단계)
      if (map.getLevel() > ZOOM.SHOW_DONG_AT_OR_BELOW + 1) {
        map.setLevel(ZOOM.SHOW_DONG_AT_OR_BELOW + 1);
      }

      refreshUI();
      drawFeatures();
    }

    function selectDong(dong, feature){
      state.selection.dong = dong;
      state.lastQuery = "";
      el.q.value = "";

      if (feature) fitFeature(feature);

      // 동 선택이면 조금 더 확대
      if (map.getLevel() > ZOOM.SHOW_DONG_AT_OR_BELOW) {
        map.setLevel(ZOOM.SHOW_DONG_AT_OR_BELOW);
      }

      refreshUI();
      drawFeatures();
    }

    function resetSelection(){
      state.selection = { sido:"", sigungu:"", dong:"" };
      state.vendorFilter = "";
      state.lastQuery = "";
      el.q.value = "";
      map.setLevel(13);
      map.setCenter(new kakao.maps.LatLng(36.35, 127.85));
      refreshUI();
      drawFeatures("sido");
    }

    function stepUp(){
      if (state.selection.dong){
        state.selection.dong = "";
      } else if (state.selection.sigungu){
        state.selection.sigungu = "";
      } else if (state.selection.sido){
        state.selection.sido = "";
      }
      refreshUI();
      drawFeatures();
    }

    /********************
     * Search (IMPORTANT: no layer reset / no data wipe)
     ********************/
    function applySearch(){
      const q = normalizeSpace(el.q.value);
      state.lastQuery = q;

      if (!q){
        refreshUI();
        drawFeatures();
        return;
      }

      const tokens = q.split(/[\/\s]+/).filter(Boolean).map(t => t.trim());
      if (!tokens.length){
        refreshUI();
        drawFeatures();
        return;
      }

      // vendor match (exact)
      const vendors = [...new Set(state.records.map(r => r.vendor))].filter(v => v && v !== "미지정");
      let vendorHit = "";
      for (const t of tokens){
        const hit = vendors.find(v => normalizeKey(v) === normalizeKey(t));
        if (hit){ vendorHit = hit; break; }
      }
      if (vendorHit) state.vendorFilter = vendorHit;

      // location match priority: sido -> sigungu -> dong
      const sidoSet = new Set(state.idx.sidoNames.map(normalizeKey));
      let hitSido = "";
      for (const t of tokens){
        const ns = normalizeKey(normalizeSidoName(t));
        const exact = state.idx.sidoNames.find(s => normalizeKey(s) === ns);
        if (exact){ hitSido = exact; break; }
      }

      // sigungu: only if we already have hitSido or token endswith 구/군/시
      let hitSigungu = "";
      if (hitSido){
        const list = state.idx.sigunguBySido.get(hitSido) || [];
        for (const t of tokens){
          const cand = t;
          const exact = list.find(x => normalizeKey(x.name) === normalizeKey(cand));
          if (exact){ hitSigungu = exact.name; break; }
        }
      } else {
        for (const t of tokens){
          if (!/(구|군|시)$/.test(t)) continue;
          // unique infer
          const set = state.idx.sigunguToSido.get(t);
          if (set && set.size === 1){
            hitSido = [...set][0];
            hitSigungu = t;
            break;
          }
        }
      }

      // dong: only if sigungu is known AND token endswith 동/읍/면
      let hitDong = "";
      if (hitSido && hitSigungu){
        const key = `${hitSido}||${hitSigungu}`;
        const list = state.idx.dongBySidoSigungu.get(key) || [];
        for (const t of tokens){
          if (!/(동|읍|면)$/.test(t)) continue;
          const exact = list.find(x => normalizeKey(x.dong) === normalizeKey(t));
          if (exact){ hitDong = exact.dong; break; }
        }
      }

      // apply selection
      if (hitSido){
        state.selection.sido = hitSido;
        state.selection.sigungu = "";
        state.selection.dong = "";
      }
      if (hitSigungu){
        state.selection.sigungu = hitSigungu;
        state.selection.dong = "";
      }
      // dong은 “줌 레벨이 충분히 확대되었거나(<=6)”, 또는 사용자가 명시적으로 dong을 입력했을 때만 세팅
      if (hitDong){
        state.selection.dong = hitDong;
      }

      refreshUI();

      // boundary 준비: sigungu 선택이면 dong 파일 로드
      (async ()=>{
        if (state.selection.sido && state.selection.sigungu){
          await ensureDongForSido(state.selection.sido);
        }

        // 선택된 feature로 자동 이동(가능할 때)
        tryAutoFitBySelection();

        // draw
        drawFeatures();
      })();
    }

    function tryAutoFitBySelection(){
      const sel = state.selection;

      if (!sel.sido) return;

      // sido feature 찾기
      const sFeat = (state.geo.sido?.features || []).find(f => normalizeKey(normalizeSidoName(featureNameKOR(f))) === normalizeKey(sel.sido));
      if (sFeat) fitFeature(sFeat);

      if (!sel.sigungu) return;

      // sigungu feature 찾기 (해당 sido 내)
      const sigFeat = (state.geo.sigungu?.features || []).find(f => {
        const nm = featureNameKOR(f);
        if (normalizeKey(nm) !== normalizeKey(sel.sigungu)) return false;
        let sido = "";
        const cd = featureCode(f);
        if (cd && cd.length>=2) sido = state.idx.sidoByCodePrefix.get(cd.slice(0,2)) || "";
        if (!sido){
          sido = normalizeSidoName(getProp(f.properties||{}, ["province","CTPRVN_NM","CTP_KOR_NM","sido"]));
        }
        if (!sido){
          const full = getProp(f.properties||{}, ["adm_nm","name"]);
          if (full.includes(" ")) sido = normalizeSidoName(full.split(" ")[0]);
        }
        return normalizeKey(normalizeSidoName(sido)) === normalizeKey(sel.sido);
      });
      if (sigFeat) fitFeature(sigFeat);

      // dong은 너무 무거워서 여기서는 강제 fit 생략(원하면 추가 가능)
    }

    /********************
     * UI Render
     ********************/
    function refreshUI(){
      const recsAll = state.records;
      const recs = filteredRecords();

      el.badgeCount.textContent = `데이터: ${recsAll.length}건`;

      // unique (vendor+location)
      const uniq = new Set(recsAll.map(r => `${r.vendor}||${normalizeSidoName(r.sido)}||${r.sigungu}||${r.dong}`));
      el.badgeUnique.textContent = `유니크: ${uniq.size}`;

      // selection badges
      const sel = state.selection;
      const scope = sel.dong ? `${sel.sido} / ${sel.sigungu} / ${sel.dong}`
                  : sel.sigungu ? `${sel.sido} / ${sel.sigungu}`
                  : sel.sido ? `${sel.sido}`
                  : "전체";
      el.badgeSel.textContent = scope;
      el.kvScope.textContent = scope;
      el.kvVendor.textContent = state.vendorFilter || "전체";

      // unique under filter
      const uniqFiltered = new Set(recs.map(r => `${r.vendor}||${normalizeSidoName(r.sido)}||${r.sigungu}||${r.dong}`));
      el.kvUnique.textContent = `${uniqFiltered.size}`;

      // path chips
      renderPathChips();

      // vendor chips
      renderVendorChips();

      // list (next level)
      renderList();

      // right panel summaries
      renderVendorDist(recs);
      renderTopDong(recs);
    }

    function renderPathChips(){
      const sel = state.selection;
      el.pathChips.innerHTML = "";

      const addChip = (label, active, onClick) => {
        const c = document.createElement("div");
        c.className = "chip" + (active ? " active" : "");
        c.textContent = label;
        c.onclick = onClick;
        el.pathChips.appendChild(c);
      };

      addChip("전체", !sel.sido && !sel.sigungu && !sel.dong, () => resetSelection());

      if (sel.sido){
        addChip(sel.sido, true, ()=> { state.selection = {sido:sel.sido, sigungu:"", dong:""}; refreshUI(); drawFeatures(); });
      }
      if (sel.sigungu){
        addChip(sel.sigungu, true, ()=> { state.selection = {sido:sel.sido, sigungu:sel.sigungu, dong:""}; refreshUI(); drawFeatures(); });
      }
      if (sel.dong){
        addChip(sel.dong, true, ()=> { refreshUI(); drawFeatures(); });
      }

      if (sel.sido){
        addChip("← 한 단계 위", false, ()=> stepUp());
      }
    }

    function renderVendorChips(){
      el.vendorChips.innerHTML = "";

      const recs = state.records;
      const vendors = [...new Set(recs.map(r => r.vendor))].filter(Boolean).sort((a,b)=>a.localeCompare(b,"ko"));

      const add = (label, active, count, onClick) => {
        const c = document.createElement("div");
        c.className = "chip" + (active ? " active" : "");
        c.innerHTML = `${label} <span class="mini">${count}</span>`;
        c.onclick = onClick;
        el.vendorChips.appendChild(c);
      };

      const allCount = recs.length;
      add("전체 업체", state.vendorFilter === "", allCount, ()=>{
        state.vendorFilter = "";
        refreshUI(); drawFeatures();
      });

      for (const v of vendors){
        const ct = recs.filter(r => r.vendor === v).length;
        add(v, state.vendorFilter === v, ct, ()=>{
          state.vendorFilter = (state.vendorFilter === v) ? "" : v;
          refreshUI(); drawFeatures();
        });
      }
    }

    function renderList(){
      const sel = state.selection;
      const recs = filteredRecords();

      el.list.innerHTML = "";

      // decide next level
      let title = "시/도";
      let rows = [];

      if (!sel.sido){
        title = "시/도";
        const m = countByKey(recs, r => normalizeSidoName(r.sido));
        rows = [...m.entries()].map(([nm, ct]) => ({ nm, ct, type:"sido" }))
          .sort((a,b)=>b.ct-a.ct || a.nm.localeCompare(b.nm,"ko"));

      } else if (!sel.sigungu){
        title = "시/군/구";
        const m = countByKey(recs, r => r.sigungu);
        rows = [...m.entries()].map(([nm, ct]) => ({ nm, ct, type:"sigungu" }))
          .sort((a,b)=>b.ct-a.ct || a.nm.localeCompare(b.nm,"ko"));

      } else {
        title = "동/읍/면";
        const m = countByKey(recs, r => r.dong);
        rows = [...m.entries()].map(([nm, ct]) => ({ nm, ct, type:"dong" }))
          .sort((a,b)=>b.ct-a.ct || a.nm.localeCompare(b.nm,"ko"));
      }

      el.listTitle.textContent = title;

      if (!rows.length){
        const empty = document.createElement("div");
        empty.className = "item";
        empty.style.cursor = "default";
        empty.innerHTML = `<div class="nm" style="color:#64748b;font-weight:900;">데이터가 없습니다.</div><div class="ct">0</div>`;
        el.list.appendChild(empty);
        return;
      }

      for (const r of rows){
        const it = document.createElement("div");
        it.className = "item";
        it.innerHTML = `<div class="nm">${r.nm || "(미상)"}</div><div class="ct">${r.ct}</div>`;
        it.onclick = async () => {
          if (r.type === "sido"){
            // 해당 sido feature로 선택
            const f = (state.geo.sido?.features||[]).find(x => normalizeKey(normalizeSidoName(featureNameKOR(x))) === normalizeKey(normalizeSidoName(r.nm)));
            await selectSido(r.nm, f);
          } else if (r.type === "sigungu"){
            // sigungu feature 찾아 선택
            const f = (state.geo.sigungu?.features||[]).find(x => normalizeKey(featureNameKOR(x)) === normalizeKey(r.nm));
            await selectSigungu(r.nm, f);
          } else {
            // dong은 feature 찾기 어려울 수 있어 selection만(원하면 find 추가)
            state.selection.dong = r.nm;
            refreshUI(); drawFeatures();
          }
        };
        el.list.appendChild(it);
      }
    }

    function renderVendorDist(recs){
      const m = countByKey(recs, r => r.vendor);
      const rows = [...m.entries()].sort((a,b)=>b[1]-a[1]).slice(0, 12);
      if (!rows.length){
        el.vendorDist.textContent = "표시할 데이터가 없습니다.";
        return;
      }
      el.vendorDist.innerHTML = rows.map(([v,c]) => `- ${v}: <b>${c}</b>`).join("<br/>");
    }

    function renderTopDong(recs){
      const m = countByKey(recs, r => r.dong);
      const rows = [...m.entries()].filter(x=>x[0]).sort((a,b)=>b[1]-a[1]).slice(0, 12);
      if (!rows.length){
        el.topDong.textContent = "표시할 데이터가 없습니다.";
        return;
      }
      el.topDong.innerHTML = rows.map(([d,c]) => `- ${d}: <b>${c}</b>`).join("<br/>");
    }

    /********************
     * Actions
     ********************/
    function saveRecords(){
      localStorage.setItem(LS.RECORDS, JSON.stringify(state.records));
      localStorage.setItem(LS.LAST_TEXT, el.ta.value);
    }

    function loadRecords(){
      try{
        const raw = localStorage.getItem(LS.RECORDS);
        if (raw){
          state.records = JSON.parse(raw) || [];
        }
      }catch(e){
        state.records = [];
      }

      const last = localStorage.getItem(LS.LAST_TEXT);
      if (last) el.ta.value = last;
    }

    function applyTextarea(){
      const text = el.ta.value || "";
      const parsed = parseLines(text);

      // 기존 + 신규를 합치되 raw 기준으로 중복 제거(원하면 다른 키로 변경)
      const merged = uniqBy([...parsed], r => r.raw);

      state.records = merged;

      // sido/sigungu boundary 인덱스로 sido 추론
      inferMissingSidoFromSigungu();

      saveRecords();
      refreshUI();
      drawFeatures();
    }

    function loadSample(){
      const sample = [
        "영등포구 대림동 마루웰",
        "영등포구 대림동 마루웰",
        "영등포구 신길동 투네스트",
        "대구시 중구 칠성동 마루웰",
        "대구광역시 중구 동인동 마루웰",
        "경기도 용인시 수지구 동천동 마루웰",
        "서울특별시 강서구 염창동 투네스트",
        "서울특별시 강서구 염창동 마루웰",
        "분당구 대장동 마루웰"
      ].join("\n");
      el.ta.value = sample;
    }

    function exportUnique(){
      const uniq = new Set(state.records.map(r => `${normalizeSidoName(r.sido)} ${r.sigungu} ${r.dong} | ${r.vendor}`.trim()));
      const text = [...uniq].sort((a,b)=>a.localeCompare(b,"ko")).join("\n");
      copyToClipboard(text).then(()=>{
        alert("유니크 목록을 클립보드에 복사했습니다.");
      }).catch(()=>{
        // fallback
        prompt("복사 실패. 아래 내용을 수동 복사하세요.", text);
      });
    }

    function copySummary(){
      const sel = state.selection;
      const scope = sel.dong ? `${sel.sido} / ${sel.sigungu} / ${sel.dong}`
                  : sel.sigungu ? `${sel.sido} / ${sel.sigungu}`
                  : sel.sido ? `${sel.sido}`
                  : "전체";

      const recs = filteredRecords();
      const mVendor = countByKey(recs, r => r.vendor);
      const vendors = [...mVendor.entries()].sort((a,b)=>b[1]-a[1]).map(([v,c])=>`${v}:${c}`).join(", ");

      const mDong = countByKey(recs, r => r.dong);
      const topDong = [...mDong.entries()].filter(x=>x[0]).sort((a,b)=>b[1]-a[1]).slice(0, 8).map(([d,c])=>`${d}:${c}`).join(", ");

      const text =
`[CoupangLand 요약]
- 범위: ${scope}
- 업체필터: ${state.vendorFilter || "전체"}
- 데이터건수(필터후): ${recs.length}
- 업체분포: ${vendors || "(없음)"}
- 상위 동: ${topDong || "(없음)"}`;

      copyToClipboard(text).then(()=>{
        alert("현재 화면 요약을 클립보드에 복사했습니다.");
      }).catch(()=>{
        prompt("복사 실패. 아래 내용을 수동 복사하세요.", text);
      });
    }

    function hardReset(){
      if (!confirm("저장된 데이터를 모두 초기화할까요? (localStorage 삭제)")) return;
      localStorage.removeItem(LS.RECORDS);
      localStorage.removeItem(LS.LAST_TEXT);
      state.records = [];
      el.ta.value = "";
      resetSelection();
      refreshUI();
      drawFeatures();
    }

    /********************
     * Init
     ********************/
    async function init(){
      // map
      map = new kakao.maps.Map(document.getElementById("map"), {
        center: new kakao.maps.LatLng(36.35, 127.85),
        level: 13
      });

      // boundaries
      await ensureBoundaries();

      // load records from storage
      loadRecords();

      // infer missing sido
      inferMissingSidoFromSigungu();

      // first paint
      refreshUI();
      drawFeatures("sido");

      // map zoom change => re-decide layer
      kakao.maps.event.addListener(map, "zoom_changed", async () => {
        // dong 레이어를 그릴 수 있는 상태인지 체크 (sigungu 선택 + dong 파일 로드)
        if (state.selection.sido && state.selection.sigungu){
          // dong 필요해질 수 있으니 미리 로드
          await ensureDongForSido(state.selection.sido);
        }
        drawFeatures();
      });

      // controls
      el.btnSearch.onclick = applySearch;
      el.q.addEventListener("keydown", (e)=>{ if (e.key === "Enter") applySearch(); });

      el.btnAll.onclick = resetSelection;
      el.btnCopy.onclick = copySummary;
      el.btnReset.onclick = hardReset;

      el.btnApply.onclick = applyTextarea;
      el.btnSample.onclick = () => { loadSample(); };
      el.btnExport.onclick = exportUnique;
    }

    init().catch(err => {
      console.error(err);
      alert("초기화 실패: " + (err?.message || err));
    });
  </script>
</body>
</html>
