<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>마루웰 라우트 편집기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; background:#020617; color:#e5e7eb; }
    body { display:flex; }

    .side {
      width: 420px;
      min-width: 320px;
      max-width: 520px;
      background:#020617;
      border-right:1px solid #1f2937;
      padding:14px 16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .title { font-size:1rem; font-weight:800; }
    .subtitle { font-size:0.75rem; color:#9ca3af; }

    label { font-size:0.78rem; margin-bottom:2px; display:block; color:#cbd5e1; }
    input[type="text"] {
      width:100%; padding:8px 10px; border-radius:10px;
      border:1px solid #334155; background:#020617; color:#e5e7eb;
      font-size:0.85rem;
    }

    .btn-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:4px; }
    button {
      border-radius:999px; border:1px solid #334155;
      background:#0b1220; color:#e5e7eb;
      padding:7px 12px; font-size:0.8rem;
      cursor:pointer; white-space:nowrap;
    }
    button.primary { background:#111827; border-color:#111827; }
    button.danger  { border-color:#b91c1c; color:#fecaca; background:#200a0a; }
    button:hover { filter:brightness(1.08); }

    .hint { font-size:0.72rem; color:#94a3b8; line-height:1.45; }
    .status-bar {
      font-size:0.72rem; padding:4px 10px; border-radius:999px;
      background:#022c22; color:#6ee7b7;
      display:inline-block; margin-top:4px;
    }
    .status-error { background:#450a0a; color:#fecaca; }

    .log-box {
      margin-top:6px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#020617;
      font-size:0.72rem;
      height:160px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .log-line-time { color:#64748b; }
    .log-line-info { color:#e5e7eb; }
    .log-line-warn { color:#fbbf24; }
    .log-line-err  { color:#f87171; }

    .map-wrap { flex:1; position:relative; }
    #map { width:100%; height:100%; }

    .overlay-badge {
      position:absolute; top:10px; left:10px;
      background:rgba(15,23,42,0.9); border:1px solid #1f2937;
      border-radius:999px; padding:4px 10px;
      font-size:0.75rem; pointer-events:none;
    }

    .route-label {
      display:inline-block;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(15,23,42,0.88);
      border:1px solid rgba(148,163,184,0.35);
      color:#e5e7eb;
      font-size:12px;
      font-weight:700;
      letter-spacing:0.2px;
      white-space:nowrap;
      transform: translate(-50%, -50%);
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
      pointer-events:none;
    }

    .xbtn {
      width:22px; height:22px;
      border-radius:999px;
      background:rgba(185,28,28,0.95);
      color:#fff;
      border:1px solid rgba(255,255,255,0.25);
      display:flex; align-items:center; justify-content:center;
      font-size:12px; font-weight:900;
      transform: translate(-50%, -50%);
      cursor:pointer;
      user-select:none;
    }

    .section {
      margin-top:8px;
      padding-top:8px;
      border-top:1px dashed #1f2937;
    }
    .section-title { font-size:0.8rem; font-weight:800; color:#e2e8f0; margin-bottom:6px; }
    .small { font-size:0.72rem; color:#94a3b8; line-height:1.45; }

    @media (max-width:900px) {
      body { flex-direction:column; }
      .side { width:100%; max-width:none; border-right:none; border-bottom:1px solid #1f2937; }
      .map-wrap { height:calc(100% - 320px); }
    }
  </style>

  <!-- Kakao Maps + drawing -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&libraries=drawing"></script>

  <!-- (선택) 지도 정렬(실험)용: turf.js -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
</head>
<body>
  <aside class="side">
    <div>
      <div class="title">마루웰 라우트 편집기</div>
      <div class="subtitle">캠프 + 라우트 코드 기반 · Supabase / Cloudflare route API</div>
    </div>

    <div>
      <label for="campInput">캠프 이름 (예: 일산2, 대구3)</label>
      <input id="campInput" type="text" placeholder="예: 대구3" />
    </div>

    <div>
      <label for="routeInput">라우트 코드 (예: 126, 126B, 126B01) — 비우면 camp 전체 표시</label>
      <input id="routeInput" type="text" placeholder="예: 126 (비우면 camp 전체)" />
    </div>

    <div class="btn-row">
      <button id="loadBtn"  class="primary">불러오기(GET)</button>
      <button id="drawBtn">새로 그리기</button>
      <button id="addRegionBtn">구역 추가</button>
      <button id="saveBtn" class="primary">저장(POST)</button>
      <button id="alignBtn">지도 정렬</button>
      <button id="labelToggleBtn">라우트 라벨 OFF</button>
      <button id="hideToggleBtn">라우트 숨기기 OFF</button>
      <button id="resetBtn" class="danger">지도 초기화</button>
    </div>

    <div class="hint">
      · GET: <b>camp만</b> 입력하면 해당 camp의 전체 노선 표시.<br/>
      · code 입력 시 기본 <code>mode=prefix</code>로 하위 노선까지 표시.<br/>
      · 지도에서 폴리곤 클릭 → <b>편집 대상</b> 선택.<br/>
      · 끊긴 구역은 <b>[구역 추가]</b>로 여러 개 저장/표시(멀티 폴리곤).<br/>
      · 편집 대상 구역을 전부 X로 삭제 후 저장하면 <b>DB에 polygon=null</b>로 반영됩니다.<br/>
      · <b>drawingManager.put</b>은 카카오 SDK 버전에서 깨져서 제거했습니다(클릭 시 사라지지 않음).
    </div>

    <div id="apiStatus" class="status-bar">API: ready</div>
    <div id="logBox" class="log-box"></div>

    <div class="section">
      <div class="section-title">DB 수정</div>
      <div class="small">지도에서 라우트를 클릭해 “편집 대상”을 만든 뒤 사용하세요.</div>

      <label for="campEditInput" style="margin-top:10px;">캠프명 변경 (예: 대구3)</label>
      <input id="campEditInput" type="text" placeholder="예: 대구3" />

      <div class="btn-row">
        <button id="updateCampSelectedBtn">선택 camp 수정</button>
        <button id="moveCampAllBtn">camp 전체 이관</button>
      </div>

      <label for="codeEditInput" style="margin-top:10px;">라우트 코드 변경 (예: 213D → 213E)</label>
      <input id="codeEditInput" type="text" placeholder="예: 213D" />
      <div class="btn-row">
        <button id="updateCodeSelectedBtn">선택 코드 수정</button>
        <button id="deleteSelectedRowBtn" class="danger">선택 DB 삭제</button>
      </div>
    </div>
  </aside>

  <div class="map-wrap">
    <div id="map"></div>
    <div class="overlay-badge" id="overlayInfo">지도 초기화 중...</div>
  </div>

  <script>
    // ================== 설정 ==================
    const ROUTE_API_BASE = "https://route.maroowell.com";

    // ================== DOM ==================
    const logBox      = document.getElementById("logBox");
    const apiStatus   = document.getElementById("apiStatus");
    const overlayInfo = document.getElementById("overlayInfo");
    const campInput   = document.getElementById("campInput");
    const routeInput  = document.getElementById("routeInput");

    const loadBtn     = document.getElementById("loadBtn");
    const drawBtn     = document.getElementById("drawBtn");
    const addRegionBtn= document.getElementById("addRegionBtn");
    const saveBtn     = document.getElementById("saveBtn");
    const alignBtn    = document.getElementById("alignBtn");
    const labelToggleBtn = document.getElementById("labelToggleBtn");
    const hideToggleBtn  = document.getElementById("hideToggleBtn");
    const resetBtn    = document.getElementById("resetBtn");

    const campEditInput = document.getElementById("campEditInput");
    const codeEditInput = document.getElementById("codeEditInput");
    const updateCampSelectedBtn = document.getElementById("updateCampSelectedBtn");
    const moveCampAllBtn = document.getElementById("moveCampAllBtn");
    const updateCodeSelectedBtn = document.getElementById("updateCodeSelectedBtn");
    const deleteSelectedRowBtn = document.getElementById("deleteSelectedRowBtn");

    // ================== 로그 ==================
    function log(message, level = "info") {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2,"0");
      const mm = String(now.getMinutes()).padStart(2,"0");
      const ss = String(now.getSeconds()).padStart(2,"0");

      const line = document.createElement("div");
      const spanTime = document.createElement("span");
      spanTime.textContent = `[${hh}:${mm}:${ss}] `;
      spanTime.className = "log-line-time";
      line.appendChild(spanTime);

      const spanMsg = document.createElement("span");
      spanMsg.textContent = message;
      spanMsg.className = "log-line-" + level;
      line.appendChild(spanMsg);

      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;

      // 콘솔도 함께
      if (level === "err") console.error(message);
      else if (level === "warn") console.warn(message);
      else console.log(message);
    }

    function setApiStatus(msg, isError = false) {
      apiStatus.textContent = "API: " + msg;
      apiStatus.className = "status-bar" + (isError ? " status-error" : "");
    }
    function setOverlayText(msg) { overlayInfo.textContent = msg; }

    // ================== 지도/드로잉 ==================
    const state = {
      map: null,
      drawingManager: null,

      // rowsById: id -> {row, regions:[Polygon], labels:[CustomOverlay], xbtns:[CustomOverlay]}
      rowsById: new Map(),

      // 편집 대상
      editId: null,          // row.id (DB row) or null
      editDraft: null,       // {camp, code} - DB row가 없어도 그림 가능

      // 토글
      labelsOn: false,
      hideOtherRoutes: false,

      // 색상: 인접 색상 중복 최소화용
      palette: [
        "#e6194b","#3cb44b","#ffe119","#4363d8","#f58231","#911eb4","#46f0f0","#f032e6",
        "#bcf60c","#fabebe","#008080","#e6beff","#9a6324","#fffac8","#800000","#aaffc3",
        "#808000","#ffd8b1","#000075","#808080"
      ],
      colorByRouteKey: new Map(),  // routeKey -> color
    };

    function initMap() {
      const center = new kakao.maps.LatLng(37.5665, 126.9780);
      state.map = new kakao.maps.Map(document.getElementById("map"), { center, level: 7 });

      state.drawingManager = new kakao.maps.drawing.DrawingManager({
        map: state.map,
        drawingMode: [kakao.maps.drawing.OverlayType.POLYGON],
        guideTooltip: ["draw", "drag", "edit"],
        polygonOptions: {
          draggable: true,
          removable: false,  // X는 우리가 직접 구현
          editable: false,   // 카카오 SDK 버전차로 편집 UI가 불안정해서 OFF
          strokeWeight: 3,
          strokeOpacity: 0.95,
          strokeStyle: "solid",
          fillOpacity: 0.28,
        },
      });

      // drawend: 새 폴리곤 region 추가
      kakao.maps.event.addListener(state.drawingManager, "drawend", function (data) {
        const overlay = data?.target;
        if (!overlay || typeof overlay.getPath !== "function") {
          log("[WARN] drawend: polygon overlay 아님", "warn");
          return;
        }

        // 편집 대상이 없으면 code 입력 필수
        const camp = (campInput.value || "").trim();
        const code = (routeInput.value || "").trim();
        const editRow = getEditTargetRow();
        if (!editRow && !code) {
          overlay.setMap(null);
          alert("편집할 라우트 코드를 먼저 입력하거나, 지도에서 기존 라우트를 클릭해 편집 대상으로 선택하세요.");
          return;
        }

        // 편집 대상이 없으면 draft 생성
        if (!editRow) {
          state.editDraft = { camp, code };
          state.editId = null;
          log(`[LOG] 편집 대상(draft) 생성: ${code}`, "info");
        }

        // points 추출
        const pts = extractPathFromPolygon(overlay);
        if (pts.length < 3) {
          overlay.setMap(null);
          log("[WARN] drawend: 점 3개 미만 → 취소", "warn");
          return;
        }

        // “편집 대상” 그룹에 region 추가
        const targetKey = getEditTargetKey();
        const color = getColorForRouteKey(targetKey);

        overlay.setOptions({
          strokeColor: color,
          fillColor: color,
        });

        overlay.__mw_points = pts;
        overlay.__mw_targetKey = targetKey;

        // 클릭하면 편집 대상으로 전환(드래프트/DB 모두 지원)
        kakao.maps.event.addListener(overlay, "click", () => {
          selectByTargetKey(targetKey);
        });

        attachRegionToEditTarget(overlay);

        log(`[LOG] 구역 추가됨: 점 ${pts.length}개`, "info");
        refreshSelectionUI();
      });

      setOverlayText("지도 초기화 완료.");
      log("[LOG] 지도 초기화 완료.", "info");
    }

    // ================== 좌표/폴리곤 유틸 ==================
    function isFiniteNum(n) { return typeof n === "number" && isFinite(n); }

    function normalizePoint(p) {
      if (!p) return null;

      // {lat,lng}
      if (isFiniteNum(p.lat) && isFiniteNum(p.lng)) return { lat: p.lat, lng: p.lng };
      // {latitude,longitude}
      if (isFiniteNum(p.latitude) && isFiniteNum(p.longitude)) return { lat: p.latitude, lng: p.longitude };

      // [a,b] : [lng,lat] 또는 [lat,lng]
      if (Array.isArray(p) && p.length >= 2) {
        const a = Number(p[0]), b = Number(p[1]);
        if (!isFinite(a) || !isFinite(b)) return null;

        // 한국 범위 힌트로 판정
        // 보통 저장이 [lng,lat]인 케이스가 많음
        const cand1 = { lng: a, lat: b }; // [lng,lat]
        const cand2 = { lng: b, lat: a }; // [lat,lng] 뒤집기
        const inKR = (pt) => pt.lat >= 30 && pt.lat <= 45 && pt.lng >= 120 && pt.lng <= 135;

        if (inKR(cand1)) return { lat: cand1.lat, lng: cand1.lng };
        if (inKR(cand2)) return { lat: cand2.lat, lng: cand2.lng };

        // 범위가 애매하면 일반 규칙 적용
        if (Math.abs(a) <= 180 && Math.abs(b) <= 90) return { lat: b, lng: a };
        if (Math.abs(a) <= 90 && Math.abs(b) <= 180) return { lat: a, lng: b };

        return null;
      }

      // kakao.maps.LatLng
      if (typeof p.getLat === "function" && typeof p.getLng === "function") {
        return { lat: p.getLat(), lng: p.getLng() };
      }

      return null;
    }

    // polygon_wgs84가
    //  - [{lat,lng}...] (단일)
    //  - [[lng,lat]...] (단일)
    //  - [ [..ring1..], [..ring2..] ] (멀티)
    //  - [ [ [{..}], [{..}] ], [ ... ] ] (멀티)
    function normalizePolygonWgs84(value) {
      if (!value) return [];

      // 멀티 판정: 첫 원소가 “ring”인가?
      const looksLikeRing = (arr) => Array.isArray(arr) && arr.length && (
        typeof arr[0] === "object" || Array.isArray(arr[0])
      );

      // 단일 ring
      if (Array.isArray(value) && value.length && !Array.isArray(value[0])) {
        const ring = value.map(normalizePoint).filter(Boolean);
        return ring.length >= 3 ? [ring] : [];
      }

      // value[0]가 배열이면 ring 또는 멀티
      if (Array.isArray(value) && value.length && Array.isArray(value[0])) {
        // 케이스1: [[x,y], [x,y]...] (단일 ring)
        if (value.length && Array.isArray(value[0]) && typeof value[0][0] === "number") {
          const ring = value.map(normalizePoint).filter(Boolean);
          return ring.length >= 3 ? [ring] : [];
        }

        // 케이스2: [ ring1, ring2... ]
        if (looksLikeRing(value[0])) {
          const regions = [];
          for (const ringLike of value) {
            if (!Array.isArray(ringLike)) continue;
            const ring = ringLike.map(normalizePoint).filter(Boolean);
            if (ring.length >= 3) regions.push(ring);
          }
          return regions;
        }
      }

      // [{lat,lng}] 형태
      if (Array.isArray(value)) {
        const ring = value.map(normalizePoint).filter(Boolean);
        return ring.length >= 3 ? [ring] : [];
      }

      return [];
    }

    function extractPathFromPolygon(polygon) {
      const out = [];
      try {
        const path = polygon.getPath();
        // MVCArray
        if (path && typeof path.getLength === "function" && typeof path.getAt === "function") {
          for (let i = 0; i < path.getLength(); i++) {
            const ll = path.getAt(i);
            const p = normalizePoint(ll);
            if (p) out.push(p);
          }
        } else if (Array.isArray(path)) {
          path.forEach((ll) => {
            const p = normalizePoint(ll);
            if (p) out.push(p);
          });
        }
      } catch (e) {
        log("[ERR] extractPathFromPolygon 실패: " + String(e), "err");
      }
      return out;
    }

    function computeCenter(points) {
      if (!points || points.length === 0) return null;
      let sumLat = 0, sumLng = 0;
      for (const p of points) { sumLat += p.lat; sumLng += p.lng; }
      return { lat: sumLat / points.length, lng: sumLng / points.length };
    }
    function computeCenterMulti(regions) {
      const all = [];
      regions.forEach(r => r.forEach(p => all.push(p)));
      return computeCenter(all);
    }

    // polylabel(간단 구현): 라벨이 폴리곤 밖으로 튀는 문제를 줄임
    // turf 사용 가능하면 turf.pointOnFeature도 가능하지만, 내부 중심에 더 잘 들어가도록 polylabel 사용
    function polylabelPoint(region) {
      try {
        if (!window.turf || !region || region.length < 3) return computeCenter(region);

        const coords = [region.map(p => [p.lng, p.lat])];
        // 닫기
        if (coords[0].length && (coords[0][0][0] !== coords[0][coords[0].length - 1][0] || coords[0][0][1] !== coords[0][coords[0].length - 1][1])) {
          coords[0].push(coords[0][0]);
        }
        const poly = turf.polygon(coords);
        const pt = turf.pointOnFeature(poly); // 내부점
        return { lat: pt.geometry.coordinates[1], lng: pt.geometry.coordinates[0] };
      } catch {
        return computeCenter(region);
      }
    }

    function bboxOfRegions(regions) {
      let minLat=999, minLng=999, maxLat=-999, maxLng=-999;
      for (const r of regions) {
        for (const p of r) {
          minLat = Math.min(minLat, p.lat);
          minLng = Math.min(minLng, p.lng);
          maxLat = Math.max(maxLat, p.lat);
          maxLng = Math.max(maxLng, p.lng);
        }
      }
      return { minLat, minLng, maxLat, maxLng };
    }

    // ================== 색상(인접 유사색 최소화) ==================
    function hexToRgb(hex) {
      const h = hex.replace("#","").trim();
      const n = parseInt(h, 16);
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
    }
    function colorDist(a, b) {
      const A = hexToRgb(a), B = hexToRgb(b);
      const dr = A.r - B.r, dg = A.g - B.g, db = A.b - B.b;
      return Math.sqrt(dr*dr + dg*dg + db*db);
    }

    function routeKeyFromRow(row) {
      // “같은 라우트”의 멀티 구역은 같은 색/키를 공유
      const camp = row?.camp ?? "";
      const code = row?.full_code ?? row?.code ?? "";
      return `${camp}::${code}`;
    }

    function assignColorsGreedy(rows) {
      state.colorByRouteKey.clear();
      const routes = new Map(); // key -> {key, regions:[...], bbox}
      rows.forEach((row) => {
        const key = routeKeyFromRow(row);
        const regions = normalizePolygonWgs84(row.polygon_wgs84);
        if (!regions.length) return;
        const bb = bboxOfRegions(regions);
        if (!routes.has(key)) routes.set(key, { key, regions, bbox: bb });
      });

      const keys = [...routes.keys()];
      const neighbors = new Map(); // key -> Set<key>
      keys.forEach(k => neighbors.set(k, new Set()));

      // bbox 겹침(살짝 margin)으로 인접 판정
      const margin = 0.0008; // ~80m 근사
      function isNeighbor(a, b) {
        const A = routes.get(a).bbox, B = routes.get(b).bbox;
        return !(
          (A.maxLng + margin) < (B.minLng - margin) ||
          (A.minLng - margin) > (B.maxLng + margin) ||
          (A.maxLat + margin) < (B.minLat - margin) ||
          (A.minLat - margin) > (B.maxLat + margin)
        );
      }

      for (let i=0;i<keys.length;i++) {
        for (let j=i+1;j<keys.length;j++) {
          const a = keys[i], b = keys[j];
          if (isNeighbor(a,b)) {
            neighbors.get(a).add(b);
            neighbors.get(b).add(a);
          }
        }
      }

      // degree 높은 순
      keys.sort((a,b) => neighbors.get(b).size - neighbors.get(a).size);

      for (const k of keys) {
        const used = new Set();
        neighbors.get(k).forEach(nk => {
          const c = state.colorByRouteKey.get(nk);
          if (c) used.add(c);
        });

        let best = state.palette[0];
        let bestScore = -1;

        for (const cand of state.palette) {
          // 이웃 색과 거리 최솟값을 최대화
          let minD = 1e9;
          for (const u of used) {
            minD = Math.min(minD, colorDist(cand, u));
          }
          // 이웃 없으면 그냥 큰 점수
          if (used.size === 0) minD = 1e6;

          if (minD > bestScore) {
            bestScore = minD;
            best = cand;
          }
        }
        state.colorByRouteKey.set(k, best);
      }
    }

    function getColorForRouteKey(routeKey) {
      if (state.colorByRouteKey.has(routeKey)) return state.colorByRouteKey.get(routeKey);
      // fallback
      const idx = Math.abs(hash(routeKey)) % state.palette.length;
      return state.palette[idx];
    }
    function hash(s) {
      let h = 0;
      for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i)) >>> 0;
      return h;
    }

    // ================== API ==================
    async function fetchRoutes({ camp, code, mode="prefix" }) {
      const url = new URL(ROUTE_API_BASE + "/route");
      if (camp) url.searchParams.set("camp", camp);
      if (code) url.searchParams.set("code", code);
      url.searchParams.set("mode", mode);

      log(`[LOG] GET /route 요청: ${url.toString()}`, "info");
      setApiStatus("GET /route 호출 중...");

      const res = await fetch(url.toString(), { method:"GET" });
      const json = await res.json().catch(() => ({}));

      if (!res.ok) {
        setApiStatus(`GET 에러 ${res.status}`, true);
        log(`[ERR] GET 실패: ${JSON.stringify(json)}`, "err");
        throw new Error("GET 실패");
      }

      setApiStatus("GET 성공");
      return json;
    }

    async function saveRoute({ camp, code, polygon_wgs84, center_wgs84 }) {
      const url = ROUTE_API_BASE + "/route";
      const body = { camp, code, polygon_wgs84, center_wgs84 };

      log(`[LOG] POST /route 요청: ${JSON.stringify(body)}`, "info");
      setApiStatus("POST /route 호출 중...");

      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: JSON.stringify(body),
      });

      const json = await res.json().catch(() => ({}));
      if (!res.ok) {
        setApiStatus(`POST 에러 ${res.status}`, true);
        log(`[ERR] POST 실패: ${JSON.stringify(json)}`, "err");
