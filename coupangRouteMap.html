<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ë§ˆë£¨ì›° ë¼ìš°íŠ¸ í¸ì§‘ê¸°</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; background:#020617; color:#e5e7eb; }
    body { display:flex; }

    .side {
      width: 420px;
      min-width: 320px;
      max-width: 520px;
      background:#020617;
      border-right:1px solid #1f2937;
      padding:14px 16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .title { font-size:1rem; font-weight:800; }
    .subtitle { font-size:0.75rem; color:#9ca3af; }

    label { font-size:0.78rem; margin-bottom:2px; display:block; color:#cbd5e1; }
    input[type="text"] {
      width:100%; padding:8px 10px; border-radius:10px;
      border:1px solid #334155; background:#020617; color:#e5e7eb;
      font-size:0.85rem;
    }

    .btn-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:4px; }
    button {
      border-radius:999px; border:1px solid #334155;
      background:#0b1220; color:#e5e7eb;
      padding:7px 12px; font-size:0.8rem;
      cursor:pointer; white-space:nowrap;
    }
    button.primary { background:#111827; border-color:#111827; }
    button.danger  { border-color:#b91c1c; color:#fecaca; background:#200a0a; }
    button:hover { filter:brightness(1.08); }

    .hint { font-size:0.72rem; color:#94a3b8; line-height:1.45; }
    .status-bar {
      font-size:0.72rem; padding:4px 10px; border-radius:999px;
      background:#022c22; color:#6ee7b7;
      display:inline-block; margin-top:4px;
    }
    .status-error { background:#450a0a; color:#fecaca; }

    .log-box {
      margin-top:6px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#020617;
      font-size:0.72rem;
      height:160px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .log-line-time { color:#64748b; }
    .log-line-info { color:#e5e7eb; }
    .log-line-warn { color:#fbbf24; }
    .log-line-err  { color:#f87171; }

    .map-wrap { flex:1; position:relative; }
    #map { width:100%; height:100%; }

    .overlay-badge {
      position:absolute; top:10px; left:10px;
      background:rgba(15,23,42,0.9); border:1px solid #1f2937;
      border-radius:999px; padding:4px 10px;
      font-size:0.75rem; pointer-events:none;
    }

    .route-label {
      display:inline-block;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(15,23,42,0.88);
      border:1px solid rgba(148,163,184,0.35);
      color:#e5e7eb;
      font-size:12px;
      font-weight:700;
      letter-spacing:0.2px;
      white-space:nowrap;
      transform: translate(-50%, -50%);
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
      pointer-events:none;
    }

    .xbtn {
      width:22px; height:22px;
      border-radius:999px;
      background:rgba(185,28,28,0.95);
      color:#fff;
      border:1px solid rgba(255,255,255,0.25);
      display:flex; align-items:center; justify-content:center;
      font-size:12px; font-weight:900;
      transform: translate(-50%, -50%);
      cursor:pointer;
      user-select:none;
    }

    .section {
      margin-top:8px;
      padding-top:8px;
      border-top:1px dashed #1f2937;
    }
    .section-title { font-size:0.8rem; font-weight:800; color:#e2e8f0; margin-bottom:6px; }
    .small { font-size:0.72rem; color:#94a3b8; line-height:1.45; }

    @media (max-width:900px) {
      body { flex-direction:column; }
      .side { width:100%; max-width:none; border-right:none; border-bottom:1px solid #1f2937; }
      .map-wrap { height:calc(100% - 320px); }
    }
  </style>

  <!-- Kakao Maps + drawing + services(geocoder) -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&libraries=drawing,services"></script>

  <!-- (ì„ íƒ) ì§€ë„ ì •ë ¬(ì‹¤í—˜)ìš©: turf.js -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
</head>
<body>
  <aside class="side">
    <div>
      <div class="title">ë§ˆë£¨ì›° ë¼ìš°íŠ¸ í¸ì§‘ê¸°</div>
      <div class="subtitle">ìº í”„ + ë¼ìš°íŠ¸ ì½”ë“œ ê¸°ë°˜ Â· Supabase / Cloudflare route API</div>
    </div>

    <div>
      <label for="campInput">ìº í”„ ì´ë¦„ (ì˜ˆ: ì¼ì‚°2, ëŒ€êµ¬3)</label>
      <input id="campInput" type="text" placeholder="ì˜ˆ: ëŒ€êµ¬3" />
    </div>

    <div>
      <label for="routeInput">ë¼ìš°íŠ¸ ì½”ë“œ (ì˜ˆ: 126, 126B, 126B01) â€” ë¹„ìš°ë©´ camp ì „ì²´ í‘œì‹œ</label>
      <input id="routeInput" type="text" placeholder="ì˜ˆ: 126 (ë¹„ìš°ë©´ camp ì „ì²´)" />
    </div>

    <div class="btn-row">
      <button id="loadBtn"  class="primary">ë¶ˆëŸ¬ì˜¤ê¸°(GET)</button>
      <button id="drawBtn">ìƒˆë¡œ ê·¸ë¦¬ê¸°</button>
      <button id="addRegionBtn">êµ¬ì—­ ì¶”ê°€</button>
      <button id="searchAddressBtn">ğŸ“ ì£¼ì†Œê²€ìƒ‰</button>
      <button id="saveBtn" class="primary">ì €ì¥(POST)</button>
      <button id="alignBtn">ì§€ë„ ì •ë ¬</button>
      <button id="labelToggleBtn">ë¼ìš°íŠ¸ ë¼ë²¨ OFF</button>
      <button id="hideToggleBtn">ë¼ìš°íŠ¸ ìˆ¨ê¸°ê¸° OFF</button>
      <button id="resetBtn" class="danger">ì§€ë„ ì´ˆê¸°í™”</button>
    </div>

    <div class="hint">
      <b>âœ¨ í´ë¦¬ê³¤ ìˆ˜ì • ë°©ë²•:</b> í´ë¦¬ê³¤ í´ë¦­(ì£¼í™©ìƒ‰ ì„ íƒ) â†’ <b>ì ì„ ë“œë˜ê·¸</b>í•´ì„œ ê±´ë¬¼ì— ë§ì¶° ì¡°ì • â†’ [ì €ì¥]<br/>
      <b>ğŸ“ ì£¼ì†Œê²€ìƒ‰:</b> ì£¼ì†Œ ì…ë ¥ â†’ ìœ„ì¹˜ ì´ë™ â†’ í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°<br/>
      <b>âœ‚ï¸ ì§€ë„ ì •ë ¬:</b> ë¾°ì¡±í•œ ë¶€ë¶„ ìë™ ì œê±° + ê²½ê³„ì„  ìŠ¤ë¬´ë”©<br/>
      Â· <b>ëª¨ë“  í´ë¦¬ê³¤</b>ì˜ ì ì„ ììœ ë¡­ê²Œ ë“œë˜ê·¸ ê°€ëŠ¥!<br/>
      Â· ëŠê¸´ êµ¬ì—­ì€ <b>[êµ¬ì—­ ì¶”ê°€]</b>ë¡œ ë©€í‹° í´ë¦¬ê³¤ ì €ì¥.
    </div>

    <div id="apiStatus" class="status-bar">API: ready</div>
    <div id="logBox" class="log-box"></div>

    <div class="section">
      <div class="section-title">DB ìˆ˜ì •</div>
      <div class="small">ì§€ë„ì—ì„œ ë¼ìš°íŠ¸ë¥¼ í´ë¦­í•´ â€œí¸ì§‘ ëŒ€ìƒâ€ì„ ë§Œë“  ë’¤ ì‚¬ìš©í•˜ì„¸ìš”.</div>

      <label for="campEditInput" style="margin-top:10px;">ìº í”„ëª… ë³€ê²½ (ì˜ˆ: ëŒ€êµ¬3)</label>
      <input id="campEditInput" type="text" placeholder="ì˜ˆ: ëŒ€êµ¬3" />

      <div class="btn-row">
        <button id="updateCampSelectedBtn">ì„ íƒ camp ìˆ˜ì •</button>
        <button id="moveCampAllBtn">camp ì „ì²´ ì´ê´€</button>
      </div>

      <label for="codeEditInput" style="margin-top:10px;">ë¼ìš°íŠ¸ ì½”ë“œ ë³€ê²½ (ì˜ˆ: 213D â†’ 213E)</label>
      <input id="codeEditInput" type="text" placeholder="ì˜ˆ: 213D" />
      <div class="btn-row">
        <button id="updateCodeSelectedBtn">ì„ íƒ ì½”ë“œ ìˆ˜ì •</button>
        <button id="deleteSelectedRowBtn" class="danger">ì„ íƒ DB ì‚­ì œ</button>
      </div>
    </div>
  </aside>

  <div class="map-wrap">
    <div id="map"></div>
    <div class="overlay-badge" id="overlayInfo">ì§€ë„ ì´ˆê¸°í™” ì¤‘...</div>
  </div>

  <script>
    // ================== ì„¤ì • ==================
    const ROUTE_API_BASE = "https://route.maroowell.com";

    // ================== DOM ==================
    const logBox      = document.getElementById("logBox");
    const apiStatus   = document.getElementById("apiStatus");
    const overlayInfo = document.getElementById("overlayInfo");
    const campInput   = document.getElementById("campInput");
    const routeInput  = document.getElementById("routeInput");

    const loadBtn     = document.getElementById("loadBtn");
    const drawBtn     = document.getElementById("drawBtn");
    const addRegionBtn= document.getElementById("addRegionBtn");
    const searchAddressBtn = document.getElementById("searchAddressBtn");
    const saveBtn     = document.getElementById("saveBtn");
    const alignBtn    = document.getElementById("alignBtn");
    const labelToggleBtn = document.getElementById("labelToggleBtn");
    const hideToggleBtn  = document.getElementById("hideToggleBtn");
    const resetBtn    = document.getElementById("resetBtn");

    const campEditInput = document.getElementById("campEditInput");
    const codeEditInput = document.getElementById("codeEditInput");
    const updateCampSelectedBtn = document.getElementById("updateCampSelectedBtn");
    const moveCampAllBtn = document.getElementById("moveCampAllBtn");
    const updateCodeSelectedBtn = document.getElementById("updateCodeSelectedBtn");
    const deleteSelectedRowBtn = document.getElementById("deleteSelectedRowBtn");

    // ================== ë¡œê·¸ ==================
    function log(message, level = "info") {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2,"0");
      const mm = String(now.getMinutes()).padStart(2,"0");
      const ss = String(now.getSeconds()).padStart(2,"0");

      const line = document.createElement("div");
      const spanTime = document.createElement("span");
      spanTime.textContent = `[${hh}:${mm}:${ss}] `;
      spanTime.className = "log-line-time";
      line.appendChild(spanTime);

      const spanMsg = document.createElement("span");
      spanMsg.textContent = message;
      spanMsg.className = "log-line-" + level;
      line.appendChild(spanMsg);

      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;

      // ì½˜ì†”ë„ í•¨ê»˜
      if (level === "err") console.error(message);
      else if (level === "warn") console.warn(message);
      else console.log(message);
    }

    function setApiStatus(msg, isError = false) {
      apiStatus.textContent = "API: " + msg;
      apiStatus.className = "status-bar" + (isError ? " status-error" : "");
    }
    function setOverlayText(msg) { overlayInfo.textContent = msg; }

    // ================== ì§€ë„/ë“œë¡œì‰ ==================
    const state = {
      map: null,
      drawingManager: null,

      // rowsById: id -> {row, regions:[Polygon], labels:[CustomOverlay], xbtns:[CustomOverlay]}
      rowsById: new Map(),

      // í¸ì§‘ ëŒ€ìƒ
      editId: null,          // row.id (DB row) or null
      editDraft: null,       // {camp, code} - DB rowê°€ ì—†ì–´ë„ ê·¸ë¦¼ ê°€ëŠ¥

      // í† ê¸€
      labelsOn: false,
      hideOtherRoutes: false,

      // ìƒ‰ìƒ: ì¸ì ‘ ìƒ‰ìƒ ì¤‘ë³µ ìµœì†Œí™”ìš©
      palette: [
        "#e6194b","#3cb44b","#ffe119","#4363d8","#f58231","#911eb4","#46f0f0","#f032e6",
        "#bcf60c","#fabebe","#008080","#e6beff","#9a6324","#fffac8","#800000","#aaffc3",
        "#808000","#ffd8b1","#000075","#808080"
      ],
      colorByRouteKey: new Map(),  // routeKey -> color
    };

    function initMap() {
      const center = new kakao.maps.LatLng(37.5665, 126.9780);
      state.map = new kakao.maps.Map(document.getElementById("map"), { center, level: 7 });

      state.drawingManager = new kakao.maps.drawing.DrawingManager({
        map: state.map,
        drawingMode: [kakao.maps.drawing.OverlayType.POLYGON],
        guideTooltip: ["draw", "drag", "edit"],
        polygonOptions: {
          draggable: true,
          removable: false,
          editable: true,
          strokeWeight: 2,      // âœ… ê²½ê³„ì„  ì–‡ê²Œ
          strokeOpacity: 0.9,
          strokeStyle: "solid",
          fillOpacity: 0.25,    // âœ… ì±„ìš°ê¸° ì—°í•˜ê²Œ
        },
      });

      // drawend: ìƒˆ í´ë¦¬ê³¤ region ì¶”ê°€
      kakao.maps.event.addListener(state.drawingManager, "drawend", function (data) {
        const overlay = data?.target;
        if (!overlay || typeof overlay.getPath !== "function") {
          log("[WARN] drawend: polygon overlay ì•„ë‹˜", "warn");
          return;
        }

        // í¸ì§‘ ëŒ€ìƒì´ ì—†ìœ¼ë©´ code ì…ë ¥ í•„ìˆ˜
        const camp = (campInput.value || "").trim();
        const code = (routeInput.value || "").trim();
        const editRow = getEditTargetRow();
        if (!editRow && !code) {
          overlay.setMap(null);
          alert("í¸ì§‘í•  ë¼ìš°íŠ¸ ì½”ë“œë¥¼ ë¨¼ì € ì…ë ¥í•˜ê±°ë‚˜, ì§€ë„ì—ì„œ ê¸°ì¡´ ë¼ìš°íŠ¸ë¥¼ í´ë¦­í•´ í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ì„ íƒí•˜ì„¸ìš”.");
          return;
        }

        // í¸ì§‘ ëŒ€ìƒì´ ì—†ìœ¼ë©´ draft ìƒì„±
        if (!editRow) {
          state.editDraft = { camp, code };
          state.editId = null;
          log(`[LOG] í¸ì§‘ ëŒ€ìƒ(draft) ìƒì„±: ${code}`, "info");
        }

        // points ì¶”ì¶œ
        const pts = extractPathFromPolygon(overlay);
        if (pts.length < 3) {
          overlay.setMap(null);
          log("[WARN] drawend: ì  3ê°œ ë¯¸ë§Œ â†’ ì·¨ì†Œ", "warn");
          return;
        }

        // â€œí¸ì§‘ ëŒ€ìƒâ€ ê·¸ë£¹ì— region ì¶”ê°€
        const targetKey = getEditTargetKey();
        const color = getColorForRouteKey(targetKey);

        overlay.setOptions({
          strokeColor: color,
          fillColor: color,
        });

        overlay.__mw_points = pts;
        overlay.__mw_targetKey = targetKey;

        // í´ë¦­í•˜ë©´ í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ì „í™˜(ë“œë˜í”„íŠ¸/DB ëª¨ë‘ ì§€ì›)
        kakao.maps.event.addListener(overlay, "click", () => {
          selectByTargetKey(targetKey);
        });

        attachRegionToEditTarget(overlay);

        log(`[LOG] êµ¬ì—­ ì¶”ê°€ë¨: ì  ${pts.length}ê°œ`, "info");
        refreshSelectionUI();
      });

      setOverlayText("ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ.");
      log("[LOG] ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ.", "info");
    }

    // ================== ì¢Œí‘œ/í´ë¦¬ê³¤ ìœ í‹¸ ==================
    function isFiniteNum(n) { return typeof n === "number" && isFinite(n); }

    function normalizePoint(p) {
      if (!p) {
        console.log("[DEBUG normalizePoint] p is null/undefined");
        return null;
      }

      console.log("[DEBUG normalizePoint] p:", p, "type:", typeof p, "constructor:", p.constructor?.name);

      // kakao.maps.LatLng - ê°€ì¥ ë¨¼ì € ì²´í¬!
      if (typeof p.getLat === "function" && typeof p.getLng === "function") {
        const result = { lat: p.getLat(), lng: p.getLng() };
        console.log("[DEBUG normalizePoint] LatLng:", result);
        return result;
      }

      // {lat,lng}
      if (isFiniteNum(p.lat) && isFiniteNum(p.lng)) {
        console.log("[DEBUG normalizePoint] {lat,lng}:", p);
        return { lat: p.lat, lng: p.lng };
      }
      
      // {latitude,longitude}
      if (isFiniteNum(p.latitude) && isFiniteNum(p.longitude)) {
        console.log("[DEBUG normalizePoint] {latitude,longitude}");
        return { lat: p.latitude, lng: p.longitude };
      }

      // [a,b] : [lng,lat] ë˜ëŠ” [lat,lng]
      if (Array.isArray(p) && p.length >= 2) {
        const a = Number(p[0]), b = Number(p[1]);
        if (!isFinite(a) || !isFinite(b)) return null;

        const cand1 = { lng: a, lat: b };
        const cand2 = { lng: b, lat: a };
        const inKR = (pt) => pt.lat >= 30 && pt.lat <= 45 && pt.lng >= 120 && pt.lng <= 135;

        if (inKR(cand1)) return { lat: cand1.lat, lng: cand1.lng };
        if (inKR(cand2)) return { lat: cand2.lat, lng: cand2.lng };

        if (Math.abs(a) <= 180 && Math.abs(b) <= 90) return { lat: b, lng: a };
        if (Math.abs(a) <= 90 && Math.abs(b) <= 180) return { lat: a, lng: b };

        return null;
      }

      console.log("[DEBUG normalizePoint] ì¸ì‹ ì‹¤íŒ¨! p:", p);
      return null;
    }

    // polygon_wgs84ê°€
    //  - [{lat,lng}...] (ë‹¨ì¼)
    //  - [[lng,lat]...] (ë‹¨ì¼)
    //  - [ [..ring1..], [..ring2..] ] (ë©€í‹°)
    //  - [ [ [{..}], [{..}] ], [ ... ] ] (ë©€í‹°)
    function normalizePolygonWgs84(value) {
      if (!value) return [];

      // ë©€í‹° íŒì •: ì²« ì›ì†Œê°€ â€œringâ€ì¸ê°€?
      const looksLikeRing = (arr) => Array.isArray(arr) && arr.length && (
        typeof arr[0] === "object" || Array.isArray(arr[0])
      );

      // ë‹¨ì¼ ring
      if (Array.isArray(value) && value.length && !Array.isArray(value[0])) {
        const ring = value.map(normalizePoint).filter(Boolean);
        return ring.length >= 3 ? [ring] : [];
      }

      // value[0]ê°€ ë°°ì—´ì´ë©´ ring ë˜ëŠ” ë©€í‹°
      if (Array.isArray(value) && value.length && Array.isArray(value[0])) {
        // ì¼€ì´ìŠ¤1: [[x,y], [x,y]...] (ë‹¨ì¼ ring)
        if (value.length && Array.isArray(value[0]) && typeof value[0][0] === "number") {
          const ring = value.map(normalizePoint).filter(Boolean);
          return ring.length >= 3 ? [ring] : [];
        }

        // ì¼€ì´ìŠ¤2: [ ring1, ring2... ]
        if (looksLikeRing(value[0])) {
          const regions = [];
          for (const ringLike of value) {
            if (!Array.isArray(ringLike)) continue;
            const ring = ringLike.map(normalizePoint).filter(Boolean);
            if (ring.length >= 3) regions.push(ring);
          }
          return regions;
        }
      }

      // [{lat,lng}] í˜•íƒœ
      if (Array.isArray(value)) {
        const ring = value.map(normalizePoint).filter(Boolean);
        return ring.length >= 3 ? [ring] : [];
      }

      return [];
    }

    function extractPathFromPolygon(polygon) {
      const out = [];
      try {
        const path = polygon.getPath();
        console.log("[DEBUG] extractPathFromPolygon - path:", path);
        
        // MVCArray
        if (path && typeof path.getLength === "function" && typeof path.getAt === "function") {
          const len = path.getLength();
          console.log("[DEBUG] MVCArray length:", len);
          for (let i = 0; i < len; i++) {
            const ll = path.getAt(i);
            console.log("[DEBUG] point", i, ":", ll);
            const p = normalizePoint(ll);
            if (p) out.push(p);
          }
        } else if (Array.isArray(path)) {
          console.log("[DEBUG] Array path, length:", path.length);
          path.forEach((ll) => {
            const p = normalizePoint(ll);
            if (p) out.push(p);
          });
        } else {
          console.log("[DEBUG] path íƒ€ì… ì•Œ ìˆ˜ ì—†ìŒ:", typeof path);
        }
        console.log("[DEBUG] extracted points:", out.length, out);
      } catch (e) {
        log("[ERR] extractPathFromPolygon ì‹¤íŒ¨: " + String(e), "err");
        console.error("[DEBUG] Exception:", e);
      }
      return out;
    }

    function computeCenter(points) {
      if (!points || points.length === 0) return null;
      let sumLat = 0, sumLng = 0;
      for (const p of points) { sumLat += p.lat; sumLng += p.lng; }
      return { lat: sumLat / points.length, lng: sumLng / points.length };
    }
    function computeCenterMulti(regions) {
      const all = [];
      regions.forEach(r => r.forEach(p => all.push(p)));
      return computeCenter(all);
    }

    // polylabel ê°œì„ : í´ë¦¬ê³¤ì˜ ì§„ì§œ ì¤‘ì‹¬ì (centroid) ê³„ì‚°
    function polylabelPoint(region) {
      try {
        if (!window.turf || !region || region.length < 3) return computeCenter(region);

        const coords = [region.map(p => [p.lng, p.lat])];
        // ë‹«ê¸°
        if (coords[0].length && (coords[0][0][0] !== coords[0][coords[0].length - 1][0] || coords[0][0][1] !== coords[0][coords[0].length - 1][1])) {
          coords[0].push(coords[0][0]);
        }
        const poly = turf.polygon(coords);
        
        // centroid ì‚¬ìš© (ë” ì •í™•í•œ ì¤‘ì‹¬)
        const centroid = turf.centroid(poly);
        const centroidPt = { lat: centroid.geometry.coordinates[1], lng: centroid.geometry.coordinates[0] };
        
        // centroidê°€ í´ë¦¬ê³¤ ë‚´ë¶€ì¸ì§€ í™•ì¸
        const isInside = turf.booleanPointInPolygon(centroid, poly);
        
        if (isInside) {
          return centroidPt;
        } else {
          // ë°–ì— ìˆìœ¼ë©´ pointOnFeature ì‚¬ìš© (í™•ì‹¤íˆ ë‚´ë¶€ì— ìˆëŠ” ì )
          const pt = turf.pointOnFeature(poly);
          return { lat: pt.geometry.coordinates[1], lng: pt.geometry.coordinates[0] };
        }
      } catch {
        return computeCenter(region);
      }
    }

    function bboxOfRegions(regions) {
      let minLat=999, minLng=999, maxLat=-999, maxLng=-999;
      for (const r of regions) {
        for (const p of r) {
          minLat = Math.min(minLat, p.lat);
          minLng = Math.min(minLng, p.lng);
          maxLat = Math.max(maxLat, p.lat);
          maxLng = Math.max(maxLng, p.lng);
        }
      }
      return { minLat, minLng, maxLat, maxLng };
    }

    // ================== ìƒ‰ìƒ(ì¸ì ‘ ìœ ì‚¬ìƒ‰ ìµœì†Œí™”) ==================
    function hexToRgb(hex) {
      const h = hex.replace("#","").trim();
      const n = parseInt(h, 16);
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
    }
    function colorDist(a, b) {
      const A = hexToRgb(a), B = hexToRgb(b);
      const dr = A.r - B.r, dg = A.g - B.g, db = A.b - B.b;
      return Math.sqrt(dr*dr + dg*dg + db*db);
    }

    function routeKeyFromRow(row) {
      // â€œê°™ì€ ë¼ìš°íŠ¸â€ì˜ ë©€í‹° êµ¬ì—­ì€ ê°™ì€ ìƒ‰/í‚¤ë¥¼ ê³µìœ 
      const camp = row?.camp ?? "";
      const code = row?.full_code ?? row?.code ?? "";
      return `${camp}::${code}`;
    }

    function assignColorsGreedy(rows) {
      state.colorByRouteKey.clear();
      const routes = new Map(); // key -> {key, regions:[...], bbox}
      rows.forEach((row) => {
        const key = routeKeyFromRow(row);
        const regions = normalizePolygonWgs84(row.polygon_wgs84);
        if (!regions.length) return;
        const bb = bboxOfRegions(regions);
        if (!routes.has(key)) routes.set(key, { key, regions, bbox: bb });
      });

      const keys = [...routes.keys()];
      const neighbors = new Map(); // key -> Set<key>
      keys.forEach(k => neighbors.set(k, new Set()));

      // bbox ê²¹ì¹¨(ì‚´ì§ margin)ìœ¼ë¡œ ì¸ì ‘ íŒì •
      const margin = 0.0008; // ~80m ê·¼ì‚¬
      function isNeighbor(a, b) {
        const A = routes.get(a).bbox, B = routes.get(b).bbox;
        return !(
          (A.maxLng + margin) < (B.minLng - margin) ||
          (A.minLng - margin) > (B.maxLng + margin) ||
          (A.maxLat + margin) < (B.minLat - margin) ||
          (A.minLat - margin) > (B.maxLat + margin)
        );
      }

      for (let i=0;i<keys.length;i++) {
        for (let j=i+1;j<keys.length;j++) {
          const a = keys[i], b = keys[j];
          if (isNeighbor(a,b)) {
            neighbors.get(a).add(b);
            neighbors.get(b).add(a);
          }
        }
      }

      // degree ë†’ì€ ìˆœ
      keys.sort((a,b) => neighbors.get(b).size - neighbors.get(a).size);

      for (const k of keys) {
        const used = new Set();
        neighbors.get(k).forEach(nk => {
          const c = state.colorByRouteKey.get(nk);
          if (c) used.add(c);
        });

        let best = state.palette[0];
        let bestScore = -1;

        for (const cand of state.palette) {
          // ì´ì›ƒ ìƒ‰ê³¼ ê±°ë¦¬ ìµœì†Ÿê°’ì„ ìµœëŒ€í™”
          let minD = 1e9;
          for (const u of used) {
            minD = Math.min(minD, colorDist(cand, u));
          }
          // ì´ì›ƒ ì—†ìœ¼ë©´ ê·¸ëƒ¥ í° ì ìˆ˜
          if (used.size === 0) minD = 1e6;

          if (minD > bestScore) {
            bestScore = minD;
            best = cand;
          }
        }
        state.colorByRouteKey.set(k, best);
      }
    }

    function getColorForRouteKey(routeKey) {
      if (state.colorByRouteKey.has(routeKey)) return state.colorByRouteKey.get(routeKey);
      // fallback
      const idx = Math.abs(hash(routeKey)) % state.palette.length;
      return state.palette[idx];
    }
    function hash(s) {
      let h = 0;
      for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i)) >>> 0;
      return h;
    }

    // ================== API ==================
    async function fetchRoutes({ camp, code, mode="prefix" }) {
      const url = new URL(ROUTE_API_BASE + "/route");
      if (camp) url.searchParams.set("camp", camp);
      if (code) url.searchParams.set("code", code);
      url.searchParams.set("mode", mode);

      log(`[LOG] GET /route ìš”ì²­: ${url.toString()}`, "info");
      setApiStatus("GET /route í˜¸ì¶œ ì¤‘...");

      const res = await fetch(url.toString(), { method:"GET" });
      const json = await res.json().catch(() => ({}));

      if (!res.ok) {
        setApiStatus(`GET ì—ëŸ¬ ${res.status}`, true);
        log(`[ERR] GET ì‹¤íŒ¨: ${JSON.stringify(json)}`, "err");
        throw new Error("GET ì‹¤íŒ¨");
      }

      setApiStatus("GET ì„±ê³µ");
      return json;
    }

    async function saveRoute({ camp, code, polygon_wgs84, center_wgs84 }) {
      const url = ROUTE_API_BASE + "/route";
      const body = { camp, code, polygon_wgs84, center_wgs84 };

      log(`[LOG] POST /route ìš”ì²­: ${JSON.stringify(body)}`, "info");
      setApiStatus("POST /route í˜¸ì¶œ ì¤‘...");

      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: JSON.stringify(body),
      });

      const json = await res.json().catch(() => ({}));
      if (!res.ok) {
        setApiStatus(`POST ì—ëŸ¬ ${res.status}`, true);
        log(`[ERR] POST ì‹¤íŒ¨: ${JSON.stringify(json)}`, "err");
        throw new Error("POST ì‹¤íŒ¨");
      }

      setApiStatus("POST ì„±ê³µ");
      return json;
    }

    async function adminAction(body) {
      const url = ROUTE_API_BASE + "/admin";
      log(`[LOG] POST /admin ìš”ì²­: ${JSON.stringify(body)}`, "info");
      setApiStatus("ADMIN í˜¸ì¶œ ì¤‘...");

      const res = await fetch(url, {
        method:"POST",
        headers: { "Content-Type":"application/json; charset=utf-8" },
        body: JSON.stringify(body),
      });

      const json = await res.json().catch(()=>({}));
      if (!res.ok) {
        setApiStatus(`ADMIN ì—ëŸ¬ ${res.status}`, true);
        log(`[ERR] ADMIN ì‹¤íŒ¨: ${JSON.stringify(json)}`, "err");
        throw new Error("ADMIN ì‹¤íŒ¨");
      }
      setApiStatus("ADMIN ì„±ê³µ");
      return json;
    }

    async function deleteRouteRowById(id) {
      const url = new URL(ROUTE_API_BASE + "/route");
      url.searchParams.set("id", String(id));

      log(`[LOG] DELETE /route ìš”ì²­: ${url.toString()}`, "info");
      setApiStatus("DELETE /route í˜¸ì¶œ ì¤‘...");

      const res = await fetch(url.toString(), { method:"DELETE" });
      const json = await res.json().catch(()=>({}));

      if (!res.ok) {
        setApiStatus(`DELETE ì—ëŸ¬ ${res.status}`, true);
        log(`[ERR] DELETE ì‹¤íŒ¨: ${JSON.stringify(json)}`, "err");
        throw new Error("DELETE ì‹¤íŒ¨");
      }

      setApiStatus("DELETE ì„±ê³µ");
      return json;
    }

    // ================== ë¼ë²¨ ì¶©ëŒ ë°©ì§€ ==================
    function adjustLabelPositions(labels) {
      // ë¹ˆ ë°°ì—´ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
      if (!labels || labels.length === 0) {
        return [];
      }

      // ë¼ë²¨ ê°„ ì¶©ëŒì„ ê°ì§€í•˜ê³  ìœ„ì¹˜ë¥¼ ì¡°ì •
      const labelData = labels.map(l => {
        // ì•ˆì „ ì²´í¬
        if (!l || !l.pos || !isFiniteNum(l.pos.lat) || !isFiniteNum(l.pos.lng)) {
          return null;
        }
        return {
          entry: l.entry,
          region: l.region,
          original: { lat: l.pos.lat, lng: l.pos.lng },
          adjusted: { lat: l.pos.lat, lng: l.pos.lng },
          text: l.text || ""
        };
      }).filter(Boolean);

      // ìœ íš¨í•œ ë¼ë²¨ì´ ì—†ìœ¼ë©´ ë°˜í™˜
      if (labelData.length === 0) {
        return [];
      }

      const labelPadding = 0.0015; // ë¼ë²¨ ê°„ ìµœì†Œ ê±°ë¦¬ (ì•½ 150m)
      const maxIterations = 50;
      const adjustStep = 0.0003; // ì¡°ì • ìŠ¤í… (ì•½ 30m)

      // ë°˜ë³µì ìœ¼ë¡œ ì¶©ëŒ í•´ê²°
      for (let iter = 0; iter < maxIterations; iter++) {
        let hasCollision = false;

        for (let i = 0; i < labelData.length; i++) {
          for (let j = i + 1; j < labelData.length; j++) {
            const a = labelData[i].adjusted;
            const b = labelData[j].adjusted;

            const dist = Math.sqrt(
              Math.pow(a.lat - b.lat, 2) + 
              Math.pow((a.lng - b.lng) * Math.cos(a.lat * Math.PI / 180), 2)
            );

            if (dist < labelPadding) {
              hasCollision = true;

              // ì¶©ëŒ ì‹œ ì„œë¡œ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì´ë™
              const angle = Math.atan2(a.lat - b.lat, a.lng - b.lng);
              
              labelData[i].adjusted.lat += Math.sin(angle) * adjustStep;
              labelData[i].adjusted.lng += Math.cos(angle) * adjustStep;
              
              labelData[j].adjusted.lat -= Math.sin(angle) * adjustStep;
              labelData[j].adjusted.lng -= Math.cos(angle) * adjustStep;
            }
          }
        }

        if (!hasCollision) break;
      }

      return labelData;
    }

    // ================== ì˜¤ë²„ë ˆì´ ê´€ë¦¬ ==================
    function clearAllOverlays() {
      for (const entry of state.rowsById.values()) {
        entry.regions.forEach(p => p.setMap(null));
        entry.labels.forEach(l => l.setMap(null));
        entry.xbtns.forEach(x => x.setMap(null));
      }
      state.rowsById.clear();
      state.editId = null;
      state.editDraft = null;
      setOverlayText("ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ. ë¶ˆëŸ¬ì˜¤ê¸° ê°€ëŠ¥.");
    }

    function setRegionsVisibility(visibleIdsSet) {
      for (const [id, entry] of state.rowsById.entries()) {
        const show = !visibleIdsSet || visibleIdsSet.has(id);
        entry.regions.forEach(p => p.setMap(show ? state.map : null));
        if (state.labelsOn) entry.labels.forEach(l => l.setMap(show ? state.map : null));
        entry.xbtns.forEach(x => x.setMap(null)); // xëŠ” ì„ íƒ ëŒ€ìƒë§Œ í‘œì‹œ
      }
    }

    function createPolygonFromRegion(region, color, rowId) {
      const path = region.map(p => new kakao.maps.LatLng(p.lat, p.lng));
      const poly = new kakao.maps.Polygon({
        map: state.map,
        path,
        strokeWeight: 2,
        strokeColor: color,
        strokeOpacity: 0.9,
        strokeStyle: "solid",
        fillColor: color,
        fillOpacity: 0.25,
        draggable: true,   // âœ… í•­ìƒ ë“œë˜ê·¸ ê°€ëŠ¥
        editable: true,    // âœ… í•­ìƒ í¸ì§‘ ê°€ëŠ¥!
        zIndex: 1
      });
      poly.__mw_points = region;
      poly.__mw_rowId = rowId;

      // í´ë¦­ ì‹œ í¸ì§‘ ëŒ€ìƒ ì„ íƒ
      kakao.maps.event.addListener(poly, "click", (e) => {
        selectRowId(rowId);
        log(`[LOG] ğŸ“ í´ë¦¬ê³¤ ì„ íƒë¨. ì ì„ ë“œë˜ê·¸í•´ì„œ ìˆ˜ì •í•˜ì„¸ìš”!`, "info");
      });

      // í¸ì§‘ ì™„ë£Œ ì‹œ ìë™ ì €ì¥
      kakao.maps.event.addListener(poly, "mouseup", () => {
        const newPts = extractPathFromPolygon(poly);
        if (newPts.length >= 3) {
          poly.__mw_points = newPts;
          log(`[LOG] âœ… í´ë¦¬ê³¤ ìˆ˜ì •ë¨: ${newPts.length}ê°œ ì . [ì €ì¥] í´ë¦­í•´ì„œ DBì— ë°˜ì˜í•˜ì„¸ìš”.`, "info");
        }
      });

      return poly;
    }

    function createLabelOverlay(region, text) {
      const pos = polylabelPoint(region) || computeCenter(region);
      if (!pos) return null;
      return new kakao.maps.CustomOverlay({
        position: new kakao.maps.LatLng(pos.lat, pos.lng),
        content: `<div class="route-label">${escapeHtml(text)}</div>`,
        yAnchor: 1,
        zIndex: 10,
      });
    }

    function createXButton(region, onClick) {
      const p0 = region && region.length ? region[0] : null;
      if (!p0) return null;

      const div = document.createElement("div");
      div.className = "xbtn";
      div.textContent = "Ã—";
      div.onclick = (e) => { e.preventDefault(); e.stopPropagation(); onClick(); };

      return new kakao.maps.CustomOverlay({
        position: new kakao.maps.LatLng(p0.lat, p0.lng),
        content: div,
        yAnchor: 0.5,
        zIndex: 100,
      });
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    // ================== ë Œë” ==================
    function renderRows(rows) {
      clearAllOverlays();

      // ìƒ‰ìƒ ê²°ì •(ì¸ì ‘ ìœ ì‚¬ìƒ‰ ìµœì†Œí™”)
      assignColorsGreedy(rows);

      // 1ë‹¨ê³„: í´ë¦¬ê³¤ ìƒì„± ë° ì´ˆê¸° ë¼ë²¨ ìœ„ì¹˜ ìˆ˜ì§‘
      const allLabelData = [];
      let shown = 0;

      rows.forEach((row) => {
        const regions = normalizePolygonWgs84(row.polygon_wgs84);
        if (!regions.length) return;

        const rowId = row.id;
        const routeKey = routeKeyFromRow(row);
        const color = getColorForRouteKey(routeKey);

        const entry = { row, regions: [], labels: [], xbtns: [] };

        regions.forEach((region) => {
          const poly = createPolygonFromRegion(region, color, rowId);
          entry.regions.push(poly);

          // ë¼ë²¨ ìœ„ì¹˜ ê³„ì‚° (ì•„ì§ ìƒì„±í•˜ì§€ ì•ŠìŒ)
          const pos = polylabelPoint(region) || computeCenter(region);
          if (pos) {
            allLabelData.push({
              entry: entry,
              region: region,
              pos: pos,
              text: (row.full_code || row.code || "")
            });
          }
        });

        state.rowsById.set(rowId, entry);
        shown++;
      });

      // 2ë‹¨ê³„: ë¼ë²¨ ìœ„ì¹˜ ì¶©ëŒ í•´ê²°
      const adjustedLabels = adjustLabelPositions(allLabelData);

      // 3ë‹¨ê³„: ì¡°ì •ëœ ìœ„ì¹˜ë¡œ ë¼ë²¨ ìƒì„±
      if (adjustedLabels && adjustedLabels.length > 0) {
        adjustedLabels.forEach(labelData => {
          if (!labelData || !labelData.entry) return;
          try {
            const overlay = new kakao.maps.CustomOverlay({
              position: new kakao.maps.LatLng(labelData.adjusted.lat, labelData.adjusted.lng),
              content: `<div class="route-label">${escapeHtml(labelData.text)}</div>`,
              yAnchor: 1,
              zIndex: 10,
            });
            labelData.entry.labels.push(overlay);
          } catch (e) {
            log(`[WARN] ë¼ë²¨ ìƒì„± ì‹¤íŒ¨: ${e.message}`, "warn");
          }
        });
      }

      // ë¼ë²¨ í† ê¸€ ë°˜ì˜
      if (!state.labelsOn) {
        for (const entry of state.rowsById.values()) entry.labels.forEach(l => l.setMap(null));
      } else {
        for (const entry of state.rowsById.values()) entry.labels.forEach(l => l.setMap(state.map));
      }

      // bounds
      fitBoundsAll();

      log(`[LOG] ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ. í‘œì‹œ ${shown}ê°œ (í¸ì§‘ ëŒ€ìƒ: ${getEditTargetKey() || "ì—†ìŒ"})`, "info");
      setOverlayText(`í‘œì‹œ ${shown}ê°œ Â· í¸ì§‘ ëŒ€ìƒ: ${getEditTargetKey() || "ì—†ìŒ"}`);

      refreshSelectionUI();
    }

    function fitBoundsAll() {
      if (!state.map) return;
      const b = new kakao.maps.LatLngBounds();
      let has = false;

      for (const entry of state.rowsById.values()) {
        entry.regions.forEach((poly) => {
          const pts = poly.__mw_points || [];
          pts.forEach(p => {
            b.extend(new kakao.maps.LatLng(p.lat, p.lng));
            has = true;
          });
        });
      }
      if (has) state.map.setBounds(b);
    }

    // ================== í¸ì§‘ ëŒ€ìƒ ê´€ë¦¬ ==================
    function getEditTargetRow() {
      if (state.editId && state.rowsById.has(state.editId)) return state.rowsById.get(state.editId).row;
      return null;
    }

    function getEditTargetKey() {
      const row = getEditTargetRow();
      if (row) return routeKeyFromRow(row);
      if (state.editDraft && state.editDraft.code) return `${state.editDraft.camp || ""}::${state.editDraft.code}`;
      return null;
    }

    function selectRowId(rowId) {
      if (!state.rowsById.has(rowId)) return;
      state.editId = rowId;
      state.editDraft = null;

      const row = state.rowsById.get(rowId).row;
      routeInput.value = row.full_code || row.code || routeInput.value;

      log(`[LOG] í¸ì§‘ ëŒ€ìƒ ì „í™˜: ${(row.full_code || row.code || "")}`, "info");
      refreshSelectionUI();
    }

    function selectByTargetKey(targetKey) {
      // draft í´ë¦­(ìƒˆë¡œ ê·¸ë¦° overlay)ì¼ ìˆ˜ë„ ìˆì–´ì„œ rowIdê°€ ì—†ëŠ” ì¼€ì´ìŠ¤ ì²˜ë¦¬
      // ìš°ì„  DB row ì¤‘ routeKeyê°€ ì¼ì¹˜í•˜ëŠ” ì²« rowë¥¼ ì„ íƒ
      for (const [id, entry] of state.rowsById.entries()) {
        if (routeKeyFromRow(entry.row) === targetKey) {
          selectRowId(id);
          return;
        }
      }
      // ì—†ìœ¼ë©´ draftë¡œ ìœ ì§€
      state.editId = null;
      const parts = String(targetKey).split("::");
      state.editDraft = { camp: parts[0] || "", code: parts[1] || "" };
      refreshSelectionUI();
    }

    function refreshSelectionUI() {
      // ìˆ¨ê¸°ê¸° í† ê¸€ ë°˜ì˜
      if (state.hideOtherRoutes) {
        const only = new Set();
        if (state.editId) only.add(state.editId);
        setRegionsVisibility(only.size ? only : null);
      } else {
        setRegionsVisibility(null);
      }

      // ë¼ë²¨ ì¬ë°°ì¹˜ë¥¼ ìœ„í•œ ë°ì´í„° ìˆ˜ì§‘
      const allLabelData = [];
      
      // ì„ íƒ ê°•ì¡° + X ë²„íŠ¼ ë¶€ì°©
      for (const [id, entry] of state.rowsById.entries()) {
        const isSel = (id === state.editId);

        entry.regions.forEach((poly) => {
          const color = getColorForRouteKey(routeKeyFromRow(entry.row));
          poly.setOptions({
            strokeWeight: isSel ? 3 : 2,
            strokeColor: isSel ? "#ff6b00" : color,  // âœ… ì„ íƒ ì‹œ ì£¼í™©ìƒ‰
            fillColor: color,
            fillOpacity: isSel ? 0.35 : 0.25,
            zIndex: isSel ? 10 : 1
          });

          // ë¼ë²¨ ìœ„ì¹˜ ìˆ˜ì§‘ (ì¶©ëŒ ë°©ì§€ë¥¼ ìœ„í•´)
          if (state.labelsOn) {
            const region = poly.__mw_points || [];
            const pos = polylabelPoint(region) || computeCenter(region);
            if (pos) {
              allLabelData.push({
                entry: entry,
                region: region,
                pos: pos,
                text: (entry.row.full_code || entry.row.code || "")
              });
            }
          }
        });

        // ê¸°ì¡´ ë¼ë²¨ ì œê±°
        entry.labels.forEach(l => l.setMap(null));
        entry.labels = [];

        // X ë²„íŠ¼ì€ ì„ íƒ ëŒ€ìƒì—ë§Œ
        entry.xbtns.forEach(x => x.setMap(null));
        entry.xbtns = [];
        if (isSel) {
          entry.regions.forEach((poly, idx) => {
            const region = poly.__mw_points || [];
            const xbtn = createXButton(region, () => {
              // êµ¬ì—­ ì‚­ì œ
              poly.setMap(null);
              entry.regions.splice(idx, 1);

              log("[WARN] í¸ì§‘ êµ¬ì—­ ì‚­ì œë¨(X). ì €ì¥í•˜ë©´ DBì—ë„ ë°˜ì˜ë©ë‹ˆë‹¤.", "warn");
              refreshSelectionUI();
            });
            if (xbtn) {
              xbtn.setMap(state.map);
              entry.xbtns.push(xbtn);
            }
          });
        }
      }

      // ë¼ë²¨ ì¶©ëŒ ë°©ì§€ ì ìš© ë° ìƒì„±
      if (state.labelsOn && allLabelData.length > 0) {
        const adjustedLabels = adjustLabelPositions(allLabelData);
        if (adjustedLabels && adjustedLabels.length > 0) {
          adjustedLabels.forEach(labelData => {
            if (!labelData || !labelData.entry) return;
            try {
              const overlay = new kakao.maps.CustomOverlay({
                position: new kakao.maps.LatLng(labelData.adjusted.lat, labelData.adjusted.lng),
                content: `<div class="route-label">${escapeHtml(labelData.text)}</div>`,
                yAnchor: 1,
                zIndex: 10,
              });
              overlay.setMap(state.map);
              labelData.entry.labels.push(overlay);
            } catch (e) {
              log(`[WARN] ë¼ë²¨ ìƒì„± ì‹¤íŒ¨: ${e.message}`, "warn");
            }
          });
        }
      }

      // ë¼ë²¨ ë²„íŠ¼ í…ìŠ¤íŠ¸
      labelToggleBtn.textContent = state.labelsOn ? "ë¼ìš°íŠ¸ ë¼ë²¨ ON" : "ë¼ìš°íŠ¸ ë¼ë²¨ OFF";
      hideToggleBtn.textContent  = state.hideOtherRoutes ? "ë¼ìš°íŠ¸ ìˆ¨ê¸°ê¸° ON" : "ë¼ìš°íŠ¸ ìˆ¨ê¸°ê¸° OFF";

      const key = getEditTargetKey();
      setOverlayText(`í¸ì§‘ ëŒ€ìƒ: ${key || "ì—†ìŒ"} Â· ë¼ë²¨:${state.labelsOn?"ON":"OFF"} Â· ìˆ¨ê¹€:${state.hideOtherRoutes?"ON":"OFF"}`);
    }

    function attachRegionToEditTarget(overlay) {
      // DB row í¸ì§‘ì´ë©´ í•´ë‹¹ rowId ì—”íŠ¸ë¦¬ì— ë¶™ì„
      if (state.editId && state.rowsById.has(state.editId)) {
        const entry = state.rowsById.get(state.editId);
        entry.regions.push(overlay);
        return;
      }

      // draftë©´, ë³„ë„ ì—”íŠ¸ë¦¬ë¥¼ ë§Œë“¤ í•„ìš”ëŠ” ì—†ìŒ(ì €ì¥ ì‹œ codeë¡œ upsert)
      // ë‹¨, í™”ë©´ í‘œì‹œ/ì‚­ì œë¥¼ ìœ„í•´ ì„ì‹œ rowIdë¥¼ ë§Œë“¤ì–´ ê´€ë¦¬
      const fakeId = "__draft__";
      if (!state.rowsById.has(fakeId)) {
        const draft = { id: fakeId, camp: (campInput.value||"").trim() || null, code: (routeInput.value||"").trim(), full_code: (routeInput.value||"").trim() };
        state.rowsById.set(fakeId, { row: draft, regions: [overlay], labels: [], xbtns: [] });
        state.editId = fakeId;
      } else {
        state.rowsById.get(fakeId).regions.push(overlay);
        state.editId = fakeId;
      }
    }

    // ================== ë²„íŠ¼ ì´ë²¤íŠ¸ ==================
    loadBtn.addEventListener("click", async () => {
      const camp = (campInput.value || "").trim();
      const code = (routeInput.value || "").trim();

      if (!camp && !code) {
        alert("camp ë˜ëŠ” code ì¤‘ í•˜ë‚˜ëŠ” ì…ë ¥í•´ì£¼ì„¸ìš”.");
        return;
      }

      try {
        const data = await fetchRoutes({ camp, code, mode: "prefix" });

        const rows = Array.isArray(data?.rows) ? data.rows
                 : Array.isArray(data?.routes) ? data.routes
                 : Array.isArray(data) ? data
                 : [];

        if (!rows.length) {
          log("[WARN] GET ê²°ê³¼ ì—†ìŒ", "warn");
          alert("ì¼ì¹˜í•˜ëŠ” ë¼ìš°íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        // polygon ìˆëŠ” rowë§Œ ìš°ì„  ë Œë”
        const usable = rows.filter(r => normalizePolygonWgs84(r.polygon_wgs84).length > 0);
        if (!usable.length) {
          log("[WARN] polygon ìˆëŠ” rowê°€ ì—†ìŒ", "warn");
          alert("í‘œì‹œ ê°€ëŠ¥í•œ í´ë¦¬ê³¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        renderRows(usable);
      } catch (e) {
        alert("ë¼ìš°íŠ¸ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
    });

    drawBtn.addEventListener("click", () => {
      const camp = (campInput.value || "").trim();
      const code = (routeInput.value || "").trim();

      if (!code) {
        alert("ìƒˆë¡œ ê·¸ë¦¬ê¸°ëŠ” ë¼ìš°íŠ¸ ì½”ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤. (ë˜ëŠ” ì§€ë„ì—ì„œ ë¼ìš°íŠ¸ë¥¼ í´ë¦­í•´ í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ì„ íƒ)");
        return;
      }

      // í¸ì§‘ ëŒ€ìƒì´ ìˆìœ¼ë©´ í•´ë‹¹ ëŒ€ìƒì˜ ê¸°ì¡´ êµ¬ì—­ì„ ëª¨ë‘ ë¹„ìš°ê³  ë‹¤ì‹œ ê·¸ë¦¼
      if (state.editId && state.rowsById.has(state.editId)) {
        const entry = state.rowsById.get(state.editId);
        entry.regions.forEach(p => p.setMap(null));
        entry.labels.forEach(l => l.setMap(null));
        entry.xbtns.forEach(x => x.setMap(null));
        entry.regions = [];
        entry.labels = [];
        entry.xbtns = [];
        log(`[LOG] ìƒˆë¡œ ê·¸ë¦¬ê¸°: ê¸°ì¡´ êµ¬ì—­ ì´ˆê¸°í™” í›„ ê·¸ë¦¬ê¸° ì‹œì‘ (${code})`, "info");
      } else {
        state.editDraft = { camp, code };
        state.editId = null;
        log(`[LOG] ìƒˆë¡œ ê·¸ë¦¬ê¸°: draft í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ì‹œì‘ (${code})`, "info");
      }

      state.drawingManager.cancel();
      state.drawingManager.select(kakao.maps.drawing.OverlayType.POLYGON);
      setOverlayText("ìƒˆë¡œ ê·¸ë¦¬ê¸° ëª¨ë“œ: ì§€ë„ì—ì„œ ì˜ì—­ì„ ê·¸ë¦¬ì„¸ìš”.");
    });

    addRegionBtn.addEventListener("click", () => {
      const code = (routeInput.value || "").trim();
      if (!code) {
        alert("êµ¬ì—­ ì¶”ê°€ëŠ” ë¼ìš°íŠ¸ ì½”ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.");
        return;
      }
      // í¸ì§‘ ëŒ€ìƒì´ ì—†ìœ¼ë©´ draftë¡œ
      if (!getEditTargetKey()) {
        const camp = (campInput.value || "").trim();
        state.editDraft = { camp, code };
        state.editId = null;
      }
      state.drawingManager.cancel();
      state.drawingManager.select(kakao.maps.drawing.OverlayType.POLYGON);
      log("[LOG] êµ¬ì—­ ì¶”ê°€ ëª¨ë“œ: ëŠê¸´ êµ¬ì—­ì´ë©´ ì¶”ê°€ë¡œ ê·¸ë¦¬ì„¸ìš”.", "info");
      setOverlayText("êµ¬ì—­ ì¶”ê°€ ëª¨ë“œ: ì§€ë„ì—ì„œ ì¶”ê°€ êµ¬ì—­ì„ ê·¸ë¦¬ì„¸ìš”.");
    });

    searchAddressBtn.addEventListener("click", () => {
      new daum.Postcode({
        oncomplete: (d) => {
          const address = d.roadAddress || d.jibunAddress || d.address;
          log(`[LOG] ì£¼ì†Œ ê²€ìƒ‰: ${address}`, "info");
          
          // Kakao ì§€ì˜¤ì½”ë”ë¡œ ì¢Œí‘œ ê²€ìƒ‰
          const geocoder = new kakao.maps.services.Geocoder();
          geocoder.addressSearch(address, (result, status) => {
            if (status === kakao.maps.services.Status.OK) {
              const coords = new kakao.maps.LatLng(result[0].y, result[0].x);
              
              // ì§€ë„ ì´ë™
              state.map.setCenter(coords);
              state.map.setLevel(3); // ì¤Œì¸
              
              // ë§ˆì»¤ í‘œì‹œ (3ì´ˆ í›„ ìë™ ì œê±°)
              const marker = new kakao.maps.Marker({
                map: state.map,
                position: coords
              });
              setTimeout(() => marker.setMap(null), 3000);
              
              log(`[LOG] ìœ„ì¹˜ ì´ë™ ì™„ë£Œ. ì´ì œ í´ë¦¬ê³¤ì„ ê·¸ë ¤ì£¼ì„¸ìš”!`, "info");
              setOverlayText(`ğŸ“ ${address.substring(0, 40)}... - í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ê°€ëŠ¥`);
              
              // ë¼ìš°íŠ¸ ì½”ë“œê°€ ì…ë ¥ë˜ì–´ ìˆìœ¼ë©´ ìë™ìœ¼ë¡œ ê·¸ë¦¬ê¸° ëª¨ë“œ ì‹œì‘
              const code = (routeInput.value || "").trim();
              if (code) {
                // í¸ì§‘ ëŒ€ìƒ ì„¤ì •
                if (!getEditTargetKey()) {
                  const camp = (campInput.value || "").trim();
                  state.editDraft = { camp, code };
                  state.editId = null;
                }
                
                state.drawingManager.cancel();
                state.drawingManager.select(kakao.maps.drawing.OverlayType.POLYGON);
                alert(`ğŸ“ ì£¼ì†Œ ìœ„ì¹˜ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.\nì´ì œ ì§€ë„ì—ì„œ ë°°ë‹¬ êµ¬ì—­ì„ ê·¸ë ¤ì£¼ì„¸ìš”!`);
              } else {
                alert(`ğŸ“ ì£¼ì†Œ ìœ„ì¹˜ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.\në¨¼ì € ë¼ìš°íŠ¸ ì½”ë“œë¥¼ ì…ë ¥í•œ í›„ í´ë¦¬ê³¤ì„ ê·¸ë ¤ì£¼ì„¸ìš”.`);
              }
            } else {
              alert("âŒ ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            }
          });
        }
      }).open();
    });

    saveBtn.addEventListener("click", async () => {
      const camp = (campInput.value || "").trim();
      const code = (routeInput.value || "").trim();

      if (!camp || !code) {
        alert("ì €ì¥ì€ camp + code ë‘˜ ë‹¤ í•„ìš”í•©ë‹ˆë‹¤.");
        return;
      }

      // í¸ì§‘ ëŒ€ìƒì˜ regions ëª¨ìœ¼ê¸°
      let regions = [];
      let targetRow = null;

      if (state.editId && state.rowsById.has(state.editId)) {
        const entry = state.rowsById.get(state.editId);
        targetRow = entry.row;
        regions = entry.regions.map(p => p.__mw_points || extractPathFromPolygon(p)).filter(r => r && r.length >= 3);
      } else {
        // draft ì €ì¥: í™”ë©´ì— draft ì—”íŠ¸ë¦¬ê°€ ìˆìœ¼ë©´ ê±°ê¸°ì„œ ê°€ì ¸ì˜´
        const draftEntry = state.rowsById.get("__draft__");
        if (draftEntry) {
          regions = draftEntry.regions.map(p => p.__mw_points || extractPathFromPolygon(p)).filter(r => r && r.length >= 3);
        }
      }

      // êµ¬ì—­ 0ê°œë©´ â€œí´ë¦¬ê³¤ ì‚­ì œ ì €ì¥â€
      let polygon_wgs84 = null;
      let center_wgs84 = null;

      if (regions.length > 0) {
        polygon_wgs84 = (regions.length === 1) ? regions[0] : regions;
        center_wgs84 = computeCenterMulti(regions);
        log(`[LOG] ì €ì¥ ì¤€ë¹„: code=${code}, êµ¬ì—­ ${regions.length}ê°œ, ì¤‘ì‹¬ (${center_wgs84.lat.toFixed(6)}, ${center_wgs84.lng.toFixed(6)})`, "info");
      } else {
        log(`[WARN] ì €ì¥ ì¤€ë¹„: code=${code}, êµ¬ì—­ 0ê°œ â†’ polygon_wgs84=null ì €ì¥(ì‚­ì œ)`, "warn");
      }

      try {
        await saveRoute({ camp, code, polygon_wgs84, center_wgs84 });
        alert("ì €ì¥ ì™„ë£Œ");

        // ì €ì¥ í›„ ì¬ì¡°íšŒ
        const data = await fetchRoutes({ camp, code, mode:"prefix" });
        const rows = Array.isArray(data?.rows) ? data.rows : [];
        const usable = rows.filter(r => normalizePolygonWgs84(r.polygon_wgs84).length > 0);
        if (usable.length) renderRows(usable);
        else {
          // í´ë¦¬ê³¤ ì‚­ì œëœ ìƒíƒœë©´ í™”ë©´ì—ì„œë„ ì œê±°
          clearAllOverlays();
          log("[LOG] ì €ì¥ í›„ í´ë¦¬ê³¤ì´ ì—†ì–´ í‘œì‹œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.", "info");
        }
      } catch (e) {
        alert("ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. (ë¡œê·¸ í™•ì¸)");
      }
    });

    labelToggleBtn.addEventListener("click", () => {
      state.labelsOn = !state.labelsOn;
      log(`[LOG] ë¼ìš°íŠ¸ ë¼ë²¨ ${state.labelsOn ? "ON" : "OFF"}`, "info");
      refreshSelectionUI();
    });

    hideToggleBtn.addEventListener("click", () => {
      state.hideOtherRoutes = !state.hideOtherRoutes;
      log(`[LOG] ë¼ìš°íŠ¸ ìˆ¨ê¸°ê¸° ${state.hideOtherRoutes ? "ON" : "OFF"}`, "info");
      refreshSelectionUI();
    });

    resetBtn.addEventListener("click", () => {
      clearAllOverlays();
      state.drawingManager.cancel();
      log("[LOG] ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ.", "info");
    });

    // ================== ì§€ë„ ì •ë ¬(ì‹¤í—˜) ==================
    // í˜„ì‹¤ì ìœ¼ë¡œ â€œì£¼ì†Œ/ê±´ë¬¼ ê°ì²´ ë‹¨ìœ„ë¡œ ì •í™•íˆ ë§ì¶¤â€ì€ OSM/ê±´ë¬¼footprint + ê³µê°„ì—°ì‚°(êµì§‘í•©/í•©ì§‘í•©)ì´ í•„ìš”í•©ë‹ˆë‹¤.
    // ì—¬ê¸°ì„œëŠ” ìµœì†Œ ë™ì‘: (1) í˜„ì¬ í´ë¦¬ê³¤ì„ ì•½ê°„ ìŠ¤ëƒ…/ë²„í¼ â†’ (2) ìë™ ì €ì¥
    alignBtn.addEventListener("click", async () => {
      const camp = (campInput.value || "").trim();
      const code = (routeInput.value || "").trim();

      if (!camp || !code) {
        alert("ì •ë ¬/ì €ì¥ì€ camp + codeê°€ í•„ìš”í•©ë‹ˆë‹¤.");
        return;
      }

      // í¸ì§‘ ëŒ€ìƒì´ ì—†ìœ¼ë©´(í†µë…¸ì„  ìƒíƒœ) â†’ í˜„ì¬ í‘œì‹œëœ ê²ƒ ì „ë¶€ ì •ë ¬(ìµœëŒ€ 8ê°œ ë³´í˜¸)
      let targetIds = [];
      if (state.editId && state.rowsById.has(state.editId)) {
        targetIds = [state.editId];
      } else {
        targetIds = [...state.rowsById.keys()].filter(id => id !== "__draft__").slice(0, 8);
        if (!targetIds.length) {
          alert("ì •ë ¬í•  ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤. (í‘œì‹œëœ ë¼ìš°íŠ¸ê°€ ì—†ìŒ)");
          return;
        }
      }

      try {
        setApiStatus("ì •ë ¬ ì¤‘...");
        log(`[LOG] ì§€ë„ ì •ë ¬ ì‹œì‘: ëŒ€ìƒ ${targetIds.length}ê°œ`, "info");

        for (const rid of targetIds) {
          const entry = state.rowsById.get(rid);
          if (!entry) continue;

          const regions = entry.regions.map(p => p.__mw_points || extractPathFromPolygon(p)).filter(r => r.length >= 3);
          if (!regions.length) continue;

          // ê°•í™”ëœ ì •ë ¬: 1) í° ë²„í¼ë¡œ ë¾°ì¡±í•œ ë¶€ë¶„ ì œê±° 2) ë‹¨ìˆœí™” 3) ìŠ¤ë¬´ë”©
          let feature = regionsToTurf(regions);
          if (!feature) continue;

          try {
            // 1ë‹¨ê³„: í° ë²„í¼ë¡œ ë¾°ì¡±í•œ ë¶€ë¶„ í¡ìˆ˜ (20m)
            feature = turf.buffer(feature, 0.02, { units:"kilometers" });
            
            // 2ë‹¨ê³„: ë‹¤ì‹œ ì¤„ì—¬ì„œ ì›ë˜ í¬ê¸°ë¡œ (-15m, ì•½ê°„ ì‘ê²Œ)
            feature = turf.buffer(feature, -0.015, { units:"kilometers" });
            
            // 3ë‹¨ê³„: í˜•ìƒ ë‹¨ìˆœí™” (ë„ˆë¬´ ë³µì¡í•œ ê²½ê³„ ì •ë¦¬)
            feature = turf.simplify(feature, { tolerance: 0.00005, highQuality: true });
            
            // 4ë‹¨ê³„: ìµœì¢… ìŠ¤ë¬´ë”© (+3m, -3m)
            feature = turf.buffer(feature, 0.003, { units:"kilometers" });
            feature = turf.buffer(feature, -0.003, { units:"kilometers" });
            
            log(`[LOG] âœ‚ï¸ í˜•ìƒ ì •ë¦¬ ì™„ë£Œ (ë¾°ì¡±í•œ ë¶€ë¶„ ì œê±°)`, "info");
          } catch (e) {
            log(`[WARN] ì •ë ¬ ë²„í¼ ì‹¤íŒ¨(ë¬´ì‹œ): ${String(e)}`, "warn");
          }

          const newRegions = turfToRegions(feature);
          if (!newRegions.length) continue;

          // ê¸°ì¡´ ì˜¤ë²„ë ˆì´ ì œê±° í›„ ì¬ìƒì„±
          entry.regions.forEach(p => p.setMap(null));
          entry.labels.forEach(l => l.setMap(null));
          entry.xbtns.forEach(x => x.setMap(null));
          entry.regions = [];
          entry.labels = [];
          entry.xbtns = [];

          const routeKey = routeKeyFromRow(entry.row);
          const color = getColorForRouteKey(routeKey);

          newRegions.forEach((reg) => {
            const poly = createPolygonFromRegion(reg, color, entry.row.id);
            entry.regions.push(poly);
          });

          // ìë™ ì €ì¥
          const center = computeCenterMulti(newRegions);
          const payloadPoly = (newRegions.length === 1) ? newRegions[0] : newRegions;

          await saveRoute({
            camp: camp,
            code: entry.row.full_code || entry.row.code,
            polygon_wgs84: payloadPoly,
            center_wgs84: center
          });

          log(`[LOG] ì •ë ¬+ì €ì¥ ì™„ë£Œ: ${entry.row.full_code || entry.row.code} (êµ¬ì—­ ${newRegions.length}ê°œ)`, "info");
        }

        setApiStatus("ì •ë ¬ ì™„ë£Œ");
        refreshSelectionUI();
        alert("ì •ë ¬(ì‹¤í—˜) ì™„ë£Œ: ë²„í¼ ê¸°ë°˜ ê°„ë‹¨ ë³´ì • + ìë™ ì €ì¥ ì™„ë£Œ");
      } catch (e) {
        setApiStatus("ì •ë ¬ ì‹¤íŒ¨", true);
        log("[ERR] ì •ë ¬ ì‹¤íŒ¨: " + String(e), "err");
        alert("ì •ë ¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë¡œê·¸ í™•ì¸");
      }
    });

    function regionsToTurf(regions) {
      try {
        const polys = regions.map((reg) => {
          const ring = reg.map(p => [p.lng, p.lat]);
          if (ring.length && (ring[0][0] !== ring[ring.length-1][0] || ring[0][1] !== ring[ring.length-1][1])) ring.push(ring[0]);
          return turf.polygon([ring]);
        });

        let merged = polys[0];
        for (let i=1;i<polys.length;i++) {
          const u = turf.union(merged, polys[i]);
          if (u) merged = u;
        }
        return merged;
      } catch (e) {
        log("[WARN] regionsToTurf ì‹¤íŒ¨: " + String(e), "warn");
        return null;
      }
    }

    function turfToRegions(feature) {
      const out = [];
      try {
        const geom = feature?.geometry;
        if (!geom) return out;

        if (geom.type === "Polygon") {
          const ring = geom.coordinates?.[0] || [];
          const reg = ring.map(c => ({ lng: c[0], lat: c[1] })).map(normalizePoint).filter(Boolean);
          if (reg.length >= 3) out.push(reg);
          return out;
        }

        if (geom.type === "MultiPolygon") {
          const polys = geom.coordinates || [];
          polys.forEach((p) => {
            const ring = p?.[0] || [];
            const reg = ring.map(c => ({ lng: c[0], lat: c[1] })).map(normalizePoint).filter(Boolean);
            if (reg.length >= 3) out.push(reg);
          });
          return out;
        }
      } catch (e) {
        log("[WARN] turfToRegions ì‹¤íŒ¨: " + String(e), "warn");
      }
      return out;
    }

    // ================== DB ìˆ˜ì • ë²„íŠ¼ ==================
    updateCampSelectedBtn.addEventListener("click", async () => {
      const newCamp = (campEditInput.value || "").trim();
      if (!newCamp) { alert("ìƒˆ campëª…ì„ ì…ë ¥í•˜ì„¸ìš”."); return; }

      if (!state.editId || !state.rowsById.has(state.editId)) {
        alert("ë¨¼ì € ì§€ë„ì—ì„œ ë¼ìš°íŠ¸ë¥¼ í´ë¦­í•´ í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ì„ íƒí•˜ì„¸ìš”.");
        return;
      }

      const row = state.rowsById.get(state.editId).row;
      try {
        const res = await adminAction({
          action: "updateCampSelected",
          id: row.id,
          new_camp: newCamp
        });
        alert(`ì„ íƒ camp ìˆ˜ì • ì™„ë£Œ (id=${row.id})`);

        // í™”ë©´ë„ ì¦‰ì‹œ ë°˜ì˜
        campInput.value = newCamp;
        await loadBtn.click();
      } catch {
        alert("ì„ íƒ camp ìˆ˜ì • ì‹¤íŒ¨ (ë¡œê·¸ í™•ì¸)");
      }
    });

    moveCampAllBtn.addEventListener("click", async () => {
      const fromCamp = (campInput.value || "").trim();
      const toCamp = (campEditInput.value || "").trim();
      if (!fromCamp || !toCamp) { alert("from camp(ìƒë‹¨ camp)ì™€ to camp(DB ìˆ˜ì • campëª…) ë‘˜ ë‹¤ í•„ìš”í•©ë‹ˆë‹¤."); return; }

      try {
        const res = await adminAction({
          action: "moveCampAll",
          from_camp: fromCamp,
          to_camp: toCamp
        });
        alert(`camp ì „ì²´ ì´ê´€ ì™„ë£Œ: updated=${res.updated || 0}, failed=${res.failed || 0}`);
        campInput.value = toCamp;
        await loadBtn.click();
      } catch {
        alert("camp ì „ì²´ ì´ê´€ ì‹¤íŒ¨ (ë¡œê·¸ í™•ì¸)");
      }
    });

    updateCodeSelectedBtn.addEventListener("click", async () => {
      const newCode = (codeEditInput.value || "").trim();
      if (!newCode) { alert("ìƒˆ codeë¥¼ ì…ë ¥í•˜ì„¸ìš”."); return; }

      if (!state.editId || !state.rowsById.has(state.editId)) {
        alert("ë¨¼ì € ì§€ë„ì—ì„œ ë¼ìš°íŠ¸ë¥¼ í´ë¦­í•´ í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ì„ íƒí•˜ì„¸ìš”.");
        return;
      }
      const row = state.rowsById.get(state.editId).row;

      try {
        const res = await adminAction({
          action: "renameCodeSelected",
          id: row.id,
          new_code: newCode
        });
        alert("ì„ íƒ ì½”ë“œ ìˆ˜ì • ì™„ë£Œ");
        routeInput.value = newCode;
        await loadBtn.click();
      } catch {
        alert("ì„ íƒ ì½”ë“œ ìˆ˜ì • ì‹¤íŒ¨ (ë¡œê·¸ í™•ì¸)");
      }
    });

    deleteSelectedRowBtn.addEventListener("click", async () => {
      if (!state.editId || !state.rowsById.has(state.editId)) {
        alert("ë¨¼ì € ì§€ë„ì—ì„œ ë¼ìš°íŠ¸ë¥¼ í´ë¦­í•´ í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ì„ íƒí•˜ì„¸ìš”.");
        return;
      }
      const row = state.rowsById.get(state.editId).row;
      if (!confirm(`ì •ë§ DB ë ˆì½”ë“œë¥¼ ì‚­ì œí• ê¹Œìš”?\n(id=${row.id}, code=${row.full_code || row.code})`)) return;

      try {
        await deleteRouteRowById(row.id);
        alert("DB ì‚­ì œ ì™„ë£Œ");
        await loadBtn.click();
      } catch {
        alert("DB ì‚­ì œ ì‹¤íŒ¨ (ë¡œê·¸ í™•ì¸)");
      }
    });

    // ================== ì „ì—­ ì—ëŸ¬ í•¸ë“¤ ==================
    window.addEventListener("error", (e) => {
      log(`[ERR] window.error: ${e.message} @ ${e.filename}:${e.lineno}:${e.colno}`, "err");
    });

    // ================== ì‹œì‘ ==================
    kakao.maps.load(initMap);
  </script>
</body>
</html>
