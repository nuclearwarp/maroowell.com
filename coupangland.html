<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>CoupangLand (프론트 임시 MVP)</title>

  <!-- Kakao 지도 SDK -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3"></script>

  <style>
    :root{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --line:#e5e7eb;

      --poly-stroke:#2563eb;
      --poly-fill:rgba(37,99,235,.14);
      --poly-hover-fill:rgba(37,99,235,.20);
      --poly-stroke-weight:3;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    .wrap{
      max-width: 1500px;
      margin: 0 auto;
      padding: 18px 18px 28px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px 14px;
      box-shadow: 0 6px 18px rgba(15,23,42,.06);
      gap:14px;
    }

    .brandbox{
      display:flex;
      gap:12px;
      align-items:flex-start;
      min-width: 280px;
      flex: 1 1 auto;
    }
    .dot{
      width:9px; height:9px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, #a78bfa 0%, #6d28d9 60%, #4c1d95 100%);
      margin-top:6px;
      flex:0 0 auto;
    }
    .titleline{
      display:flex;
      align-items:baseline;
      gap:10px;
      flex-wrap:wrap;
    }
    .title{
      font-weight:900;
      letter-spacing:-.2px;
      font-size:20px;
      line-height:1;
    }
    .pill{
      font-size:12px;
      padding:4px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      color:var(--muted);
      background:#fff;
    }
    .desc{
      margin-top:6px;
      font-size:13px;
      color:var(--muted);
      line-height:1.35;
    }

    /* coupang colored letters */
    .coupang span{ font-weight:900; letter-spacing:-.4px; }
    .coupang .c{ color: rgb(80,16,16); }
    .coupang .o{ color: rgb(80,16,16); }
    .coupang .u{ color: rgb(208,48,32); }
    .coupang .p{ color: rgb(224,144,32); }
    .coupang .a{ color: rgb(144,176,48); }
    .coupang .n{ color: rgb(80,160,208); }
    .coupang .g{ color: rgb(80,160,208); }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex: 0 0 auto;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .btn{
      border:1px solid var(--line);
      background:#fff;
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      font-size:13px;
      cursor:pointer;
    }
    .btn:hover{ border-color:#cbd5e1; }
    .btn.primary{
      background: #f5f3ff;
      border-color: #ddd6fe;
      color: #4c1d95;
    }
    .btn.danger{
      background: #fff1f2;
      border-color: #fecdd3;
      color: #9f1239;
    }

    /* 핵심: 왼쪽(지도) 크게, 오른쪽(상세) 작게 */
    .grid{
      margin-top:14px;
      display:grid;
      grid-template-columns: 1fr 420px;
      gap:14px;
      align-items:start;
    }

    .card{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow: 0 6px 18px rgba(15,23,42,.06);
      overflow:hidden;
      min-width: 0;
    }
    .card .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card .hd .h{
      font-weight:900;
      font-size:15px;
      letter-spacing:-.2px;
    }
    .badge{
      font-size:12px;
      font-weight:800;
      padding:5px 10px;
      border-radius:999px;
      background:#f1f5f9;
      color:#0f172a;
      border:1px solid var(--line);
      white-space:nowrap;
    }
    .bd{
      padding:14px;
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .search{
      flex:1;
      display:flex;
      gap:10px;
      align-items:center;
    }
    input[type="text"]{
      width:100%;
      padding:11px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      outline:none;
      font-size:14px;
      background:#fff;
    }
    input[type="text"]:focus{
      border-color:#c4b5fd;
      box-shadow: 0 0 0 3px rgba(109,40,217,.12);
    }

    .chips{
      margin-top:10px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:#fff;
      font-size:13px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
    }
    .chip:hover{ border-color:#cbd5e1; }
    .chip.active{
      border-color:#c4b5fd;
      background:#f5f3ff;
      color:#4c1d95;
    }
    .chip .mini{
      font-weight:900;
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      background:#0f172a;
      color:#fff;
    }

    /* 지도 크게 */
    #map{
      margin-top:12px;
      width:100%;
      height: 760px;
      border-radius:14px;
      border:1px solid var(--line);
      overflow:hidden;
    }

    .listbox{
      margin-top:12px;
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background:#fff;
    }
    .listbox .lh{
      padding:10px 12px;
      background:#f8fafc;
      border-bottom:1px solid var(--line);
      font-weight:900;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .listbox .lh small{
      color:var(--muted);
      font-weight:800;
    }
    .list{
      max-height: 260px;
      overflow:auto;
    }
    .item{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      cursor:pointer;
    }
    .item:last-child{ border-bottom:none; }
    .item:hover{ background:#f8fafc; }
    .item .nm{
      font-weight:900;
      letter-spacing:-.2px;
      color:#111827;
    }
    .item .ct{
      font-weight:900;
      color:#4b5563;
      background:#f1f5f9;
      border:1px solid var(--line);
      padding:3px 10px;
      border-radius:999px;
      font-size:12px;
      white-space:nowrap;
    }

    .admin{
      margin-top:12px;
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background:#fff;
    }
    .admin .ah{
      padding:10px 12px;
      background:#f8fafc;
      border-bottom:1px solid var(--line);
      font-weight:900;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    textarea{
      width:100%;
      min-height: 240px;
      border:none;
      outline:none;
      padding:12px;
      font-size:13px;
      line-height:1.45;
      resize:vertical;
    }
    .admin .ab{
      padding:10px 12px 12px;
      border-top:1px solid var(--line);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-start;
    }

    /* 오른쪽(상세) 너무 커 보이지 않게 */
    .right .bd{
      padding: 12px 14px 14px;
    }

    .kvs{
      display:grid;
      grid-template-columns: 120px 1fr;
      gap:8px 10px;
      margin-top:4px;
      padding-top:4px;
    }
    .k{
      color:var(--muted);
      font-weight:900;
      font-size:13px;
    }
    .v{
      font-weight:900;
      font-size:13px;
      color:#111827;
    }

    .sep{
      margin:12px 0;
      height:1px;
      background:var(--line);
    }

    .note{
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
    }

    /* overlay badge */
    .ov{
      background:#2563eb;
      color:#fff;
      font-weight:900;
      font-size:12px;
      padding:5px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 6px 14px rgba(0,0,0,.18);
      white-space:nowrap;
      cursor:pointer;
      user-select:none;
    }

    @media (max-width: 1040px){
      .grid{ grid-template-columns: 1fr; }
      #map{ height: 640px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brandbox">
        <div class="dot"></div>
        <div>
          <div class="titleline">
            <div class="title">
              <span class="coupang">
                <span class="c">c</span><span class="o">o</span><span class="u">u</span><span class="p">p</span><span class="a">a</span><span class="n">n</span><span class="g">g</span>
              </span>Land
            </div>
            <span class="pill">프론트 임시 MVP</span>
          </div>
          <div class="desc">시/도 → 시군구 → 동(행정동) 단위로 대리점/라우트 현황을 조회합니다. (백엔드 없음 / localStorage 저장)</div>
        </div>
      </div>

      <div class="actions">
        <button class="btn primary" id="btnAll">전체 보기</button>
        <button class="btn" id="btnCopy">현재 화면 요약 복사</button>
        <button class="btn danger" id="btnReset">데이터 초기화</button>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT -->
      <div class="card left">
        <div class="hd">
          <div class="h">지도 기반 조회</div>
          <div class="badge" id="badgeCount">데이터: 0건</div>
        </div>
        <div class="bd">
          <div class="row">
            <div class="search">
              <input id="q" type="text" placeholder="검색: 예) 대구 / 중구 / 칠성동 / 영등포구 / 마루웰" />
              <button class="btn" id="btnSearch">검색</button>
            </div>
          </div>

          <div class="chips" id="pathChips"></div>
          <div class="chips" id="vendorChips"></div>

          <div id="map"></div>

          <div class="listbox">
            <div class="lh">
              <div id="listTitle">목록</div>
              <small id="listHint">클릭해서 단계 이동</small>
            </div>
            <div class="list" id="list"></div>
          </div>

          <div class="admin">
            <div class="ah">
              <div>데이터 입력/수정 (관리용)</div>
              <div class="badge" id="badgeUnique">유니크: 0</div>
            </div>
            <textarea id="ta" spellcheck="false"></textarea>
            <div class="ab">
              <button class="btn primary" id="btnApply">파싱/적용</button>
              <button class="btn" id="btnSample">샘플(현재 데이터) 로드</button>
              <button class="btn" id="btnExport">유니크 목록 내보내기</button>
            </div>
          </div>

          <div class="note" style="margin-top:10px">
            표시 규칙(줌 레벨): 시/도 선택 후 기본은 <b>시군구</b> 먼저, 더 확대하면 <b>동</b>이 나타납니다.
          </div>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card right">
        <div class="hd">
          <div class="h">현재 선택 상세</div>
          <div class="badge" id="badgeSel">전체</div>
        </div>
        <div class="bd">
          <div class="kvs">
            <div class="k">선택 범위</div><div class="v" id="kvScope">전체</div>
            <div class="k">업체 필터</div><div class="v" id="kvVendor">전체</div>
            <div class="k">유니크(업체+지역)</div><div class="v" id="kvUnique">0</div>
          </div>

          <div class="sep"></div>

          <div style="font-weight:900; margin-bottom:8px;">업체 분포</div>
          <div id="vendorDist" class="note"></div>

          <div class="sep"></div>

          <div style="font-weight:900; margin-bottom:8px;">상위 동(Top 12)</div>
          <div id="topDong" class="note"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /********************
     * Default Data (요청 데이터)
     ********************/
    const DEFAULT_DATA = `영등포구 대림동 마루웰
영등포구 대림동 마루웰
분당구 대장동 투네스트
용인시 수지구 동천동 투네스트
용인시 수지구 동천동 마루웰
용인시 수지구 동천동 강동물류
영등포구 신길동 마루웰
대구광역시 중구 칠성동 마루웰
대구광역시 중구 동인동 마루웰
서울특별시 강서구 염창동 투네스트
서울특별시 강서구 염창동 마루웰
경기도 용인시 수지구 동천동 마루웰
대구광역시 달서구 월성동 지엔제이
대구광역시 중구 대봉동 123로지스
대구광역시 중구 동인동 123로지스
대구광역시 달성군 화원읍 태호물류
대구광역시 동구 검사동 정직한물류
대구광역시 달서구 감삼동 에스제이
대구광역시 수성구 만촌동 수성영업소
용인시 기흥구 마북동 성하
용인시 기흥구 마북동 타이탄
경기도 화성시 영천동 씨제이대한통운 서울장지
경기도 용인시 기흥구 하갈동 신화종합물류
경기도 용인시 기흥구 영덕동 신화종합물류
경기도 용인시 기흥구 보정동 CTR종합물류
경기도 성남시 분당구 분당동 천상로지스틱스
경기도 성남시 분당구 정자동 아이비그룹
경기도 고양시 일산서구 일산동 HR그룹
경기도 고양시 일산서구 일산동 삼보로직스
경기도 고양시 일산서구 일산동 YS물류
경기도 고양시 일산서구 일산동 JK글로벌로직스
경기도 고양시 일산서구 주엽동 가화컴퍼니
경기도 고양시 일산서구 주엽동 삼보로직스`;

    /********************
     * Config / Storage
     ********************/
    const LS = {
      RECORDS: "coupangland_records_v3",
      LAST_TEXT: "coupangland_last_text_v3",
    };

    // Zoom level in Kakao: 1(가장 확대) ~ 14(가장 축소)
    const ZOOM = {
      SHOW_SIGUNGU_AT_OR_ABOVE: 7,
      SHOW_DONG_AT_OR_BELOW: 6,
    };

    const BOUNDARY_URLS = {
      sido: [
        "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2013/json/skorea_provinces_geo_simple.json",
        "https://cdn.jsdelivr.net/gh/southkorea/southkorea-maps@master/kostat/2013/json/skorea_provinces_geo_simple.json"
      ],
      sigungu: [
        "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2013/json/skorea_municipalities_geo_simple.json",
        "https://cdn.jsdelivr.net/gh/southkorea/southkorea-maps@master/kostat/2013/json/skorea_municipalities_geo_simple.json"
      ],
      dongBaseRaw: "https://raw.githubusercontent.com/raqoon886/Local_HangJeongDong/master/",
      dongBaseJsdelivr: "https://cdn.jsdelivr.net/gh/raqoon886/Local_HangJeongDong@master/",
      dongFilePrefix: "hangjeongdong_",
      dongFileSuffix: ".geojson"
    };

    /********************
     * Utilities
     ********************/
    function safeText(s){ return (s ?? "").toString().trim(); }
    function normalizeSpaceOne(s){ return safeText(s).replace(/\s+/g, " ").trim(); }
    function normalizeKey(s){
      return normalizeSpaceOne(s).toLowerCase().replace(/[()]/g,"");
    }

    async function fetchJsonWithFallback(urls){
      let lastErr = null;
      for (const url of urls){
        try{
          const res = await fetch(url, { cache: "force-cache" });
          if (!res.ok) throw new Error("HTTP " + res.status);
          return await res.json();
        }catch(e){
          lastErr = e;
        }
      }
      throw lastErr || new Error("fetch failed");
    }

    function getProp(obj, keys){
      if (!obj) return "";
      for (const k of keys){
        if (obj[k] !== undefined && obj[k] !== null && String(obj[k]).trim() !== ""){
          return String(obj[k]).trim();
        }
      }
      return "";
    }

    function featureNameKOR(f){
      const p = f?.properties || {};
      return getProp(p, ["name","NAME","CTP_KOR_NM","CTPRVN_NM","SIG_KOR_NM","EMD_KOR_NM","adm_nm","admName"]);
    }

    function featureCode(f){
      const p = f?.properties || {};
      const raw = getProp(p, ["code","CTPRVN_CD","CTP_CD","SIDO_CD","SIG_CD","EMD_CD","adm_cd","id"]);
      const onlyNum = String(raw).replace(/\D/g,"");
      return onlyNum;
    }

    function coordsToLatLngPath(ring){
      return ring.map(pt => new kakao.maps.LatLng(pt[1], pt[0]));
    }

    function geometryToPolygonPaths(geom){
      if (!geom) return [];
      const t = geom.type;
      const c = geom.coordinates;

      if (t === "Polygon"){
        const rings = c.map(ring => coordsToLatLngPath(ring));
        return [rings];
      }
      if (t === "MultiPolygon"){
        const polys = [];
        for (const poly of c){
          const rings = poly.map(ring => coordsToLatLngPath(ring));
          polys.push(rings);
        }
        return polys;
      }
      return [];
    }

    function boundsFromPolygonPaths(paths){
      const b = new kakao.maps.LatLngBounds();
      for (const rings of paths){
        for (const ring of rings){
          for (const ll of ring) b.extend(ll);
        }
      }
      return b;
    }

    function centerFromBounds(b){
      return b.getSouthWest() && b.getNorthEast()
        ? new kakao.maps.LatLng(
            (b.getSouthWest().getLat() + b.getNorthEast().getLat())/2,
            (b.getSouthWest().getLng() + b.getNorthEast().getLng())/2
          )
        : null;
    }

    function copyToClipboard(text){
      return navigator.clipboard?.writeText(text);
    }

    /********************
     * Name Normalize
     ********************/
    const SIDO_ALIAS = new Map([
      ["서울", "서울특별시"], ["서울시", "서울특별시"], ["서울특별시", "서울특별시"],
      ["부산", "부산광역시"], ["부산시", "부산광역시"], ["부산광역시", "부산광역시"],
      ["대구", "대구광역시"], ["대구시", "대구광역시"], ["대구광역시", "대구광역시"],
      ["인천", "인천광역시"], ["인천시", "인천광역시"], ["인천광역시", "인천광역시"],
      ["광주", "광주광역시"], ["광주시", "광주광역시"], ["광주광역시", "광주광역시"],
      ["대전", "대전광역시"], ["대전시", "대전광역시"], ["대전광역시", "대전광역시"],
      ["울산", "울산광역시"], ["울산시", "울산광역시"], ["울산광역시", "울산광역시"],
      ["세종", "세종특별자치시"], ["세종시", "세종특별자치시"], ["세종특별자치시", "세종특별자치시"],
      ["경기", "경기도"], ["경기도", "경기도"],
      ["강원", "강원특별자치도"], ["강원도", "강원특별자치도"], ["강원특별자치도", "강원특별자치도"],
      ["충북", "충청북도"], ["충청북도", "충청북도"],
      ["충남", "충청남도"], ["충청남도", "충청남도"],
      ["전북", "전북특별자치도"], ["전라북도", "전북특별자치도"], ["전북특별자치도", "전북특별자치도"],
      ["전남", "전라남도"], ["전라남도", "전라남도"],
      ["경북", "경상북도"], ["경상북도", "경상북도"],
      ["경남", "경상남도"], ["경상남도", "경상남도"],
      ["제주", "제주특별자치도"], ["제주도", "제주특별자치도"], ["제주특별자치도", "제주특별자치도"],
    ]);

    function normalizeSidoName(s){
      s = normalizeSpaceOne(s);
      if (!s) return "";
      return SIDO_ALIAS.get(s) || s;
    }

    function isSidoToken(t){
      const n = normalizeSidoName(t);
      return SIDO_ALIAS.has(t) || (n && (n.endsWith("도") || n.endsWith("특별시") || n.endsWith("광역시") || n.endsWith("특별자치시") || n.endsWith("특별자치도")));
    }

    function isDongToken(t){
      return /(동|읍|면|리)$/.test(t);
    }
    function isSigunguStartTwoTokens(t1, t2){
      return (/(시)$/.test(t1) && /(구|군)$/.test(t2));
    }

    /********************
     * State
     ********************/
    let map;

    const state = {
      selection: { sido:"", sigungu:"", dong:"" },
      vendorFilter: "",

      records: [],

      geo: {
        sido: null,
        sigungu: null,
        dongBySido: new Map(),
      },

      idx: {
        sidoNames: [],
        sidoByCodePrefix: new Map(),

        sigunguBySido: new Map(),       // sido -> [{name, feature}]
        sigunguToSido: new Map(),       // exact name -> Set(sido)
        sigunguSuffixUnique: new Map(), // suffix("분당구") -> {sido, fullName} if unique

        dongBySidoSigungu: new Map(),   // `${sido}||${sigungu}` -> [{dong, feature}]
      },

      layer: {
        polygons: [],
        overlays: [],
        currentType: ""
      },

      lastQuery: ""
    };

    /********************
     * UI Elements
     ********************/
    const el = {
      badgeCount: document.getElementById("badgeCount"),
      badgeUnique: document.getElementById("badgeUnique"),
      badgeSel: document.getElementById("badgeSel"),
      q: document.getElementById("q"),
      btnSearch: document.getElementById("btnSearch"),
      btnAll: document.getElementById("btnAll"),
      btnCopy: document.getElementById("btnCopy"),
      btnReset: document.getElementById("btnReset"),

      pathChips: document.getElementById("pathChips"),
      vendorChips: document.getElementById("vendorChips"),

      listTitle: document.getElementById("listTitle"),
      list: document.getElementById("list"),

      ta: document.getElementById("ta"),
      btnApply: document.getElementById("btnApply"),
      btnSample: document.getElementById("btnSample"),
      btnExport: document.getElementById("btnExport"),

      kvScope: document.getElementById("kvScope"),
      kvVendor: document.getElementById("kvVendor"),
      kvUnique: document.getElementById("kvUnique"),
      vendorDist: document.getElementById("vendorDist"),
      topDong: document.getElementById("topDong"),
    };

    /********************
     * Boundary Load + Index Build
     ********************/
    async function ensureBoundaries(){
      if (!state.geo.sido) state.geo.sido = await fetchJsonWithFallback(BOUNDARY_URLS.sido);
      if (!state.geo.sigungu) state.geo.sigungu = await fetchJsonWithFallback(BOUNDARY_URLS.sigungu);
      buildIndices();
    }

    function buildIndices(){
      state.idx.sidoNames = [];
      state.idx.sidoByCodePrefix = new Map();
      state.idx.sigunguBySido = new Map();
      state.idx.sigunguToSido = new Map();
      state.idx.sigunguSuffixUnique = new Map();

      // provinces
      const sidoFeatures = state.geo.sido?.features || [];
      for (const f of sidoFeatures){
        const nm = normalizeSidoName(featureNameKOR(f));
        if (nm) state.idx.sidoNames.push(nm);

        const cd = featureCode(f);
        if (cd && cd.length >= 2){
          state.idx.sidoByCodePrefix.set(cd.slice(0,2), nm);
        }
      }
      state.idx.sidoNames = [...new Set(state.idx.sidoNames)].sort((a,b)=>a.localeCompare(b,"ko"));

      // municipalities
      const sigFeatures = state.geo.sigungu?.features || [];
      const suffixTemp = new Map(); // suffix -> {count, first:{sido,fullName}}
      for (const f of sigFeatures){
        const sigName = featureNameKOR(f);
        const sig = safeText(sigName);
        if (!sig) continue;

        let sido = "";
        const cd = featureCode(f);
        if (cd && cd.length >= 2){
          sido = state.idx.sidoByCodePrefix.get(cd.slice(0,2)) || "";
        }
        if (!sido){
          sido = normalizeSidoName(getProp(f.properties||{}, ["province","CTPRVN_NM","CTP_KOR_NM","sido","SIDO_NM"]));
        }
        if (!sido){
          const full = getProp(f.properties||{}, ["adm_nm","name"]);
          if (full.includes(" ")){
            const first = full.split(" ")[0];
            sido = normalizeSidoName(first);
          }
        }
        if (!sido) continue;

        if (!state.idx.sigunguBySido.has(sido)) state.idx.sigunguBySido.set(sido, []);
        state.idx.sigunguBySido.get(sido).push({ name: sig, feature: f });

        if (!state.idx.sigunguToSido.has(sig)) state.idx.sigunguToSido.set(sig, new Set());
        state.idx.sigunguToSido.get(sig).add(sido);

        // suffix unique 후보(마지막 토큰)
        const parts = sig.split(" ").filter(Boolean);
        const suffix = parts[parts.length - 1]; // 예: "분당구"
        if (suffix){
          const key = suffix;
          if (!suffixTemp.has(key)) suffixTemp.set(key, {count:0, first:null});
          const rec = suffixTemp.get(key);
          rec.count++;
          if (!rec.first) rec.first = {sido, fullName: sig};
        }
      }

      for (const [sido, arr] of state.idx.sigunguBySido.entries()){
        arr.sort((a,b)=>a.name.localeCompare(b.name,"ko"));
      }

      // suffix가 전국에서 유일하면 맵에 넣음
      for (const [suffix, rec] of suffixTemp.entries()){
        if (rec.count === 1 && rec.first){
          state.idx.sigunguSuffixUnique.set(suffix, rec.first);
        }
      }
    }

    async function ensureDongForSido(sido){
      sido = normalizeSidoName(sido);
      if (!sido) return;
      if (state.geo.dongBySido.has(sido)) return;

      const filename = BOUNDARY_URLS.dongFilePrefix + encodeURIComponent(sido) + BOUNDARY_URLS.dongFileSuffix;
      const urls = [
        BOUNDARY_URLS.dongBaseRaw + filename,
        BOUNDARY_URLS.dongBaseJsdelivr + filename
      ];

      const geo = await fetchJsonWithFallback(urls);
      state.geo.dongBySido.set(sido, geo);

      // build dong index for that sido (핵심 수정: sigungu는 tokens[1..-2] join)
      const feats = geo?.features || [];
      for (const f of feats){
        const p = f.properties || {};
        const full = getProp(p, ["adm_nm","ADM_NM","name","full_name","admName"]);
        if (!full) continue;

        const sp = full.split(" ").filter(Boolean);
        // 보통: [시도, 시군구(1~n토큰), 동]
        if (sp.length < 3) continue;

        const sigungu = sp.slice(1, sp.length - 1).join(" ");
        const dong = sp[sp.length - 1];

        if (!sigungu || !dong) continue;

        const key = `${sido}||${sigungu}`;
        if (!state.idx.dongBySidoSigungu.has(key)) state.idx.dongBySidoSigungu.set(key, []);
        state.idx.dongBySidoSigungu.get(key).push({ dong, feature: f });
      }

      // sort for all sigungu in this sido
      for (const [k, arr] of state.idx.dongBySidoSigungu.entries()){
        if (k.startsWith(sido + "||")) arr.sort((a,b)=>a.dong.localeCompare(b.dong,"ko"));
      }
    }

    function canonicalizeSigunguIfPossible(sido, sigunguRaw){
      sido = normalizeSidoName(sido);
      sigunguRaw = safeText(sigunguRaw);
      if (!sido || !sigunguRaw) return sigunguRaw;

      const list = state.idx.sigunguBySido.get(sido) || [];
      if (!list.length) return sigunguRaw;

      // exact match
      const exact = list.find(x => normalizeKey(x.name) === normalizeKey(sigunguRaw));
      if (exact) return exact.name;

      // endsWith match (입력이 "분당구"인데 실제는 "성남시 분당구" 같은 경우)
      const cand = list.filter(x => x.name.endsWith(sigunguRaw));
      if (cand.length === 1) return cand[0].name;

      // reverse contains (입력이 길고 실제가 짧을 때)
      const cand2 = list.filter(x => sigunguRaw.endsWith(x.name));
      if (cand2.length === 1) return cand2[0].name;

      return sigunguRaw;
    }

    function inferAndNormalizeRecords(){
      // 1) sido가 없으면 sigungu로 추론
      for (const r of state.records){
        if (r.sido || !r.sigungu) continue;

        // exact match
        const set = state.idx.sigunguToSido.get(r.sigungu);
        if (set && set.size === 1){
          r.sido = normalizeSidoName([...set][0]);
          continue;
        }

        // suffix unique match (예: "분당구" -> "성남시 분당구", 경기도)
        const suf = state.idx.sigunguSuffixUnique.get(r.sigungu);
        if (suf){
          r.sido = normalizeSidoName(suf.sido);
          r.sigungu = suf.fullName; // sigungu까지 보정
          continue;
        }
      }

      // 2) sido가 생겼으면 해당 sido 기준으로 sigungu canonicalize
      for (const r of state.records){
        if (!r.sido || !r.sigungu) continue;
        r.sido = normalizeSidoName(r.sido);
        r.sigungu = canonicalizeSigunguIfPossible(r.sido, r.sigungu);
      }
    }

    /********************
     * Data Parsing (핵심 버그 수정)
     ********************/
    function parseLines(text){
      // IMPORTANT: 먼저 줄 단위 split -> 라인별 정규화 (이게 안 되면 데이터가 "안 들어간 것처럼" 보임)
      const lines = safeText(text).split(/\r?\n/).map(x => normalizeSpaceOne(x)).filter(Boolean);

      const out = [];
      for (const rawLine of lines){
        const line = normalizeSpaceOne(rawLine);
        if (!line) continue;

        const parts = line.split(" ").filter(Boolean);
        if (!parts.length) continue;

        let i = 0;
        let sido = "";
        let sigungu = "";
        let dong = "";
        let vendor = "";

        // 1) sido
        if (parts[0] && isSidoToken(parts[0])){
          sido = normalizeSidoName(parts[0]);
          i = 1;
        }

        // 2) sigungu (1~2 tokens)
        if (i < parts.length){
          const t1 = parts[i];
          const t2 = parts[i+1];
          if (t2 && isSigunguStartTwoTokens(t1, t2)){
            sigungu = `${t1} ${t2}`;
            i += 2;
          } else {
            sigungu = t1;
            i += 1;
          }
        }

        // 3) dong (1 token) - 동/읍/면/리
        if (i < parts.length && isDongToken(parts[i])){
          dong = parts[i];
          i += 1;
        } else if (i < parts.length){
          // dong 토큰이 명확히 동/읍/면/리로 끝나지 않더라도,
          // 데이터 형태상 다음 토큰을 dong으로 보는 편이 안정적(예: "검사동"은 ok)
          dong = parts[i] || "";
          i += 1;
        }

        // 4) vendor = 나머지 전부 합침(중요: 씨제이대한통운 서울장지 같은 케이스)
        if (i < parts.length){
          vendor = parts.slice(i).join(" ").trim();
        }
        if (!vendor) vendor = "미지정";

        out.push({
          sido: normalizeSidoName(sido),
          sigungu: safeText(sigungu),
          dong: safeText(dong),
          vendor: safeText(vendor),
          raw: line
        });
      }

      return out;
    }

    /********************
     * Aggregations
     ********************/
    function filteredRecords(){
      const sel = state.selection;
      const vf = state.vendorFilter;

      return state.records.filter(r => {
        if (vf && r.vendor !== vf) return false;
        if (sel.sido && normalizeSidoName(r.sido) !== normalizeSidoName(sel.sido)) return false;
        if (sel.sigungu && r.sigungu !== sel.sigungu) return false;
        if (sel.dong && r.dong !== sel.dong) return false;
        return true;
      });
    }

    function countByKey(records, keyFn){
      const m = new Map();
      for (const r of records){
        const k = keyFn(r);
        if (!k) continue;
        m.set(k, (m.get(k)||0) + 1);
      }
      return m;
    }

    /********************
     * Map Drawing
     ********************/
    function clearMapLayer(){
      for (const p of state.layer.polygons) p.setMap(null);
      for (const o of state.layer.overlays) o.setMap(null);
      state.layer.polygons = [];
      state.layer.overlays = [];
      state.layer.currentType = "";
    }

    function polygonStyle(base={}){
      const root = getComputedStyle(document.documentElement);
      const w = parseInt(root.getPropertyValue("--poly-stroke-weight")) || 3;
      const stroke = root.getPropertyValue("--poly-stroke").trim() || "#2563eb";
      return Object.assign({
        strokeWeight: w,
        strokeColor: stroke,
        strokeOpacity: 0.92,
        fillColor: stroke,
        fillOpacity: 0.14,
      }, base);
    }

    function drawFeatures(forceType){
      clearMapLayer();

      const sel = state.selection;
      const lv = map.getLevel();
      const recs = filteredRecords();

      let showType = "sido";
      if (!sel.sido){
        showType = "sido";
      } else {
        showType = "sigungu";
        if (sel.sigungu && lv <= ZOOM.SHOW_DONG_AT_OR_BELOW){
          showType = "dong";
        }
      }
      if (forceType) showType = forceType;
      state.layer.currentType = showType;

      if (showType === "sido"){
        const feats = state.geo.sido?.features || [];
        const cntMap = countByKey(recs, r => normalizeSidoName(r.sido));
        drawGeoFeatures(feats, {
          getName: (f)=> normalizeSidoName(featureNameKOR(f)),
          getCount: (nm)=> cntMap.get(nm)||0,
          onClick: (nm, f)=> selectSido(nm, f),
        });

      } else if (showType === "sigungu"){
        const feats = (state.geo.sigungu?.features || []).filter(f => {
          const nm = featureNameKOR(f);
          if (!nm) return false;

          let sido = "";
          const cd = featureCode(f);
          if (cd && cd.length>=2) sido = state.idx.sidoByCodePrefix.get(cd.slice(0,2)) || "";
          if (!sido){
            sido = normalizeSidoName(getProp(f.properties||{}, ["province","CTPRVN_NM","CTP_KOR_NM","sido"]));
          }
          if (!sido){
            const full = getProp(f.properties||{}, ["adm_nm","name"]);
            if (full.includes(" ")) sido = normalizeSidoName(full.split(" ")[0]);
          }
          return normalizeSidoName(sido) === normalizeSidoName(sel.sido);
        });

        const cntMap = countByKey(recs, r => r.sigungu);
        drawGeoFeatures(feats, {
          getName: (f)=> featureNameKOR(f),
          getCount: (nm)=> cntMap.get(nm)||0,
          onClick: (nm, f)=> selectSigungu(nm, f),
        });

      } else if (showType === "dong"){
        const key = `${sel.sido}||${sel.sigungu}`;
        const list = state.idx.dongBySidoSigungu.get(key) || [];
        const feats = list.map(x => x.feature);

        const cntMap = countByKey(recs, r => r.dong);
        drawGeoFeatures(feats, {
          getName: (f)=> {
            const p = f.properties||{};
            const full = getProp(p, ["adm_nm","name"]);
            if (full.includes(" ")){
              const sp = full.split(" ").filter(Boolean);
              return sp[sp.length-1];
            }
            return getProp(p, ["EMD_KOR_NM","emd_nm","dong"]) || featureNameKOR(f);
          },
          getCount: (nm)=> cntMap.get(nm)||0,
          onClick: (nm, f)=> selectDong(nm, f),
          overlayLimit: 80
        });
      }
    }

    function drawGeoFeatures(features, opt){
      const getName = opt.getName;
      const getCount = opt.getCount;
      const onClick = opt.onClick;
      const overlayLimit = opt.overlayLimit ?? 50;

      const items = [];
      for (const f of features){
        const nm = safeText(getName(f));
        if (!nm) continue;
        const ct = getCount(nm) || 0;
        items.push({ nm, ct, f });
      }

      const topForOverlay = [...items].sort((a,b)=>b.ct-a.ct).slice(0, overlayLimit);

      for (const it of items){
        const pathsList = geometryToPolygonPaths(it.f.geometry);
        for (const rings of pathsList){
          const poly = new kakao.maps.Polygon({
            path: rings,
            ...polygonStyle({
              fillOpacity: it.ct > 0 ? 0.16 : 0.07
            })
          });

          kakao.maps.event.addListener(poly, "mouseover", ()=> {
            poly.setOptions(polygonStyle({ fillOpacity: 0.20 }));
          });
          kakao.maps.event.addListener(poly, "mouseout", ()=> {
            poly.setOptions(polygonStyle({ fillOpacity: it.ct > 0 ? 0.16 : 0.07 }));
          });
          kakao.maps.event.addListener(poly, "click", ()=> onClick(it.nm, it.f));

          poly.setMap(map);
          state.layer.polygons.push(poly);
        }
      }

      for (const it of topForOverlay){
        if (!it.ct) continue;
        const pathsList = geometryToPolygonPaths(it.f.geometry);
        if (!pathsList.length) continue;
        const b = boundsFromPolygonPaths(pathsList);
        const center = centerFromBounds(b);
        if (!center) continue;

        const div = document.createElement("div");
        div.className = "ov";
        div.textContent = `${it.nm} ${it.ct}`;
        div.onclick = () => onClick(it.nm, it.f);

        const ov = new kakao.maps.CustomOverlay({
          position: center,
          content: div,
          yAnchor: 1,
        });
        ov.setMap(map);
        state.layer.overlays.push(ov);
      }
    }

    function fitFeature(f){
      const pathsList = geometryToPolygonPaths(f.geometry);
      if (!pathsList.length) return;
      const b = boundsFromPolygonPaths(pathsList);
      map.setBounds(b);
    }

    /********************
     * Selection Control
     ********************/
    async function selectSido(sido, feature){
      state.selection = { sido: normalizeSidoName(sido), sigungu:"", dong:"" };
      state.lastQuery = "";
      el.q.value = "";

      if (feature) fitFeature(feature);

      if (map.getLevel() < ZOOM.SHOW_SIGUNGU_AT_OR_ABOVE) {
        map.setLevel(ZOOM.SHOW_SIGUNGU_AT_OR_ABOVE);
      }

      refreshUI();
      drawFeatures();
    }

    async function selectSigungu(sigungu, feature){
      state.selection.sigungu = sigungu;
      state.selection.dong = "";
      state.lastQuery = "";
      el.q.value = "";

      await ensureDongForSido(state.selection.sido);

      if (feature) fitFeature(feature);

      if (map.getLevel() > ZOOM.SHOW_DONG_AT_OR_BELOW + 1) {
        map.setLevel(ZOOM.SHOW_DONG_AT_OR_BELOW + 1);
      }

      refreshUI();
      drawFeatures();
    }

    function selectDong(dong, feature){
      state.selection.dong = dong;
      state.lastQuery = "";
      el.q.value = "";

      if (feature) fitFeature(feature);

      if (map.getLevel() > ZOOM.SHOW_DONG_AT_OR_BELOW) {
        map.setLevel(ZOOM.SHOW_DONG_AT_OR_BELOW);
      }

      refreshUI();
      drawFeatures();
    }

    function resetSelection(){
      state.selection = { sido:"", sigungu:"", dong:"" };
      state.vendorFilter = "";
      state.lastQuery = "";
      el.q.value = "";
      map.setLevel(13);
      map.setCenter(new kakao.maps.LatLng(36.35, 127.85));
      refreshUI();
      drawFeatures("sido");
    }

    function stepUp(){
      if (state.selection.dong){
        state.selection.dong = "";
      } else if (state.selection.sigungu){
        state.selection.sigungu = "";
      } else if (state.selection.sido){
        state.selection.sido = "";
      }
      refreshUI();
      drawFeatures();
    }

    /********************
     * Search
     ********************/
    function applySearch(){
      const q = normalizeSpaceOne(el.q.value);
      state.lastQuery = q;

      if (!q){
        refreshUI();
        drawFeatures();
        return;
      }

      const tokens = q.split(/[\/\s]+/).filter(Boolean).map(t => t.trim());
      if (!tokens.length){
        refreshUI();
        drawFeatures();
        return;
      }

      const vendors = [...new Set(state.records.map(r => r.vendor))].filter(v => v && v !== "미지정");
      let vendorHit = "";
      for (const t of tokens){
        const hit = vendors.find(v => normalizeKey(v) === normalizeKey(t));
        if (hit){ vendorHit = hit; break; }
      }
      if (vendorHit) state.vendorFilter = vendorHit;

      let hitSido = "";
      for (const t of tokens){
        const ns = normalizeKey(normalizeSidoName(t));
        const exact = state.idx.sidoNames.find(s => normalizeKey(s) === ns);
        if (exact){ hitSido = exact; break; }
      }

      let hitSigungu = "";
      if (hitSido){
        const list = state.idx.sigunguBySido.get(hitSido) || [];
        for (const t of tokens){
          const exact = list.find(x => normalizeKey(x.name) === normalizeKey(t) || x.name.endsWith(t));
          if (exact){ hitSigungu = exact.name; break; }
        }
      } else {
        for (const t of tokens){
          if (!/(구|군|시)$/.test(t)) continue;

          const set = state.idx.sigunguToSido.get(t);
          if (set && set.size === 1){
            hitSido = [...set][0];
            hitSigungu = canonicalizeSigunguIfPossible(hitSido, t);
            break;
          }

          const suf = state.idx.sigunguSuffixUnique.get(t);
          if (suf){
            hitSido = suf.sido;
            hitSigungu = suf.fullName;
            break;
          }
        }
      }

      let hitDong = "";
      if (hitSido && hitSigungu){
        const key = `${normalizeSidoName(hitSido)}||${hitSigungu}`;
        const list = state.idx.dongBySidoSigungu.get(key) || [];
        for (const t of tokens){
          if (!/(동|읍|면)$/.test(t)) continue;
          const exact = list.find(x => normalizeKey(x.dong) === normalizeKey(t));
          if (exact){ hitDong = exact.dong; break; }
        }
      }

      if (hitSido){
        state.selection.sido = normalizeSidoName(hitSido);
        state.selection.sigungu = "";
        state.selection.dong = "";
      }
      if (hitSigungu){
        state.selection.sigungu = hitSigungu;
        state.selection.dong = "";
      }
      if (hitDong){
        state.selection.dong = hitDong;
      }

      refreshUI();

      (async ()=>{
        if (state.selection.sido && state.selection.sigungu){
          await ensureDongForSido(state.selection.sido);
        }
        tryAutoFitBySelection();
        drawFeatures();
      })();
    }

    function tryAutoFitBySelection(){
      const sel = state.selection;
      if (!sel.sido) return;

      const sFeat = (state.geo.sido?.features || []).find(f => normalizeKey(normalizeSidoName(featureNameKOR(f))) === normalizeKey(sel.sido));
      if (sFeat) fitFeature(sFeat);

      if (!sel.sigungu) return;

      const sigFeat = (state.geo.sigungu?.features || []).find(f => {
        const nm = featureNameKOR(f);
        if (normalizeKey(nm) !== normalizeKey(sel.sigungu)) return false;

        let sido = "";
        const cd = featureCode(f);
        if (cd && cd.length>=2) sido = state.idx.sidoByCodePrefix.get(cd.slice(0,2)) || "";
        if (!sido){
          sido = normalizeSidoName(getProp(f.properties||{}, ["province","CTPRVN_NM","CTP_KOR_NM","sido"]));
        }
        if (!sido){
          const full = getProp(f.properties||{}, ["adm_nm","name"]);
          if (full.includes(" ")) sido = normalizeSidoName(full.split(" ")[0]);
        }
        return normalizeKey(normalizeSidoName(sido)) === normalizeKey(sel.sido);
      });
      if (sigFeat) fitFeature(sigFeat);
    }

    /********************
     * UI Render
     ********************/
    function refreshUI(){
      const recsAll = state.records;
      const recs = filteredRecords();

      el.badgeCount.textContent = `데이터: ${recsAll.length}건`;

      const uniq = new Set(recsAll.map(r => `${r.vendor}||${normalizeSidoName(r.sido)}||${r.sigungu}||${r.dong}`));
      el.badgeUnique.textContent = `유니크: ${uniq.size}`;

      const sel = state.selection;
      const scope = sel.dong ? `${sel.sido} / ${sel.sigungu} / ${sel.dong}`
                  : sel.sigungu ? `${sel.sido} / ${sel.sigungu}`
                  : sel.sido ? `${sel.sido}`
                  : "전체";
      el.badgeSel.textContent = scope;
      el.kvScope.textContent = scope;
      el.kvVendor.textContent = state.vendorFilter || "전체";

      const uniqFiltered = new Set(recs.map(r => `${r.vendor}||${normalizeSidoName(r.sido)}||${r.sigungu}||${r.dong}`));
      el.kvUnique.textContent = `${uniqFiltered.size}`;

      renderPathChips();
      renderVendorChips();
      renderList();
      renderVendorDist(recs);
      renderTopDong(recs);
    }

    function renderPathChips(){
      const sel = state.selection;
      el.pathChips.innerHTML = "";

      const addChip = (label, active, onClick) => {
        const c = document.createElement("div");
        c.className = "chip" + (active ? " active" : "");
        c.textContent = label;
        c.onclick = onClick;
        el.pathChips.appendChild(c);
      };

      addChip("전체", !sel.sido && !sel.sigungu && !sel.dong, () => resetSelection());
      if (sel.sido) addChip(sel.sido, true, ()=> { state.selection = {sido:sel.sido, sigungu:"", dong:""}; refreshUI(); drawFeatures(); });
      if (sel.sigungu) addChip(sel.sigungu, true, ()=> { state.selection = {sido:sel.sido, sigungu:sel.sigungu, dong:""}; refreshUI(); drawFeatures(); });
      if (sel.dong) addChip(sel.dong, true, ()=> { refreshUI(); drawFeatures(); });

      if (sel.sido) addChip("← 한 단계 위", false, ()=> stepUp());
    }

    function renderVendorChips(){
      el.vendorChips.innerHTML = "";

      const recs = state.records;
      const vendors = [...new Set(recs.map(r => r.vendor))].filter(Boolean).sort((a,b)=>a.localeCompare(b,"ko"));

      const add = (label, active, count, onClick) => {
        const c = document.createElement("div");
        c.className = "chip" + (active ? " active" : "");
        c.innerHTML = `${label} <span class="mini">${count}</span>`;
        c.onclick = onClick;
        el.vendorChips.appendChild(c);
      };

      add("전체 업체", state.vendorFilter === "", recs.length, ()=>{
        state.vendorFilter = "";
        refreshUI(); drawFeatures();
      });

      for (const v of vendors){
        const ct = recs.filter(r => r.vendor === v).length;
        add(v, state.vendorFilter === v, ct, ()=>{
          state.vendorFilter = (state.vendorFilter === v) ? "" : v;
          refreshUI(); drawFeatures();
        });
      }
    }

    function renderList(){
      const sel = state.selection;
      const recs = filteredRecords();
      el.list.innerHTML = "";

      let title = "시/도";
      let rows = [];

      if (!sel.sido){
        title = "시/도";
        const m = countByKey(recs, r => normalizeSidoName(r.sido));
        rows = [...m.entries()].map(([nm, ct]) => ({ nm, ct, type:"sido" }))
          .sort((a,b)=>b.ct-a.ct || a.nm.localeCompare(b.nm,"ko"));

      } else if (!sel.sigungu){
        title = "시/군/구";
        const m = countByKey(recs, r => r.sigungu);
        rows = [...m.entries()].map(([nm, ct]) => ({ nm, ct, type:"sigungu" }))
          .sort((a,b)=>b.ct-a.ct || a.nm.localeCompare(b.nm,"ko"));

      } else {
        title = "동/읍/면";
        const m = countByKey(recs, r => r.dong);
        rows = [...m.entries()].map(([nm, ct]) => ({ nm, ct, type:"dong" }))
          .sort((a,b)=>b.ct-a.ct || a.nm.localeCompare(b.nm,"ko"));
      }

      el.listTitle.textContent = title;

      if (!rows.length){
        const empty = document.createElement("div");
        empty.className = "item";
        empty.style.cursor = "default";
        empty.innerHTML = `<div class="nm" style="color:#64748b;font-weight:900;">데이터가 없습니다.</div><div class="ct">0</div>`;
        el.list.appendChild(empty);
        return;
      }

      for (const r of rows){
        const it = document.createElement("div");
        it.className = "item";
        it.innerHTML = `<div class="nm">${r.nm || "(미상)"}</div><div class="ct">${r.ct}</div>`;
        it.onclick = async () => {
          if (r.type === "sido"){
            const f = (state.geo.sido?.features||[]).find(x => normalizeKey(normalizeSidoName(featureNameKOR(x))) === normalizeKey(normalizeSidoName(r.nm)));
            await selectSido(r.nm, f);
          } else if (r.type === "sigungu"){
            const f = (state.geo.sigungu?.features||[]).find(x => normalizeKey(featureNameKOR(x)) === normalizeKey(r.nm));
            await selectSigungu(r.nm, f);
          } else {
            state.selection.dong = r.nm;
            refreshUI(); drawFeatures();
          }
        };
        el.list.appendChild(it);
      }
    }

    function renderVendorDist(recs){
      const m = countByKey(recs, r => r.vendor);
      const rows = [...m.entries()].sort((a,b)=>b[1]-a[1]).slice(0, 12);
      el.vendorDist.innerHTML = rows.length
        ? rows.map(([v,c]) => `- ${v}: <b>${c}</b>`).join("<br/>")
        : "표시할 데이터가 없습니다.";
    }

    function renderTopDong(recs){
      const m = countByKey(recs, r => r.dong);
      const rows = [...m.entries()].filter(x=>x[0]).sort((a,b)=>b[1]-a[1]).slice(0, 12);
      el.topDong.innerHTML = rows.length
        ? rows.map(([d,c]) => `- ${d}: <b>${c}</b>`).join("<br/>")
        : "표시할 데이터가 없습니다.";
    }

    /********************
     * Actions / Storage
     ********************/
    function saveRecords(){
      localStorage.setItem(LS.RECORDS, JSON.stringify(state.records));
      localStorage.setItem(LS.LAST_TEXT, el.ta.value);
    }

    function loadRecords(){
      let loaded = false;
      try{
        const raw = localStorage.getItem(LS.RECORDS);
        if (raw){
          const arr = JSON.parse(raw) || [];
          if (Array.isArray(arr) && arr.length){
            state.records = arr;
            loaded = true;
          }
        }
      }catch(e){
        state.records = [];
      }

      const last = localStorage.getItem(LS.LAST_TEXT);
      if (last) el.ta.value = last;

      // 저장된 데이터가 없으면: 요청 데이터 기본 주입 + 자동 적용
      if (!loaded){
        el.ta.value = DEFAULT_DATA;
      }

      return loaded;
    }

    function applyTextarea(){
      const text = el.ta.value || "";
      const parsed = parseLines(text);

      // 중요: 중복도 데이터로 유지 (동일 라인 2개면 2건)
      state.records = parsed;

      inferAndNormalizeRecords();
      saveRecords();

      refreshUI();
      drawFeatures();
    }

    function loadSample(){
      el.ta.value = DEFAULT_DATA;
      applyTextarea();
    }

    function exportUnique(){
      const uniq = new Set(state.records.map(r => `${normalizeSidoName(r.sido)} ${r.sigungu} ${r.dong} | ${r.vendor}`.trim()));
      const text = [...uniq].sort((a,b)=>a.localeCompare(b,"ko")).join("\n");
      copyToClipboard(text).then(()=>{
        alert("유니크 목록을 클립보드에 복사했습니다.");
      }).catch(()=>{
        prompt("복사 실패. 아래 내용을 수동 복사하세요.", text);
      });
    }

    function copySummary(){
      const sel = state.selection;
      const scope = sel.dong ? `${sel.sido} / ${sel.sigungu} / ${sel.dong}`
                  : sel.sigungu ? `${sel.sido} / ${sel.sigungu}`
                  : sel.sido ? `${sel.sido}`
                  : "전체";

      const recs = filteredRecords();
      const mVendor = countByKey(recs, r => r.vendor);
      const vendors = [...mVendor.entries()].sort((a,b)=>b[1]-a[1]).map(([v,c])=>`${v}:${c}`).join(", ");

      const mDong = countByKey(recs, r => r.dong);
      const topDong = [...mDong.entries()].filter(x=>x[0]).sort((a,b)=>b[1]-a[1]).slice(0, 8).map(([d,c])=>`${d}:${c}`).join(", ");

      const text =
`[CoupangLand 요약]
- 범위: ${scope}
- 업체필터: ${state.vendorFilter || "전체"}
- 데이터건수(필터후): ${recs.length}
- 업체분포: ${vendors || "(없음)"}
- 상위 동: ${topDong || "(없음)"}`;

      copyToClipboard(text).then(()=>{
        alert("현재 화면 요약을 클립보드에 복사했습니다.");
      }).catch(()=>{
        prompt("복사 실패. 아래 내용을 수동 복사하세요.", text);
      });
    }

    function hardReset(){
      if (!confirm("저장된 데이터를 모두 초기화할까요? (localStorage 삭제)")) return;
      localStorage.removeItem(LS.RECORDS);
      localStorage.removeItem(LS.LAST_TEXT);
      state.records = [];
      el.ta.value = DEFAULT_DATA;
      applyTextarea();
      resetSelection();
    }

    /********************
     * Init
     ********************/
    async function init(){
      map = new kakao.maps.Map(document.getElementById("map"), {
        center: new kakao.maps.LatLng(36.35, 127.85),
        level: 13
      });

      await ensureBoundaries();

      const hasStored = loadRecords();
      inferAndNormalizeRecords();

      // 저장 데이터 없었으면(첫 실행) 자동 적용해서 "데이터가 안 들어가" 체감 제거
      if (!hasStored){
        applyTextarea();
      }

      refreshUI();
      drawFeatures("sido");

      kakao.maps.event.addListener(map, "zoom_changed", async () => {
        if (state.selection.sido && state.selection.sigungu){
          await ensureDongForSido(state.selection.sido);
        }
        drawFeatures();
      });

      el.btnSearch.onclick = applySearch;
      el.q.addEventListener("keydown", (e)=>{ if (e.key === "Enter") applySearch(); });

      el.btnAll.onclick = resetSelection;
      el.btnCopy.onclick = copySummary;
      el.btnReset.onclick = hardReset;

      el.btnApply.onclick = applyTextarea;
      el.btnSample.onclick = loadSample;
      el.btnExport.onclick = exportUnique;
    }

    init().catch(err => {
      console.error(err);
      alert("초기화 실패: " + (err?.message || err));
    });
  </script>
</body>
</html>
