<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>CoupangLand (프론트 임시 MVP)</title>
  <meta name="description" content="시/도→시군구→동 단위로 대리점/라우트 현황을 폴리곤 기반으로 조회합니다. (백엔드 없음 / localStorage 저장)" />
  <meta name="robots" content="noindex,nofollow" />

  <style>
    :root{
      --bg:#f6f8fb;
      --panel:#ffffff;
      --line:rgba(15,23,42,.10);
      --line2:rgba(15,23,42,.16);
      --text:#0b1220;
      --muted:rgba(15,23,42,.70);
      --muted2:rgba(15,23,42,.55);
      --accent:#6d5cff;
      --accent2:#1388ff;
      --danger:#e11d48;
      --shadow:0 10px 28px rgba(15,23,42,.10);
      --shadow2:0 6px 18px rgba(15,23,42,.08);
      --radius:18px;
      --radius2:14px;
      --btn:#f3f6fc;
      --btnH:#e9eef9;
      --input:#ffffff;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif;
      background:
        radial-gradient(900px 600px at 15% 0%, rgba(109,92,255,.12), transparent 60%),
        radial-gradient(900px 600px at 85% 0%, rgba(19,136,255,.10), transparent 60%),
        var(--bg);
      color:var(--text);
    }
    .wrap{ max-width: 1400px; margin: 0 auto; padding: 18px 18px 26px; }

    .topbar{
      display:flex; align-items:flex-start; justify-content:space-between; gap:16px;
      padding: 14px 16px; border:1px solid var(--line);
      background: rgba(255,255,255,.82); border-radius: var(--radius);
      box-shadow: var(--shadow); backdrop-filter: blur(10px);
    }
    .brand{ display:flex; gap:12px; align-items:flex-start; }
    .dot{
      width:10px; height:10px; border-radius:999px; margin-top:6px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.45) 35%, rgba(255,255,255,0) 70%), var(--accent);
      box-shadow: 0 0 14px rgba(109,92,255,.38);
    }
    .brand h1{
      margin:0; font-size: 18px; letter-spacing: .2px;
      display:flex; gap:10px; align-items:center;
    }
    .pill{
      font-size:12px; color:rgba(15,23,42,.82);
      border:1px solid var(--line2); background: rgba(109,92,255,.10);
      padding: 4px 10px; border-radius: 999px; font-weight: 800;
    }
    .subtitle{ margin-top:6px; color:var(--muted); font-size: 13px; line-height: 1.35; }

    .actions{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; align-items:center; }
    .btn{
      appearance:none; border:1px solid var(--line2); background: var(--btn);
      color:var(--text); padding: 10px 12px; border-radius: 12px;
      cursor:pointer; transition: .15s ease; font-weight: 900; font-size: 13px;
      box-shadow: 0 1px 0 rgba(15,23,42,.05);
    }
    .btn:hover{ transform: translateY(-1px); background: var(--btnH); }
    .btn:active{ transform: translateY(0); }
    .btn.primary{
      border-color: rgba(109,92,255,.45);
      box-shadow: 0 0 0 1px rgba(109,92,255,.12) inset, 0 1px 0 rgba(15,23,42,.05);
      background: linear-gradient(180deg, rgba(109,92,255,.14), rgba(109,92,255,.08));
    }
    .btn.danger{
      border-color: rgba(225,29,72,.40);
      box-shadow: 0 0 0 1px rgba(225,29,72,.10) inset, 0 1px 0 rgba(15,23,42,.05);
      background: linear-gradient(180deg, rgba(225,29,72,.12), rgba(225,29,72,.06));
    }

    .grid{ margin-top: 14px; display:grid; grid-template-columns: 560px 1fr; gap: 14px; align-items: stretch; }
    @media (max-width: 1100px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      border:1px solid var(--line); background: rgba(255,255,255,.86);
      border-radius: var(--radius); box-shadow: var(--shadow);
      overflow:hidden; min-height: 720px;
    }
    .cardHeader{
      display:flex; justify-content:space-between; align-items:center;
      padding: 12px 14px; border-bottom:1px solid var(--line);
      background: rgba(255,255,255,.92);
    }
    .cardHeader h2{ margin:0; font-size: 14px; letter-spacing:.2px; font-weight: 1000; }
    .badge{
      font-size:12px; border:1px solid var(--line2);
      color:rgba(15,23,42,.80); background: rgba(255,255,255,.70);
      padding: 6px 10px; border-radius: 999px; font-weight: 900;
    }
    .cardBody{ padding: 12px 14px 14px; }

    .row{ display:flex; gap:10px; align-items:center; }
    .row + .row{ margin-top: 10px; }
    .input{
      width:100%; border:1px solid var(--line2); background: var(--input);
      color: var(--text); padding: 11px 12px; border-radius: 12px;
      outline:none; font-size: 13px; box-shadow: 0 1px 0 rgba(15,23,42,.04);
    }
    .input::placeholder{ color: rgba(15,23,42,.45); }
    .miniBtn{
      border:1px solid var(--line2); background: var(--btn);
      color: var(--text); padding: 11px 12px; border-radius: 12px;
      cursor:pointer; font-weight: 1000; min-width: 72px;
      box-shadow: 0 1px 0 rgba(15,23,42,.05);
    }
    .miniBtn:hover{ background: var(--btnH); }

    .chips{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .chip{
      display:inline-flex; gap:8px; align-items:center;
      padding: 7px 10px; border-radius: 999px;
      background: #f2f5fb; border:1px solid var(--line2);
      color: rgba(15,23,42,.92); font-size: 12px;
      cursor:pointer; user-select:none;
      box-shadow: 0 1px 0 rgba(15,23,42,.04);
    }
    .chip strong{ font-weight: 1000; font-size: 12px; }
    .chip.active{
      border-color: rgba(109,92,255,.55);
      background: rgba(109,92,255,.12);
      box-shadow: 0 0 0 1px rgba(109,92,255,.12) inset, 0 1px 0 rgba(15,23,42,.04);
    }
    .chip .count{
      font-size: 11px; color: rgba(15,23,42,.72);
      border:1px solid rgba(15,23,42,.16);
      padding: 2px 7px; border-radius: 999px;
      background: rgba(255,255,255,.70);
      font-weight: 900;
    }

    .mapWrap{
      margin-top: 10px; border-radius: var(--radius2);
      border:1px solid var(--line); overflow:hidden;
      background: rgba(255,255,255,.70);
      height: 560px; position:relative; box-shadow: var(--shadow2);
    }
    @media (max-width: 600px){ .mapWrap{ height: 470px; } }
    #map{ width:100%; height:100%; }
    .mapHint{
      position:absolute; left:12px; right:12px; bottom:12px;
      padding: 10px 10px; border-radius: 12px;
      border:1px solid rgba(15,23,42,.16);
      background: rgba(255,255,255,.86);
      color: rgba(15,23,42,.78);
      font-size: 12px; line-height: 1.35;
      backdrop-filter: blur(8px);
      pointer-events:none; box-shadow: var(--shadow2);
    }
    .mapHint b{ color: rgba(15,23,42,.92); }

    .sectionTitle{ margin: 12px 0 8px; font-size: 13px; font-weight: 1000; letter-spacing: .2px; }
    .list{
      border:1px solid var(--line); border-radius: var(--radius2);
      background: rgba(255,255,255,.72); overflow:hidden;
      box-shadow: 0 1px 0 rgba(15,23,42,.03);
    }
    .listItem{
      display:flex; justify-content:space-between; align-items:center;
      padding: 10px 12px; border-top: 1px solid rgba(15,23,42,.06);
      cursor:pointer; user-select:none;
    }
    .listItem:first-child{ border-top:0; }
    .listItem:hover{ background: rgba(109,92,255,.06); }
    .liLeft{ display:flex; gap:10px; align-items:center; min-width:0; }
    .liName{ font-weight: 1000; font-size: 13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .liSub{ font-size: 12px; color: var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .liRight{ display:flex; gap:8px; align-items:center; flex-shrink:0; }
    .pillCount{
      font-size: 11px; border:1px solid rgba(15,23,42,.16);
      padding: 3px 8px; border-radius: 999px;
      color: rgba(15,23,42,.78);
      background: rgba(255,255,255,.78);
      font-weight: 900;
    }

    textarea{
      width:100%; min-height: 130px; resize: vertical;
      border:1px solid var(--line2); background: rgba(255,255,255,.92);
      color: var(--text); padding: 10px 12px; border-radius: 12px;
      outline:none; font-size: 13px; line-height: 1.4;
      box-shadow: 0 1px 0 rgba(15,23,42,.04);
    }
    .muted{ color: var(--muted2); font-size: 12px; line-height: 1.35; }
    .tiny{ margin-top: 8px; color: rgba(15,23,42,.62); font-size: 11px; line-height: 1.35; }

    .detailEmpty{
      border:1px dashed rgba(15,23,42,.22);
      border-radius: var(--radius2);
      padding: 14px; background: rgba(255,255,255,.70);
      color: rgba(15,23,42,.72); font-size: 13px;
    }
    .kv{ display:grid; grid-template-columns: 130px 1fr; gap:10px; padding: 10px 12px; border-top:1px solid rgba(15,23,42,.06); }
    .kv:first-child{ border-top:0; }
    .k{ color: rgba(15,23,42,.70); font-size: 12px; font-weight: 1000; }
    .v{ font-size: 12px; color: rgba(15,23,42,.92); word-break: break-word; font-weight: 800; }
    .divider{ height:1px; background: rgba(15,23,42,.08); margin: 12px 0; }

    .regionLabel{
      padding: 5px 10px; border-radius: 999px;
      border:1px solid rgba(15,23,42,.18);
      background: rgba(255,255,255,.90);
      color: rgba(15,23,42,.92);
      font-size: 12px; font-weight: 1000;
      box-shadow: var(--shadow2);
      backdrop-filter: blur(6px);
      white-space:nowrap;
    }
    .regionLabel small{
      font-weight: 1000;
      color: rgba(19,136,255,.95);
      margin-left:6px;
    }

    .toast{
      position: fixed; left: 50%; bottom: 18px;
      transform: translateX(-50%);
      background: rgba(255,255,255,.92);
      border:1px solid rgba(15,23,42,.16);
      color: rgba(15,23,42,.92);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      box-shadow: var(--shadow);
      opacity:0; pointer-events:none;
      transition: .2s ease;
      z-index: 9999;
      font-weight: 900;
    }
    .toast.show{ opacity:1; }
  </style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="dot"></div>
      <div>
        <h1>CoupangLand <span class="pill">프론트 임시 MVP</span></h1>
        <div class="subtitle">
          시/도 지도 기반 → 시/군/구 → 동 단위로 대리점/라우트 현황을 드릴다운 조회합니다. (백엔드 없음 / localStorage 저장)
        </div>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="btnResetView" type="button">전체 보기</button>
      <button class="btn" id="btnCopySummary" type="button">현재 화면 요약 복사</button>
      <button class="btn danger" id="btnClearAll" type="button">데이터 초기화</button>
    </div>
  </div>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="cardHeader">
        <h2>지도 기반 조회</h2>
        <span class="badge" id="badgeData">데이터: 0건</span>
      </div>
      <div class="cardBody">
        <div class="row">
          <input class="input" id="q" placeholder="검색: 예) 영등포구 / 대림동 / 용인시 수지구 / 투네스트 / 대구광역시" />
          <button class="miniBtn" id="btnSearch" type="button">검색</button>
        </div>

        <div class="chips" id="chipsScope"></div>
        <div class="chips" id="chipsVendors"></div>

        <div class="mapWrap">
          <div id="map"></div>
          <div class="mapHint" id="mapHint">
            <b>표시 기준</b>: 시/도 선택 시 기본은 <b>시군구(구)</b>입니다. 시군구 선택 후, 충분히 확대(줌)하면 <b>동</b>을 자동으로 보여줍니다.<br/>
            업체 필터(마루웰/투네스트 등)로 조회 범위를 좁힐 수 있습니다.
          </div>
        </div>

        <div class="sectionTitle" id="listTitle">목록</div>
        <div class="list" id="listBox"></div>

        <div class="divider"></div>

        <div class="sectionTitle">데이터 입력/수정 (관리용)</div>
        <textarea id="raw" spellcheck="false" placeholder="예)
대구광역시 중구 칠성동 | 마루웰
서울특별시 영등포구 대림동 | 마루웰
서울특별시 강서구 염창동 | 투네스트

- 구/동만 들어오면(예: '영등포구 대림동') 가능한 범위에서 자동 추정합니다.
- 같은 라인이 여러 번 있어도 유니크로 정리됩니다."></textarea>

        <div class="row">
          <button class="btn primary" id="btnApply" type="button">파싱/적용</button>
          <button class="btn" id="btnSample" type="button">샘플 로드</button>
          <button class="btn" id="btnExport" type="button">유니크 목록 내보내기</button>
        </div>

        <div class="tiny" id="statsLine">-</div>
        <div class="tiny">
          경계 데이터 소스: southkorea/southkorea-maps(시/도·시군구), raqoon886/Local_HangJeongDong(동/행정동).
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="cardHeader">
        <h2>현재 선택 상세</h2>
        <span class="badge" id="badgeSel">-</span>
      </div>
      <div class="cardBody">
        <div class="detailEmpty" id="detailBox">
          선택된 조건에 데이터가 없습니다.<br/><br/>
          <div class="muted">
            구현 의도:
            <ul style="margin:8px 0 0 18px; padding:0; color:rgba(15,23,42,.65);">
              <li>시/도 클릭 시: 해당 시/도에 존재하는 업체 집계</li>
              <li>시군구 클릭 시: 해당 시군구 데이터</li>
              <li>동 클릭 시: 해당 동 데이터</li>
              <li><b>줌(스케일)</b>에 따라 시군구/동 표시를 자동 전환</li>
            </ul>
          </div>
        </div>

        <div class="divider"></div>

        <div class="sectionTitle">디버그/메모</div>
        <div class="muted" id="debugNote" style="white-space:pre-wrap;">
- 동(행정동) 경계는 용량이 커서 “선택된 시/도만” 로드합니다.
- 시군구까지 선택한 상태에서 충분히 확대하면(줌) 동 레이어로 전환됩니다.
- '대구' 같은 케이스(도시명인데 글자 끝이 '구') 오인 문제를 보정했습니다.
        </div>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<!-- topojson-client -->
<script src="https://unpkg.com/topojson-client@3/dist/topojson-client.min.js"></script>

<!-- Kakao 지도 SDK -->
<script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3"></script>

<script>
(function(){
  "use strict";

  /*********************
   * CONFIG
   *********************/
  // 카카오지도 레벨: 숫자가 작을수록 더 확대(가까움)
  // 시군구 선택 후, 이 레벨 이하로 확대되면 동(행정동) 레이어를 보여줍니다.
  const DONG_ZOOM_THRESHOLD = 6;

  const SOURCES = {
    provincesGeo: "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2012/json/provinces-geo-simple.json",
    municipalitiesTopo: "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2018/json/skorea-municipalities-2018-topo-simple.json",
    hangjeongdongBase: "https://raw.githubusercontent.com/raqoon886/Local_HangJeongDong/master/hangjeongdong_"
  };

  const SIDO_FILE = {
    "서울특별시":"서울특별시",
    "부산광역시":"부산광역시",
    "대구광역시":"대구광역시",
    "인천광역시":"인천광역시",
    "광주광역시":"광주광역시",
    "대전광역시":"대전광역시",
    "울산광역시":"울산광역시",
    "세종특별자치시":"세종특별자치시",
    "경기도":"경기도",
    "강원특별자치도":"강원특별자치도",
    "강원도":"강원도",
    "충청북도":"충청북도",
    "충청남도":"충청남도",
    "전북특별자치도":"전북특별자치도",
    "전라북도":"전라북도",
    "전라남도":"전라남도",
    "경상북도":"경상북도",
    "경상남도":"경상남도",
    "제주특별자치도":"제주특별자치도"
  };

  const SIDO_ALIASES = new Map([
    ["서울","서울특별시"], ["서울시","서울특별시"], ["서울특별시","서울특별시"],
    ["부산","부산광역시"], ["부산시","부산광역시"], ["부산광역시","부산광역시"],
    ["대구","대구광역시"], ["대구시","대구광역시"], ["대구광역시","대구광역시"],
    ["인천","인천광역시"], ["인천시","인천광역시"], ["인천광역시","인천광역시"],
    ["광주","광주광역시"], ["광주시","광주광역시"], ["광주광역시","광주광역시"],
    ["대전","대전광역시"], ["대전시","대전광역시"], ["대전광역시","대전광역시"],
    ["울산","울산광역시"], ["울산시","울산광역시"], ["울산광역시","울산광역시"],
    ["세종","세종특별자치시"], ["세종시","세종특별자치시"], ["세종특별자치시","세종특별자치시"],
    ["경기","경기도"], ["경기도","경기도"],
    ["강원","강원도"], ["강원도","강원도"], ["강원특별자치도","강원특별자치도"],
    ["충북","충청북도"], ["충청북도","충청북도"],
    ["충남","충청남도"], ["충청남도","충청남도"],
    ["전북","전라북도"], ["전라북도","전라북도"], ["전북특별자치도","전북특별자치도"],
    ["전남","전라남도"], ["전라남도","전라남도"],
    ["경북","경상북도"], ["경상북도","경상북도"],
    ["경남","경상남도"], ["경상남도","경상남도"],
    ["제주","제주특별자치도"], ["제주도","제주특별자치도"], ["제주특별자치도","제주특별자치도"]
  ]);

  const DEFAULT_VENDOR = "마루웰";
  const STORAGE_KEY = "coupangland_routes_v1";
  const STORAGE_RAW_KEY = "coupangland_raw_v1";

  /*********************
   * STATE
   *********************/
  const state = {
    level: "SIDO", // SIDO | SIGUNGU | DONG
    sido: null,
    sigungu: null,
    dong: null,
    vendor: null,

    entries: [],
    uniqueKeys: new Set(),

    map: null,
    polygons: [],
    overlays: [],

    provincesGeo: null,
    municipalitiesTopo: null,
    municipalitiesGeo: null,
    sigunguToSido: new Map(),
    dongGeoBySido: new Map(),

    // map rerender control
    lastRenderedLayerKey: "",
    zoomTimer: null,
    isRenderingMap: false
  };

  /*********************
   * DOM
   *********************/
  const el = {
    badgeData: document.getElementById("badgeData"),
    chipsScope: document.getElementById("chipsScope"),
    chipsVendors: document.getElementById("chipsVendors"),
    listTitle: document.getElementById("listTitle"),
    listBox: document.getElementById("listBox"),
    detailBox: document.getElementById("detailBox"),
    badgeSel: document.getElementById("badgeSel"),
    q: document.getElementById("q"),
    btnSearch: document.getElementById("btnSearch"),
    btnResetView: document.getElementById("btnResetView"),
    btnCopySummary: document.getElementById("btnCopySummary"),
    btnClearAll: document.getElementById("btnClearAll"),
    raw: document.getElementById("raw"),
    btnApply: document.getElementById("btnApply"),
    btnSample: document.getElementById("btnSample"),
    btnExport: document.getElementById("btnExport"),
    statsLine: document.getElementById("statsLine"),
    toast: document.getElementById("toast")
  };

  /*********************
   * UTIL
   *********************/
  function toast(msg){
    el.toast.textContent = msg;
    el.toast.classList.add("show");
    setTimeout(()=> el.toast.classList.remove("show"), 1600);
  }
  function safeJsonParse(s, fallback){ try{ return JSON.parse(s); }catch(e){ return fallback; } }
  function normalizeWS(s){ return (s||"").toString().replace(/\s+/g," ").trim(); }
  function normalizeDongName(d){
    let x = (d||"").toString().trim();
    x = x.replace(/제?\s*\d+\s*동$/,"동");
    x = x.replace(/\d+동$/,"동");
    x = x.replace(/\s+/g,"");
    return x;
  }

  function isSidoToken(tok){
    if(!tok) return false;
    return tok.endsWith("도") || tok.endsWith("시") || tok.endsWith("특별시") || tok.endsWith("광역시") || tok.endsWith("특별자치시") || tok.endsWith("특별자치도");
  }

  // 핵심 수정:
  // '대구'는 도시명인데 글자 끝이 '구'라서 시군구로 오인됨 → 예외 처리
  function isSigunguToken(tok){
    if(!tok) return false;
    if(tok === "대구") return false; // 도시명 예외
    return tok.endsWith("시") || tok.endsWith("군") || tok.endsWith("구");
  }

  function isDongToken(tok){
    if(!tok) return false;
    return tok.endsWith("동") || tok.endsWith("읍") || tok.endsWith("면") || tok.endsWith("리");
  }

  function canonicalSido(sidoRaw){
    const s = normalizeWS(sidoRaw);
    return SIDO_ALIASES.get(s) || s;
  }

  function encodePathComponent(s){ return encodeURIComponent(s); }
  function buildDongUrl(sido){
    const key = SIDO_FILE[sido] || sido;
    return SOURCES.hangjeongdongBase + encodePathComponent(key) + ".geojson";
  }
  function uniq(arr){ return Array.from(new Set(arr)); }

  function groupCount(items){
    const m = new Map();
    for(const k of items){ m.set(k, (m.get(k)||0)+1); }
    return m;
  }
  function sortByCountThenName(map){
    return Array.from(map.entries()).sort((a,b)=>{
      if(b[1]!==a[1]) return b[1]-a[1];
      return a[0].localeCompare(b[0], "ko");
    });
  }

  function copyToClipboard(text){
    if(navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(text);
    }
    const ta = document.createElement("textarea");
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
    return Promise.resolve();
  }

  /*********************
   * DATA PARSING
   *********************/
  function parseLinesToEntries(rawText){
    const lines = (rawText||"").split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
    const out = [];

    for(const line of lines){
      let locPart = line;
      let vendorPart = null;

      if(line.includes("|")){
        const parts = line.split("|").map(p=>p.trim()).filter(Boolean);
        locPart = parts[0] || "";
        vendorPart = parts[1] || null;
      }else if(line.includes(",")){
        const parts = line.split(",").map(p=>p.trim()).filter(Boolean);
        if(parts.length>=2){
          locPart = parts[0];
          vendorPart = parts.slice(1).join(" ");
        }
      }

      const vendor = normalizeWS(vendorPart || DEFAULT_VENDOR) || DEFAULT_VENDOR;
      const tokens = normalizeWS(locPart).split(" ").filter(Boolean);
      if(tokens.length === 0) continue;

      let sido = null;
      let sigungu = null;
      let dong = null;

      if(isSidoToken(tokens[0]) || SIDO_ALIASES.has(tokens[0])){
        sido = canonicalSido(tokens[0]);
        if(tokens.length >= 3){
          if(tokens.length === 3){
            sigungu = tokens[1];
            dong = tokens[2];
          }else{
            dong = tokens[tokens.length-1];
            sigungu = tokens.slice(1, tokens.length-1).join(" ");
          }
        }else{
          continue;
        }
      }else{
        // 시/도 빠진 형태: "영등포구 대림동" / "용인시 수지구 동천동"
        if(tokens.length === 2){
          sigungu = tokens[0];
          dong = tokens[1];
        }else{
          dong = tokens[tokens.length-1];
          sigungu = tokens.slice(0, tokens.length-1).join(" ");
        }
      }

      if(!sigungu || !dong) continue;

      out.push({
        vendor,
        sido,
        sigungu: normalizeWS(sigungu),
        dong: normalizeWS(dong)
      });
    }

    return { entries: out };
  }

  function rebuildUnique(entries){
    state.uniqueKeys.clear();
    const uniqEntries = [];
    for(const e of entries){
      const key = [e.vendor, e.sido || "", e.sigungu || "", e.dong || ""].join("||");
      if(!state.uniqueKeys.has(key)){
        state.uniqueKeys.add(key);
        uniqEntries.push(e);
      }
    }
    state.entries = uniqEntries;
  }

  /*********************
   * BOUNDARY LOADING
   *********************/
  async function fetchJson(url){
    const r = await fetch(url, { cache:"force-cache" });
    if(!r.ok) throw new Error("HTTP " + r.status + " " + url);
    return r.json();
  }

  function featureName(props){
    if(!props) return "";
    return (
      props.name || props.NAME || props.Name ||
      props.adm_nm ||
      props.sido || props.sidonm || props.SIDO_NM ||
      props.sigungu || props.sggnm || props.SGG_NM ||
      props.EMD_NM || props.emdnm ||
      props.CTP_KOR_NM || props.SIG_KOR_NM ||
      ""
    ).toString().trim();
  }

  function parseFullNameGuess(fullName){
    const t = normalizeWS(fullName).split(" ").filter(Boolean);
    if(t.length<2) return { sido:null, sigungu:null };
    const sido = canonicalSido(t[0]);
    const sigungu = t.slice(1).join(" ");
    return { sido, sigungu };
  }

  async function ensureProvinces(){
    if(state.provincesGeo) return state.provincesGeo;
    const j = await fetchJson(SOURCES.provincesGeo);
    state.provincesGeo = j;
    return j;
  }

  async function ensureMunicipalities(){
    if(state.municipalitiesGeo) return state.municipalitiesGeo;

    const topo = await fetchJson(SOURCES.municipalitiesTopo);
    state.municipalitiesTopo = topo;

    const objKey = Object.keys(topo.objects||{})[0];
    if(!objKey) throw new Error("TopoJSON objects 없음");

    const geo = topojson.feature(topo, topo.objects[objKey]);
    state.municipalitiesGeo = geo;

    // sigungu->sido 추정 맵
    const tempMap = new Map();
    for(const f of (geo.features||[])){
      const nm = featureName(f.properties) || "";
      const parsed = parseFullNameGuess(nm);
      if(parsed.sido && parsed.sigungu){
        const sig = parsed.sigungu;
        if(!tempMap.has(sig)) tempMap.set(sig, new Set());
        tempMap.get(sig).add(parsed.sido);
      }
    }
    state.sigunguToSido.clear();
    for(const [sig, set] of tempMap.entries()){
      if(set.size === 1){
        state.sigunguToSido.set(sig, Array.from(set)[0]);
      }
    }

    return geo;
  }

  async function ensureDongGeo(sido){
    if(!sido) throw new Error("sido 없음");
    const key = canonicalSido(sido);
    if(state.dongGeoBySido.has(key)) return state.dongGeoBySido.get(key);

    const url = buildDongUrl(key);
    const j = await fetchJson(url);
    state.dongGeoBySido.set(key, j);
    return j;
  }

  /*********************
   * INFER / VALIDATE
   *********************/
  function inferMissingSido(){
    let changed = 0;
    for(const e of state.entries){
      if(e.sido) continue;
      const inferred = state.sigunguToSido.get(e.sigungu);
      if(inferred){
        e.sido = inferred;
        changed++;
      }
    }
    return changed;
  }

  // 선택된 sigungu가 현재 sido의 시군구 목록에 실제로 존재하는지 검증
  function validateSelectionSigungu(){
    if(!state.sido || !state.sigungu || !state.municipalitiesGeo) return;
    const targetSido = canonicalSido(state.sido);
    const sigSet = new Set();

    for(const f of (state.municipalitiesGeo.features||[])){
      const nm = featureName(f.properties);
      const parsed = parseFullNameGuess(nm);
      if(parsed.sido && canonicalSido(parsed.sido) === targetSido && parsed.sigungu){
        sigSet.add(parsed.sigungu);
      }
    }

    if(!sigSet.has(state.sigungu)){
      // 오인/오타로 잡힌 sigungu면 상위로 리셋(동도 같이 리셋)
      state.sigungu = null;
      state.dong = null;
      state.level = "SIGUNGU";
    }
  }

  /*********************
   * FILTERING / AGG
   *********************/
  function selectionLabel(){
    const parts = [];
    if(state.sido) parts.push(state.sido);
    if(state.sigungu) parts.push(state.sigungu);
    if(state.dong) parts.push(state.dong);
    if(parts.length === 0) return "전체";
    return parts.join(" / ");
  }

  function entryMatchesSelection(e){
    if(state.vendor && e.vendor !== state.vendor) return false;
    if(state.sido && e.sido !== state.sido) return false;
    if(state.sigungu && e.sigungu !== state.sigungu) return false;
    if(state.dong && normalizeDongName(e.dong) !== normalizeDongName(state.dong)) return false;
    return true;
  }

  function getFiltered(){
    return state.entries.filter(entryMatchesSelection);
  }

  function aggByLevel(level, entries){
    const keys = [];
    for(const e of entries){
      if(level==="SIDO"){ if(e.sido) keys.push(e.sido); }
      else if(level==="SIGUNGU"){ if(e.sigungu) keys.push(e.sigungu); }
      else { if(e.dong) keys.push(e.dong); }
    }
    return groupCount(keys);
  }

  function aggVendors(entries){
    return groupCount(entries.map(e=>e.vendor));
  }

  function uniqueLocationCount(entries){
    const s = new Set();
    for(const e of entries){
      s.add([e.vendor, e.sido||"", e.sigungu||"", normalizeDongName(e.dong||"")].join("||"));
    }
    return s.size;
  }

  /*********************
   * MAP DRAWING
   *********************/
  function ensureMap(){
    if(state.map) return;
    const center = new kakao.maps.LatLng(36.5, 127.8);
    state.map = new kakao.maps.Map(document.getElementById("map"), { center, level: 13 });

    // 줌 변경 시 레이어 자동 전환
    kakao.maps.event.addListener(state.map, "zoom_changed", function(){
      scheduleMapRerenderByZoom();
    });
  }

  function scheduleMapRerenderByZoom(){
    if(!state.sido) return; // 전국(시도) 단계는 줌 기반 전환 필요 없음
    clearTimeout(state.zoomTimer);
    state.zoomTimer = setTimeout(()=>{
      // 줌 기반 redraw는 fitBounds 하지 않고 현재 뷰 유지
      renderMapBySelection({ fitBounds:false, reason:"zoom" }).catch(()=>{});
    }, 120);
  }

  function clearMapOverlays(){
    for(const p of state.polygons){ try{ p.setMap(null); }catch(e){} }
    for(const o of state.overlays){ try{ o.setMap(null); }catch(e){} }
    state.polygons = [];
    state.overlays = [];
  }

  function geoCoordsToLatLngPath(coords){
    const path = [];
    for(const pt of coords){
      if(!pt || pt.length < 2) continue;
      path.push(new kakao.maps.LatLng(pt[1], pt[0]));
    }
    return path;
  }

  function geomToPaths(geom){
    if(!geom) return [];
    const type = geom.type;
    const c = geom.coordinates;
    const out = [];
    if(type === "Polygon"){
      if(Array.isArray(c) && c[0]) out.push(geoCoordsToLatLngPath(c[0]));
    }else if(type === "MultiPolygon"){
      for(const poly of (c||[])){ if(poly && poly[0]) out.push(geoCoordsToLatLngPath(poly[0])); }
    }
    return out;
  }

  function boundsFromPath(path){
    const b = new kakao.maps.LatLngBounds();
    for(const ll of path) b.extend(ll);
    return b;
  }

  function centroidFromPath(path){
    let sumLat = 0, sumLng = 0, n = 0;
    for(const ll of path){ sumLat += ll.getLat(); sumLng += ll.getLng(); n++; }
    if(n===0) return null;
    return new kakao.maps.LatLng(sumLat/n, sumLng/n);
  }

  function makeLabelOverlay(position, name, count){
    const div = document.createElement("div");
    div.className = "regionLabel";
    div.textContent = name;
    if(typeof count === "number"){
      const sm = document.createElement("small");
      sm.textContent = String(count);
      div.appendChild(sm);
    }
    return new kakao.maps.CustomOverlay({ position, content: div, yAnchor: 1 });
  }

  function colorForCount(count){
    if(count >= 10) return "rgba(19,136,255,.30)";
    if(count >= 5) return "rgba(109,92,255,.28)";
    if(count >= 1) return "rgba(15,23,42,.10)";
    return "rgba(15,23,42,.04)";
  }
  function strokeForActive(active){ return active ? "rgba(109,92,255,.98)" : "rgba(19,136,255,.82)"; }
  function fillOpacityForActive(active){ return active ? 0.46 : 0.32; }

  // fitBounds 옵션 추가: zoom 이벤트로 다시 그릴 땐 현재 뷰 유지
  function drawGeoFeatures(geo, options){
    clearMapOverlays();

    const counts = options.countsMap || new Map();
    const activeName = options.activeName || null;
    const fitBounds = (options.fitBounds !== false);

    let overallBounds = null;

    for(const f of (geo.features||[])){
      const nm = (options.getName ? options.getName(f) : featureName(f.properties)) || "";
      if(!nm) continue;

      const paths = geomToPaths(f.geometry);
      if(paths.length===0) continue;

      const count = counts.get(nm) || 0;
      const isActive = (activeName && nm === activeName);

      for(const path of paths){
        if(path.length < 3) continue;

        const poly = new kakao.maps.Polygon({
          path,
          strokeWeight: 3,
          strokeColor: strokeForActive(isActive),
          strokeOpacity: 0.98,
          strokeStyle: "solid",
          fillColor: colorForCount(count),
          fillOpacity: fillOpacityForActive(isActive)
        });

        poly.setMap(state.map);
        state.polygons.push(poly);

        if(fitBounds){
          const b = boundsFromPath(path);
          if(!overallBounds) overallBounds = b;
          else overallBounds.extend(b.getSouthWest()), overallBounds.extend(b.getNorthEast());
        }

        if(options.onClick){
          kakao.maps.event.addListener(poly, "click", function(){
            options.onClick(nm, f);
          });
        }
      }

      const representativePath = paths[0];
      const center = centroidFromPath(representativePath);
      if(center && (count > 0 || nm === activeName)){
        const ov = makeLabelOverlay(center, nm, count);
        ov.setMap(state.map);
        state.overlays.push(ov);
      }
    }

    if(fitBounds && overallBounds){
      state.map.setBounds(overallBounds);
    }
  }

  /*********************
   * UI RENDER
   *********************/
  function renderBadge(){ el.badgeData.textContent = "데이터: " + state.entries.length + "건"; }
  function escapeHtml(s){
    return (s||"").toString()
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }

  function renderScopeChips(){
    const items = [];
    items.push({ key:"ALL", label:"전체", active: !state.sido && !state.sigungu && !state.dong });
    if(state.sido) items.push({ key:"SIDO", label: state.sido, active: !!state.sido && !state.sigungu && !state.dong });
    if(state.sigungu) items.push({ key:"SIGUNGU", label: state.sigungu, active: !!state.sigungu && !state.dong });
    if(state.dong) items.push({ key:"DONG", label: state.dong, active: !!state.dong });

    const canBack = !!(state.sido || state.sigungu || state.dong);

    el.chipsScope.innerHTML = "";
    for(const it of items){
      const c = document.createElement("div");
      c.className = "chip" + (it.active ? " active" : "");
      c.innerHTML = "<strong>" + escapeHtml(it.label) + "</strong>";
      c.addEventListener("click", ()=>{
        if(it.key==="ALL"){
          setSelection({ level:"SIDO", sido:null, sigungu:null, dong:null });
        }else if(it.key==="SIDO"){
          setSelection({ level:"SIGUNGU", sido:state.sido, sigungu:null, dong:null });
        }else if(it.key==="SIGUNGU"){
          setSelection({ level:"DONG", sido:state.sido, sigungu:state.sigungu, dong:null });
        }
      });
      el.chipsScope.appendChild(c);
    }

    if(canBack){
      const c = document.createElement("div");
      c.className = "chip";
      c.innerHTML = "<strong>← 한 단계 위</strong>";
      c.addEventListener("click", ()=>{
        if(state.dong){
          setSelection({ level:"DONG", sido:state.sido, sigungu:state.sigungu, dong:null });
        }else if(state.sigungu){
          setSelection({ level:"SIGUNGU", sido:state.sido, sigungu:null, dong:null });
        }else if(state.sido){
          setSelection({ level:"SIDO", sido:null, sigungu:null, dong:null });
        }
      });
      el.chipsScope.appendChild(c);
    }
  }

  function renderVendorChips(){
    const base = state.entries.filter(e=>{
      if(state.sido && e.sido !== state.sido) return false;
      if(state.sigungu && e.sigungu !== state.sigungu) return false;
      if(state.dong && normalizeDongName(e.dong) !== normalizeDongName(state.dong)) return false;
      return true;
    });

    const m = aggVendors(base);
    const rows = sortByCountThenName(m);

    el.chipsVendors.innerHTML = "";

    const allCount = uniqueLocationCount(base);
    const allChip = document.createElement("div");
    allChip.className = "chip" + (!state.vendor ? " active" : "");
    allChip.innerHTML = "<strong>전체 업체</strong> <span class='count'>" + allCount + "</span>";
    allChip.addEventListener("click", ()=>{
      state.vendor = null;
      refresh();
    });
    el.chipsVendors.appendChild(allChip);

    for(const [vendor, count] of rows){
      const c = document.createElement("div");
      c.className = "chip" + (state.vendor === vendor ? " active" : "");
      c.innerHTML = "<strong>" + escapeHtml(vendor) + "</strong> <span class='count'>" + count + "</span>";
      c.addEventListener("click", ()=>{
        state.vendor = (state.vendor === vendor) ? null : vendor;
        refresh();
      });
      el.chipsVendors.appendChild(c);
    }
  }

  function renderList(){
    const filtered = getFiltered();
    el.listBox.innerHTML = "";

    let mode = "SIDO";
    if(state.sido && !state.sigungu) mode = "SIGUNGU";
    if(state.sigungu && !state.dong) mode = "DONG";
    if(state.dong) mode = "DETAIL";

    if(mode === "SIDO"){
      el.listTitle.textContent = "시/도";
      const rows = sortByCountThenName(aggByLevel("SIDO", filtered));
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>표시할 데이터가 없습니다.</div></div>";
        return;
      }
      for(const [name, count] of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(name)}</div>
              <div class="liSub">클릭해서 시군구 보기</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">${count}</span></div>`;
        item.addEventListener("click", ()=>{
          setSelection({ level:"SIGUNGU", sido:name, sigungu:null, dong:null });
        });
        el.listBox.appendChild(item);
      }
    }else if(mode === "SIGUNGU"){
      el.listTitle.textContent = "시/군/구 (선택: " + state.sido + ")";
      const rows = sortByCountThenName(aggByLevel("SIGUNGU", filtered));
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>선택된 시/도에 데이터가 없습니다.</div></div>";
        return;
      }
      for(const [name, count] of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(name)}</div>
              <div class="liSub">클릭해서 동 보기</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">${count}</span></div>`;
        item.addEventListener("click", ()=>{
          setSelection({ level:"DONG", sido:state.sido, sigungu:name, dong:null });
        });
        el.listBox.appendChild(item);
      }
    }else if(mode === "DONG"){
      el.listTitle.textContent = "동/읍/면 (선택: " + state.sigungu + ")";
      const rows = sortByCountThenName(aggByLevel("DONG", filtered));
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>선택된 시군구에 데이터가 없습니다.</div></div>";
        return;
      }
      for(const [name, count] of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(name)}</div>
              <div class="liSub">클릭해서 업체/상세 보기</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">${count}</span></div>`;
        item.addEventListener("click", ()=>{
          setSelection({ level:"DONG", sido:state.sido, sigungu:state.sigungu, dong:name });
        });
        el.listBox.appendChild(item);
      }
    }else{
      el.listTitle.textContent = "상세 (선택: " + state.dong + ")";
      const rows = filtered.slice().sort((a,b)=>{
        const A = a.vendor.localeCompare(b.vendor, "ko");
        if(A!==0) return A;
        const B = (a.sigungu||"").localeCompare(b.sigungu||"", "ko");
        if(B!==0) return B;
        return (a.dong||"").localeCompare(b.dong||"", "ko");
      });
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>해당 동에 데이터가 없습니다.</div></div>";
        return;
      }
      for(const e of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(e.vendor)}</div>
              <div class="liSub">${escapeHtml((e.sido||"?") + " / " + e.sigungu + " / " + e.dong)}</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">1</span></div>`;
        el.listBox.appendChild(item);
      }
    }
  }

  function kvRow(k,v){
    return `
      <div class="kv">
        <div class="k">${escapeHtml(k)}</div>
        <div class="v">${escapeHtml(v)}</div>
      </div>`;
  }

  function renderDetail(){
    const filtered = getFiltered();
    el.badgeSel.textContent = selectionLabel() + (state.vendor ? (" / " + state.vendor) : "");

    if(filtered.length===0){
      el.detailBox.className = "detailEmpty";
      el.detailBox.innerHTML = "선택된 조건에 데이터가 없습니다.";
      return;
    }

    const vendors = sortByCountThenName(aggVendors(filtered));
    const uniqCnt = uniqueLocationCount(filtered);
    const topDong = sortByCountThenName(aggByLevel("DONG", filtered)).slice(0, 12);

    const html = [];
    html.push("<div class='list' style='margin-bottom:12px;'>");
    html.push(kvRow("선택 범위", selectionLabel()));
    html.push(kvRow("업체 필터", state.vendor ? state.vendor : "전체"));
    html.push(kvRow("유니크(업체+지역)", String(uniqCnt)));
    html.push("</div>");

    html.push("<div class='sectionTitle'>업체 분포</div>");
    html.push("<div class='list'>");
    for(const [v, c] of vendors){ html.push(kvRow(v, String(c))); }
    html.push("</div>");

    html.push("<div class='divider'></div>");
    html.push("<div class='sectionTitle'>상위 동(Top 12)</div>");
    html.push("<div class='list'>");
    for(const [d, c] of topDong){ html.push(kvRow(d, String(c))); }
    html.push("</div>");

    el.detailBox.className = "";
    el.detailBox.innerHTML = html.join("");
  }

  function renderStatsLine(extra){
    const rawLines = (el.raw.value||"").split(/\r?\n/).filter(x=>x.trim()).length;
    el.statsLine.textContent = `원본 라인 ${rawLines} / 유니크(업체+지역) ${state.entries.length}` + (extra ? (" / " + extra) : "");
  }

  /*********************
   * SELECTION
   *********************/
  function setSelection(next){
    state.level = next.level || state.level;
    state.sido = next.sido ?? state.sido;
    state.sigungu = next.sigungu ?? state.sigungu;
    state.dong = next.dong ?? state.dong;
    refresh();
  }

  function persist(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state.entries));
    localStorage.setItem(STORAGE_RAW_KEY, el.raw.value || "");
  }

  function restore(){
    const saved = safeJsonParse(localStorage.getItem(STORAGE_KEY), []);
    if(Array.isArray(saved) && saved.length){
      state.entries = saved.map(x=>({
        vendor: normalizeWS(x.vendor||DEFAULT_VENDOR) || DEFAULT_VENDOR,
        sido: x.sido ? canonicalSido(x.sido) : null,
        sigungu: normalizeWS(x.sigungu||""),
        dong: normalizeWS(x.dong||"")
      })).filter(x=>x.sigungu && x.dong);
      rebuildUnique(state.entries);
    }
    const rawSaved = localStorage.getItem(STORAGE_RAW_KEY);
    if(rawSaved){ el.raw.value = rawSaved; }
  }

  function resetView(){
    state.level = "SIDO";
    state.sido = null;
    state.sigungu = null;
    state.dong = null;
    state.vendor = null;
    el.q.value = "";
    refresh();
  }

  /*********************
   * LAYER DECISION (Scale-based)
   *********************/
  function desiredLayer(){
    // 전국이면 시도
    if(!state.sido) return "SIDO";

    // 시/도만 선택이면 무조건 시군구
    if(!state.sigungu) return "SIGUNGU";

    // 시군구 선택 상태에서 줌이 충분히 크면 동
    const lvl = state.map ? state.map.getLevel() : 99;
    if(lvl <= DONG_ZOOM_THRESHOLD) return "DONG";

    // 줌이 멀면 시군구(선택 구 하이라이트)
    return "SIGUNGU";
  }

  function layerKey(layer){
    return [
      layer,
      state.sido||"",
      state.sigungu||"",
      state.dong||"",
      state.vendor||"ALL",
      (state.map ? state.map.getLevel() : "")
    ].join("|");
  }

  /*********************
   * MAP RENDER
   *********************/
  async function renderMapBySelection(opts){
    ensureMap();
    const fitBounds = (opts && opts.fitBounds !== false);

    if(state.isRenderingMap) return;
    state.isRenderingMap = true;

    try{
      await ensureMunicipalities();
      inferMissingSido();
      rebuildUnique(state.entries);
      validateSelectionSigungu();
      persist();

      const layer = desiredLayer();
      const key = layerKey(layer);
      if(key === state.lastRenderedLayerKey && opts && opts.reason==="zoom"){
        // 줌 이벤트로 불필요한 반복 redraw 방지
        return;
      }
      state.lastRenderedLayerKey = key;

      if(layer === "SIDO"){
        const provinces = await ensureProvinces();
        const filtered = getFiltered();
        const countsMap = aggByLevel("SIDO", filtered);

        drawGeoFeatures(provinces, {
          getName: (f)=> canonicalSido(featureName(f.properties)),
          countsMap,
          activeName: null,
          fitBounds,
          onClick: (sidoName)=>{
            setSelection({ level:"SIGUNGU", sido: canonicalSido(sidoName), sigungu:null, dong:null });
          }
        });
        return;
      }

      if(layer === "SIGUNGU"){
        const targetSido = canonicalSido(state.sido);
        const filtered = getFiltered();
        const sigCount = aggByLevel("SIGUNGU", filtered);

        const feat = [];
        for(const f of (state.municipalitiesGeo.features||[])){
          const nm = featureName(f.properties);
          const parsed = parseFullNameGuess(nm);
          if(parsed.sido && canonicalSido(parsed.sido) === targetSido){
            const clone = Object.assign({}, f);
            clone.__displayName = parsed.sigungu;
            feat.push(clone);
          }
        }
        const geo = { type:"FeatureCollection", features: feat };

        drawGeoFeatures(geo, {
          getName: (f)=> f.__displayName || featureName(f.properties),
          countsMap: sigCount,
          activeName: state.sigungu || null,   // 선택된 구 하이라이트
          fitBounds,
          onClick: (sigName)=>{
            // 구 클릭 → 구 선택(동 단계로 진입)
            setSelection({ level:"DONG", sido: state.sido, sigungu: sigName, dong:null });
          }
        });
        return;
      }

      // DONG layer
      await renderDongLevel({ fitBounds });
    }catch(err){
      clearMapOverlays();
      toast("경계/지도 로드 실패");
    }finally{
      state.isRenderingMap = false;
    }
  }

  async function renderDongLevel({ fitBounds }){
    if(!state.sido || !state.sigungu){
      // 안전장치: 동은 구 선택 후에만
      await renderMapBySelection({ fitBounds, reason:"fallbackSigungu" });
      return;
    }

    const dongGeo = await ensureDongGeo(state.sido);
    inferMissingSido();
    rebuildUnique(state.entries);

    const filtered = getFiltered();
    const dongCount = aggByLevel("DONG", filtered);

    const countsMapNorm = new Map();
    for(const [d,c] of dongCount.entries()){
      countsMapNorm.set(normalizeDongName(d), c);
    }

    const features = [];
    const targetSigungu = normalizeWS(state.sigungu);

    for(const f of (dongGeo.features||[])){
      const nm = featureName(f.properties);
      const adm = normalizeWS(nm);
      if(!adm.includes(targetSigungu)) continue;
      const clone = Object.assign({}, f);
      clone.__admName = adm;
      features.push(clone);
    }

    const geo = { type:"FeatureCollection", features };

    drawGeoFeatures(geo, {
      getName: (f)=>{
        const adm = f.__admName || featureName(f.properties);
        const toks = normalizeWS(adm).split(" ");
        const last = toks[toks.length-1] || adm;
        return normalizeDongName(last);
      },
      countsMap: countsMapNorm,
      activeName: state.dong ? normalizeDongName(state.dong) : null,
      fitBounds,
      onClick: (dongName)=>{
        setSelection({ level:"DONG", sido: state.sido, sigungu: state.sigungu, dong: dongName });
      }
    });
  }

  /*********************
   * REFRESH
   *********************/
  async function refresh(){
    renderBadge();
    renderScopeChips();
    renderVendorChips();
    renderList();
    renderDetail();
    renderStatsLine();

    await renderMapBySelection({ fitBounds:true, reason:"selection" });
    persist();
  }

  /*********************
   * SEARCH
   *********************/
  function doSearch(){
    const q = normalizeWS(el.q.value);
    if(!q){ toast("검색어를 입력하세요"); return; }

    const allVendors = uniq(state.entries.map(e=>e.vendor));
    for(const v of allVendors){
      if(v && q.includes(v)){ state.vendor = v; break; }
    }

    const tokens = q.split(" ").filter(Boolean);

    let sido = null, sigungu = null, dong = null;

    for(const t of tokens){
      if(SIDO_ALIASES.has(t) || isSidoToken(t)){
        sido = canonicalSido(t);
        break;
      }
    }

    for(let i=tokens.length-1; i>=0; i--){
      const t = tokens[i];
      if(!dong && isDongToken(t)) dong = t;
      if(!sigungu && isSigunguToken(t)) sigungu = t;
    }

    // "대구" 단독 검색이면 sigungu로 잡히지 않도록 이미 보정됨
    if(!sido && sigungu){
      const inferred = state.sigunguToSido.get(sigungu);
      if(inferred) sido = inferred;
    }

    if(sido && sigungu && dong){
      setSelection({ level:"DONG", sido, sigungu, dong });
    }else if(sido && sigungu){
      setSelection({ level:"DONG", sido, sigungu, dong:null });
    }else if(sido){
      setSelection({ level:"SIGUNGU", sido, sigungu:null, dong:null });
    }else{
      toast("지역을 특정할 수 없습니다(예: '대구광역시 중구 칠성동')");
      refresh();
    }
  }

  /*********************
   * EVENTS
   *********************/
  el.btnApply.addEventListener("click", async ()=>{
    const { entries } = parseLinesToEntries(el.raw.value);
    rebuildUnique(entries);

    try{
      await ensureMunicipalities();
      const changed = inferMissingSido();
      rebuildUnique(state.entries);
      renderStatsLine("시도 자동추정 " + changed + "건");
      toast("적용 완료 (유니크 " + state.entries.length + ")");
      refresh();
    }catch(e){
      renderStatsLine("경계 로드 실패로 시도 자동추정 불가");
      toast("적용 완료(경계 로드 실패)");
      refresh();
    }
    persist();
  });

  el.btnSample.addEventListener("click", ()=>{
    el.raw.value =
`영등포구 대림동 | 마루웰
영등포구 대림동 | 마루웰
분당구 대장동 | 투네스트
용인시 수지구 동천동 | 투네스트
영등포구 신길동 | 마루웰
대구광역시 중구 칠성동 | 마루웰
대구광역시 중구 동인동 | 마루웰
서울특별시 강서구 염창동 | 투네스트
서울특별시 강서구 염창동 | 마루웰
경기도 용인시 수지구 동천동 | 마루웰`;
    toast("샘플 로드");
    renderStatsLine();
  });

  el.btnExport.addEventListener("click", ()=>{
    const lines = state.entries
      .slice()
      .sort((a,b)=>{
        const A=(a.sido||"").localeCompare(b.sido||"", "ko");
        if(A!==0) return A;
        const B=(a.sigungu||"").localeCompare(b.sigungu||"", "ko");
        if(B!==0) return B;
        const C=normalizeDongName(a.dong||"").localeCompare(normalizeDongName(b.dong||""), "ko");
        if(C!==0) return C;
        return (a.vendor||"").localeCompare(b.vendor||"", "ko");
      })
      .map(e=>{
        const loc = [e.sido||"", e.sigungu||"", e.dong||""].filter(Boolean).join(" ");
        return loc + " | " + e.vendor;
      });
    copyToClipboard(lines.join("\n")).then(()=> toast("유니크 목록 복사됨"));
  });

  el.btnSearch.addEventListener("click", doSearch);
  el.q.addEventListener("keydown", (ev)=>{ if(ev.key==="Enter") doSearch(); });

  el.btnResetView.addEventListener("click", resetView);

  el.btnCopySummary.addEventListener("click", ()=>{
    const filtered = getFiltered();
    const uniqCnt = uniqueLocationCount(filtered);
    const vendors = sortByCountThenName(aggVendors(filtered));
    const topDong = sortByCountThenName(aggByLevel("DONG", filtered)).slice(0, 10);

    const summary =
`[CoupangLand 요약]
선택: ${selectionLabel()}
업체필터: ${state.vendor ? state.vendor : "전체"}
유니크(업체+지역): ${uniqCnt}

[업체 분포]
${vendors.map(([v,c])=>`- ${v}: ${c}`).join("\n") || "- (없음)"}

[Top 동]
${topDong.map(([d,c])=>`- ${d}: ${c}`).join("\n") || "- (없음)"}
`;
    copyToClipboard(summary).then(()=> toast("요약 복사됨"));
  });

  el.btnClearAll.addEventListener("click", ()=>{
    if(!confirm("localStorage의 CoupangLand 데이터를 모두 삭제할까요?")) return;
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(STORAGE_RAW_KEY);
    state.entries = [];
    state.uniqueKeys.clear();
    el.raw.value = "";
    resetView();
    toast("초기화 완료");
  });

  /*********************
   * INIT
   *********************/
  async function init(){
    ensureMap();
    restore();

    renderBadge();
    renderScopeChips();
    renderVendorChips();
    renderList();
    renderDetail();
    renderStatsLine();

    try{
      await ensureMunicipalities();
      const changed = inferMissingSido();
      if(changed>0){
        rebuildUnique(state.entries);
        persist();
      }
    }catch(e){}

    await refresh();
  }

  init();

})();
</script>
</body>
</html>
