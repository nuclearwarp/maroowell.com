<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>CoupangLand | MaruWell</title>

  <meta name="robots" content="noindex" />
  <meta name="description" content="지역별 대리점/라우트 현황을 카카오지도 + 행정경계 오버레이로 드릴다운 조회" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="CoupangLand | MaruWell" />
  <meta property="og:description" content="시/도 → 시군구 → 동 단위 드릴다운" />
  <meta property="og:site_name" content="MaroWell" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico?v=2" />

  <style>
    :root{
      --bg:#0b1220;
      --panel:#111a2e;
      --line:rgba(255,255,255,.10);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.68);
      --muted2:rgba(255,255,255,.54);
      --accent:#6ee7ff;
      --accent2:#a78bfa;
      --danger:#ff4d4f;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius: 16px;
      --radius2: 12px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1100px 700px at 20% 0%, rgba(110,231,255,.10), transparent 65%),
                  radial-gradient(900px 650px at 90% 20%, rgba(167,139,250,.12), transparent 60%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
    }
    .wrap{max-width:1200px; margin:0 auto; padding:18px 16px 28px}
    header{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; padding:12px 10px 18px;
    }
    .brand{display:flex; flex-direction:column; gap:4px;}
    .brand .title{
      font-weight:800; letter-spacing:.2px; font-size:20px;
      display:flex; align-items:center; gap:10px;
    }
    .dot{
      width:10px; height:10px; border-radius:99px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 0 0 6px rgba(110,231,255,.10);
    }
    .brand .sub{color:var(--muted); font-size:13px}
    .headerActions{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
    .btn{
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius: 12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
      transition: .15s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.09)}
    .btn:active{transform: translateY(0px)}
    .btn.primary{
      border-color: rgba(110,231,255,.45);
      background: linear-gradient(135deg, rgba(110,231,255,.18), rgba(167,139,250,.16));
    }
    .btn.danger{
      border-color: rgba(255,77,79,.40);
      background: rgba(255,77,79,.12);
    }

    .grid{display:grid; grid-template-columns: 1.1fr .9fr; gap:14px;}
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
      header{flex-direction:column; align-items:flex-start}
      .headerActions{width:100%; justify-content:stretch}
      .headerActions .btn{flex:1}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHead{
      padding:14px 14px 10px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      border-bottom: 1px solid var(--line);
      background: rgba(0,0,0,.10);
    }
    .cardHead h2{margin:0; font-size:14px; letter-spacing:.2px;}
    .pill{
      font-size:12px; font-weight:800;
      padding:6px 10px; border-radius:999px;
      background: rgba(255,255,255,.08);
      border:1px solid var(--line);
      color: var(--muted);
      white-space:nowrap;
    }
    .cardBody{padding:14px}

    .searchRow{display:flex; gap:10px; flex-wrap:wrap; margin-bottom:12px;}
    .input{
      flex: 1;
      min-width: 220px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color: var(--text);
      border-radius: 12px;
      padding: 11px 12px;
      outline:none;
    }
    .input::placeholder{color: rgba(255,255,255,.45)}
    .hint{color: var(--muted2); font-size:12px; line-height:1.45; margin-top:8px}

    .mapWrap{display:grid; grid-template-columns: 1.15fr .85fr; gap:14px; align-items:start;}
    @media (max-width: 980px){ .mapWrap{grid-template-columns:1fr} }

    .mapBox{
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: rgba(255,255,255,.03);
      overflow:hidden;
      position:relative;
    }
    #kakaoMap{width:100%; height:560px;}
    .mapTopRight{
      position:absolute;
      right:10px; top:10px;
      display:flex; gap:8px; flex-wrap:wrap;
      z-index:5;
    }
    .miniBtn{
      border:1px solid var(--line);
      background: rgba(10,16,32,.72);
      color:var(--text);
      border-radius: 999px;
      padding:8px 10px;
      font-size:12px;
      font-weight:800;
      cursor:pointer;
    }
    .miniBtn:hover{background: rgba(10,16,32,.88)}
    .levelTag{
      position:absolute;
      left:10px; top:10px;
      z-index:5;
      border:1px solid var(--line);
      background: rgba(10,16,32,.72);
      border-radius: 999px;
      padding:8px 10px;
      font-size:12px;
      font-weight:900;
      color: var(--muted);
    }

    .side{
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: rgba(255,255,255,.03);
      padding:12px;
    }

    .crumbs{display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px; align-items:center;}
    .crumb{
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      padding:7px 10px;
      border-radius: 999px;
      cursor:pointer;
      font-weight: 800;
      font-size:12px;
      color: var(--muted);
      transition:.12s ease;
    }
    .crumb:hover{background: rgba(255,255,255,.08); transform: translateY(-1px)}
    .crumb.active{
      color: var(--text);
      border-color: rgba(110,231,255,.45);
      background: rgba(110,231,255,.10);
    }

    .chips{display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px;}
    .chip{
      border:1px solid var(--line);
      background: rgba(255,255,255,.08);
      border-radius: 999px;
      padding:7px 10px;
      cursor:pointer;
      font-size:12px;
      font-weight: 800;
      color: var(--muted);
      display:flex; gap:8px; align-items:center;
      transition:.12s ease;
    }
    .chip:hover{background: rgba(255,255,255,.12); transform: translateY(-1px)}
    .chip.active{
      color: var(--text);
      border-color: rgba(167,139,250,.55);
      background: rgba(167,139,250,.14);
    }
    .badge{
      min-width: 22px;
      text-align:center;
      padding:2px 7px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.12);
      color: var(--text);
      font-weight: 900;
      font-size: 11px;
    }

    .list{display:flex; flex-direction:column; gap:8px; margin-top: 8px;}
    .item{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      cursor:pointer;
      transition:.12s ease;
    }
    .item:hover{background: rgba(255,255,255,.07); transform: translateY(-1px)}
    .item .left{display:flex; flex-direction:column; gap:3px; min-width:0;}
    .item .name{font-weight: 900; font-size: 13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .item .meta{font-size: 12px; color: var(--muted2); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

    .empty{
      border:1px dashed rgba(255,255,255,.18);
      background: rgba(255,255,255,.03);
      border-radius: 12px;
      padding:12px;
      color: var(--muted);
      font-size: 13px;
      line-height:1.45;
    }

    details{border-top:1px solid var(--line); margin-top: 12px; padding-top: 12px;}
    details summary{cursor:pointer; font-weight: 900; color: var(--text); list-style:none; user-select:none;}
    details summary::-webkit-details-marker{display:none}
    .textarea{
      width:100%;
      min-height: 200px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      color: var(--text);
      border-radius: 12px;
      padding: 12px;
      outline:none;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Noto Sans Mono", monospace;
      font-size: 12px;
      line-height: 1.45;
    }
    .rowBtns{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    .footNote{margin-top:10px; color: var(--muted2); font-size:12px; line-height:1.45}
    .statLine{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; color: var(--muted); font-size: 12px;}
    .statLine b{color: var(--text)}

    .toast{
      position: fixed;
      right: 16px;
      bottom: 16px;
      max-width: 360px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(10,16,32,.92);
      box-shadow: var(--shadow);
      color: var(--text);
      font-size: 13px;
      line-height: 1.35;
      opacity: 0;
      transform: translateY(8px);
      transition: .18s ease;
      pointer-events:none;
      z-index: 9999;
    }
    .toast.show{opacity: 1; transform: translateY(0px);}

    /* Kakao CustomOverlay */
    .mwLabel{
      border:1px solid rgba(255,255,255,.18);
      background: rgba(10,16,32,.78);
      color: rgba(255,255,255,.92);
      padding: 6px 9px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 900;
      white-space: nowrap;
      box-shadow: 0 10px 24px rgba(0,0,0,.30);
      transform: translate(-50%, -100%);
    }
    .mwLabel .c{color: rgba(110,231,255,.95)}
  </style>

  <!-- Kakao 지도 SDK (사용 중인 키 그대로) -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3"></script>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="title"><span class="dot"></span> CoupangLand <span class="pill">KakaoMap + 행정경계</span></div>
        <div class="sub">시/도 → 시군구 → 동 경계를 GeoJSON으로 오버레이해 드릴다운 조회합니다. (백엔드 없음 / localStorage 저장)</div>
      </div>

      <div class="headerActions">
        <button class="btn primary" id="btnReset">전체 보기</button>
        <button class="btn" id="btnCopy">현재 화면 요약 복사</button>
        <button class="btn danger" id="btnClear">데이터 초기화</button>
      </div>
    </header>

    <div class="grid">
      <!-- Left -->
      <div class="card">
        <div class="cardHead">
          <h2>카카오지도 기반 조회</h2>
          <span class="pill" id="pillData">데이터: 0건</span>
        </div>
        <div class="cardBody">
          <div class="searchRow">
            <input class="input" id="q" placeholder="검색: 예) 영등포구 / 대림동 / 용인시 수지구 / 투네스트" />
            <button class="btn" id="btnSearch">검색</button>
          </div>

          <div class="mapWrap">
            <div class="mapBox">
              <div class="levelTag" id="geoLevelTag">경계: 시/도</div>
              <div class="mapTopRight">
                <button class="miniBtn" id="btnGeoUp">한 단계 위</button>
                <button class="miniBtn" id="btnGeoReload">경계 다시 불러오기</button>
              </div>
              <div id="kakaoMap"></div>

              <div class="hint" style="padding:10px 12px;">
                운영용으로는 반드시 실제 행정경계 GeoJSON을 넣어야 합니다.<br/>
                경계 파일이 없으면(404) 지도는 뜨지만 폴리곤이 없습니다.
              </div>
            </div>

            <div class="side">
              <div class="crumbs" id="crumbs"></div>
              <div class="chips" id="vendorChips"></div>

              <div id="panelTitle" style="font-weight:900; margin:4px 0 6px;">목록</div>
              <div class="list" id="list"></div>

              <details>
                <summary>데이터 입력/수정 (관리용)</summary>
                <div style="margin-top:10px">
                  <textarea class="textarea" id="raw"></textarea>
                  <div class="rowBtns">
                    <button class="btn primary" id="btnParse">파싱/적용</button>
                    <button class="btn" id="btnLoadSample">샘플 로드</button>
                    <button class="btn" id="btnExport">유니크 목록 내보내기</button>
                  </div>
                  <div class="footNote">
                    입력 포맷(권장):<br/>
                    - <b>[시/도] [시/군/구] [동] | [업체명]</b><br/>
                    - 지금처럼 “영등포구 대림동”만 들어오면 일부는 자동추론(서울 일부 등), 불확실하면 “(미분류)”로 들어갑니다.<br/>
                    - 동일 라인이 여러 번이면 <b>카운트</b>로 집계됩니다.
                  </div>
                  <div class="statLine" id="stats"></div>
                </div>
              </details>
            </div>
          </div>
        </div>
      </div>

      <!-- Right -->
      <div class="card">
        <div class="cardHead">
          <h2>현재 선택 상세</h2>
          <span class="pill" id="pillSel">전체</span>
        </div>
        <div class="cardBody">
          <div id="detail" class="empty">좌측에서 경계를 클릭하거나 목록을 클릭하거나 검색하세요.</div>

          <div style="height:12px"></div>
          <div class="hint">
            구현 의도(원하신 로직):<br/>
            - “서울특별시” 클릭 시: 서울 내 모든 업체(예: 마루웰/투네스트) 집계 노출<br/>
            - “강서구” 클릭 시: 강서구에 있는 업체만 노출<br/>
            - “염창동” 클릭 시: 해당 동에 있는 업체만 노출
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  /* =========================
     0) Config: 경계 파일 경로
     ========================= */
  const GEO_BASE = "/coupangland/geo"; // 여기에 geojson 올리면 됨

  // 시/도명 -> 파일키(슬러그) 매핑 (필요시 추가/수정)
  const SIDO_TO_KEY = {
    "서울특별시": "seoul",
    "부산광역시": "busan",
    "대구광역시": "daegu",
    "인천광역시": "incheon",
    "광주광역시": "gwangju",
    "대전광역시": "daejeon",
    "울산광역시": "ulsan",
    "세종특별자치시": "sejong",
    "경기도": "gyeonggi",
    "강원특별자치도": "gangwon",
    "충청북도": "chungbuk",
    "충청남도": "chungnam",
    "전북특별자치도": "jeonbuk",
    "전라남도": "jeonnam",
    "경상북도": "gyeongbuk",
    "경상남도": "gyeongnam",
    "제주특별자치도": "jeju",
  };

  // “시/군/구 key”는 데이터 소스마다 다릅니다.
  // 1차 MVP는 파일명을 “한글 그대로” 쓰지 말고, 아래처럼 SIGUNGU_KEY_MAP에 대응시키는 걸 권장.
  // 예: 서울 영등포구 -> "yeongdeungpo"
  // 실제 파일을 만들기 전까진 비워둬도 됩니다(그러면 동 레벨 로드만 실패하고 시군구까지는 가능).
  const SIGUNGU_KEY_MAP = {
    "서울특별시|영등포구": "yeongdeungpo",
    "서울특별시|강서구": "gangseo",
    "대구광역시|중구": "jung-gu",
    "경기도|용인시 수지구": "yongin-suji",
    "경기도|성남시 분당구": "seongnam-bundang",
  };

  const LS_KEY = "mw_coupangland_routes_v2_kakao";

  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));

  const el = {
    pillData: $("#pillData"),
    pillSel: $("#pillSel"),
    q: $("#q"),
    btnSearch: $("#btnSearch"),
    btnReset: $("#btnReset"),
    btnCopy: $("#btnCopy"),
    btnClear: $("#btnClear"),
    crumbs: $("#crumbs"),
    vendorChips: $("#vendorChips"),
    panelTitle: $("#panelTitle"),
    list: $("#list"),
    detail: $("#detail"),
    raw: $("#raw"),
    btnParse: $("#btnParse"),
    btnLoadSample: $("#btnLoadSample"),
    btnExport: $("#btnExport"),
    stats: $("#stats"),
    toast: $("#toast"),
    geoLevelTag: $("#geoLevelTag"),
    btnGeoUp: $("#btnGeoUp"),
    btnGeoReload: $("#btnGeoReload"),
  };

  /* =========================
     1) Toast
     ========================= */
  function toast(msg, tone="info"){
    el.toast.textContent = msg;
    el.toast.classList.add("show");
    el.toast.style.borderColor = tone==="danger" ? "rgba(255,77,79,.45)" : "rgba(110,231,255,.35)";
    el.toast.style.background = tone==="danger" ? "rgba(40,10,12,.92)" : "rgba(10,16,32,.92)";
    clearTimeout(toast._t);
    toast._t = setTimeout(()=> el.toast.classList.remove("show"), 1900);
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (m) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  /* =========================
     2) 데이터 파싱(라우트 현황)
     ========================= */
  const SIDO_ALIAS = new Map([
    ["서울시","서울특별시"], ["서울","서울특별시"],
    ["부산시","부산광역시"], ["부산","부산광역시"],
    ["대구시","대구광역시"], ["대구","대구광역시"],
    ["인천시","인천광역시"], ["인천","인천광역시"],
    ["광주시","광주광역시"], ["광주","광주광역시"],
    ["대전시","대전광역시"], ["대전","대전광역시"],
    ["울산시","울산광역시"], ["울산","울산광역시"],
    ["세종","세종특별자치시"],
    ["강원도","강원특별자치도"],
    ["전북","전북특별자치도"], ["전라북도","전북특별자치도"],
    ["제주도","제주특별자치도"], ["제주","제주특별자치도"],
  ]);

  // 서울 25개 구(추론 강화)
  const SEOUL_GU = new Set([
    "강남구","강동구","강북구","강서구","관악구","광진구","구로구","금천구","노원구","도봉구",
    "동대문구","동작구","마포구","서대문구","서초구","성동구","성북구","송파구","양천구","영등포구",
    "용산구","은평구","종로구","중구","중랑구"
  ]);

  // 광역시 구 추론(중구/서구 등은 충돌 가능해서 광역시+구 형태면 확정, 구 단독은 보수적으로 처리)
  const METRO_SIDO = new Set(["부산광역시","대구광역시","인천광역시","광주광역시","대전광역시","울산광역시","서울특별시"]);

  const CITY_TO_SIDO = new Map([
    ["용인시","경기도"],
    ["성남시","경기도"],
    ["수원시","경기도"],
    ["고양시","경기도"],
    ["대구시","대구광역시"],
  ]);

  function normalizeSido(s){
    if(!s) return s;
    s = s.trim();
    return SIDO_ALIAS.get(s) || s;
  }

  function splitVendor(line){
    const raw = line.trim();
    if(!raw) return null;

    let loc = raw, vendor = "";
    if(raw.includes("|")){
      const parts = raw.split("|");
      loc = (parts[0] || "").trim();
      vendor = (parts.slice(1).join("|") || "").trim();
    } else if(raw.includes("\t")){
      const parts = raw.split("\t");
      loc = (parts[0] || "").trim();
      vendor = (parts.slice(1).join("\t") || "").trim();
    } else if(raw.includes(",")){
      const parts = raw.split(",");
      if(parts.length >= 2 && (parts[0].trim().split(/\s+/).length >= 2)) {
        loc = parts[0].trim();
        vendor = parts.slice(1).join(",").trim();
      }
    }

    vendor = vendor || "마루웰(기본)";
    return { loc, vendor };
  }

  function parseLocation(loc){
    // 목표: {sido, sigungu, dong}
    const tokens = (loc || "").trim().split(/\s+/).filter(Boolean);
    if(tokens.length === 0) return null;

    // 1) 첫 토큰이 시도면 확정
    const t0 = normalizeSido(tokens[0]);
    const isSidoToken = (
      Object.prototype.hasOwnProperty.call(SIDO_TO_KEY, t0) ||
      t0.endsWith("도") || t0.endsWith("특별시") || t0.endsWith("광역시") || t0.endsWith("특별자치시") || t0.endsWith("특별자치도")
    );
    if(isSidoToken){
      const sido = t0;
      if(tokens.length === 2) return { sido, sigungu: tokens[1], dong: null };
      if(tokens.length >= 3){
        const rest = tokens.slice(1);
        // "용인시 수지구 동천동" 같은 경우
        if(rest.length >= 2 && rest[0].endsWith("시") && rest[1].endsWith("구")){
          return { sido, sigungu: rest[0] + " " + rest[1], dong: rest.slice(2).join(" ") || null };
        }
        return { sido, sigungu: rest[0], dong: rest.slice(1).join(" ") || null };
      }
    }

    // 2) "영등포구 대림동" 같은 2토큰
    if(tokens.length === 2){
      let sigungu = tokens[0];
      const dong = tokens[1];

      if(SEOUL_GU.has(sigungu)){
        return { sido:"서울특별시", sigungu, dong };
      }
      // 기타 구는 미분류(충돌 가능성 때문)
      return { sido:"(미분류)", sigungu, dong };
    }

    // 3) "용인시 수지구 동천동" / "대구시 중구 칠성동"
    if(tokens.length >= 3){
      const a = tokens[0], b = tokens[1];
      const rest = tokens.slice(2).join(" ") || null;

      // 대구시/서울시 별칭이 앞에 오면 시도 추론
      const aNorm = normalizeSido(a);
      if(Object.prototype.hasOwnProperty.call(SIDO_TO_KEY, aNorm)){
        // 예: "대구시 중구 칠성동" -> sido=대구광역시, sigungu=중구
        return { sido: aNorm, sigungu: b, dong: rest };
      }

      // "용인시 수지구 동천동" -> sido=경기도
      if(a.endsWith("시") && b.endsWith("구")){
        const sido = CITY_TO_SIDO.get(a) || "(미분류)";
        return { sido, sigungu: a + " " + b, dong: rest };
      }

      // "성남시 분당구 대장동" 처럼
      if(a.endsWith("시") && b.endsWith("구")){
        const sido = CITY_TO_SIDO.get(a) || "(미분류)";
        return { sido, sigungu: a + " " + b, dong: rest };
      }

      // fallback
      return { sido:"(미분류)", sigungu: tokens.slice(0, tokens.length-1).join(" "), dong: tokens[tokens.length-1] };
    }

    return { sido:"(미분류)", sigungu: tokens[0], dong: tokens.slice(1).join(" ") || null };
  }

  function parseRaw(text){
    const lines = (text || "")
      .split(/\r?\n/)
      .map(s => s.trim())
      .filter(s => s && !s.startsWith("#") && !s.startsWith("//"));

    const map = new Map(); // vendor|sido|sigungu|dong -> count
    for(const line of lines){
      const sv = splitVendor(line);
      if(!sv) continue;
      const loc = parseLocation(sv.loc);
      if(!loc) continue;

      const vendor = (sv.vendor || "마루웰(기본)").trim();
      const sido = normalizeSido(loc.sido || "(미분류)");
      const sigungu = (loc.sigungu || "(미분류)").trim();
      const dong = (loc.dong || "(미분류)").trim();

      const key = vendor + "|" + sido + "|" + sigungu + "|" + dong;
      map.set(key, (map.get(key) || 0) + 1);
    }

    const entries = [];
    for(const [key, count] of map.entries()){
      const [vendor, sido, sigungu, dong] = key.split("|");
      entries.push({ vendor, sido, sigungu, dong, count });
    }
    return entries;
  }

  function sampleText(){
    return [
      "영등포구 대림동 | 마루웰",
      "영등포구 대림동 | 마루웰",
      "영등포구 대림동 | 투네스트",
      "영등포구 신길동 | 마루웰",
      "영등포구 신길동 | 마루웰",
      "경기도 성남시 분당구 대장동 | 마루웰",
      "용인시 수지구 동천동 | 투네스트",
      "용인시 수지구 동천동 | 투네스트",
      "대구시 중구 칠성동 | 마루웰",
      "대구시 중구 동인동 | 마루웰",
      "대구시 중구 동인동 | 투네스트",
      "서울시 강서구 염창동 | 투네스트"
    ].join("\n");
  }

  function saveEntries(entries){ localStorage.setItem(LS_KEY, JSON.stringify(entries)); }
  function loadEntries(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return null;
      const data = JSON.parse(raw);
      if(!Array.isArray(data)) return null;
      return data;
    }catch(e){ return null; }
  }

  /* =========================
     3) 상태(State)
     ========================= */
  const state = {
    entries: [],
    // 선택
    sido: null,
    sigungu: null,
    dong: null,
    vendor: null,

    // 검색 모드
    searchMode: false,
    searchResults: [],

    // 지도 경계 레벨
    geoLevel: "sido", // "sido" | "sigungu" | "dong"
  };

  function selectionLabel(){
    const parts = [];
    if(state.sido) parts.push(state.sido);
    if(state.sigungu) parts.push(state.sigungu);
    if(state.dong) parts.push(state.dong);
    return parts.length ? parts.join(" > ") : "전체";
  }

  function withinSelection(e){
    if(state.sido && e.sido !== state.sido) return false;
    if(state.sigungu && e.sigungu !== state.sigungu) return false;
    if(state.dong && e.dong !== state.dong) return false;
    if(state.vendor && e.vendor !== state.vendor) return false;
    return true;
  }

  function filteredEntries(){
    return state.entries.filter(withinSelection);
  }

  function groupBy(entries, keyFn){
    const m = new Map();
    for(const e of entries){
      const k = keyFn(e);
      const prev = m.get(k) || { key:k, count:0, vendors:new Set() };
      prev.count += e.count;
      prev.vendors.add(e.vendor);
      m.set(k, prev);
    }
    return Array.from(m.values());
  }

  function uiLevel(){
    // UI 드릴다운은 데이터 기준
    if(!state.sido) return "sido";
    if(!state.sigungu) return "sigungu";
    if(!state.dong) return "dong";
    return "detail";
  }

  /* =========================
     4) Kakao 지도 + GeoJSON Polygon Renderer
     ========================= */
  let map = null;
  let geoPolygons = [];    // kakao.maps.Polygon[]
  let geoOverlays = [];    // kakao.maps.CustomOverlay[]
  let lastGeoFeatures = []; // 최근 렌더링한 feature 메타(이름/키/카운트/센터 등)

  function clearGeo(){
    geoPolygons.forEach(p => p.setMap(null));
    geoOverlays.forEach(o => o.setMap(null));
    geoPolygons = [];
    geoOverlays = [];
    lastGeoFeatures = [];
  }

  function getFeatureName(props){
    // 다양한 GeoJSON 소스 대응
    return (
      props.CTP_KOR_NM || props.SIG_KOR_NM || props.EMD_KOR_NM ||
      props.name || props.NAME_1 || props.NAME_2 || props.NAME ||
      props.sido || props.sigungu || props.dong ||
      ""
    ).trim();
  }

  function normalizeRegionNameByLevel(level, rawName, sidoContext){
    let name = (rawName || "").trim();
    if(!name) return name;

    // 시도 레벨이면 alias 정규화
    if(level === "sido"){
      name = normalizeSido(name);
      // 일부 데이터는 "강원도" 같은 걸로 올 수 있어 alias에서 처리됨
      return name;
    }

    // sigungu 레벨에서는 “서울특별시” 컨텍스트가 있으면 "영등포구"처럼 유지,
    // 경기도는 "용인시 수지구"처럼 데이터 파서와 맞추는 게 중요
    // (여기는 데이터 소스에 따라 다르니, 필요 시 규칙 확장)
    if(level === "sigungu"){
      // 예: GeoJSON이 "수지구"만 주는 경우, 경기도 용인시 컨텍스트가 없으면 조인이 어려움.
      // 운영에서는 GeoJSON properties에 상위명(시) 또는 법정코드를 포함한 소스를 쓰는 걸 권장.
      return name;
    }

    if(level === "dong"){
      return name;
    }

    return name;
  }

  function latLngFromCoord(coord){
    // GeoJSON: [lng, lat]
    return new kakao.maps.LatLng(coord[1], coord[0]);
  }

  function geomToPaths(geometry){
    // 반환: kakao.maps.Polygon path 형식
    // - Polygon: [ [LatLng...], [hole...], ... ]
    // - MultiPolygon: [ [ [LatLng...], ... ], ... ]
    if(!geometry) return null;

    if(geometry.type === "Polygon"){
      return geometry.coordinates.map(ring => ring.map(latLngFromCoord));
    }
    if(geometry.type === "MultiPolygon"){
      return geometry.coordinates.map(poly => poly.map(ring => ring.map(latLngFromCoord)));
    }
    return null;
  }

  function computeBoundsFromPaths(path){
    // path가 Polygon 혹은 MultiPolygon 중첩 배열일 수 있음
    const bounds = new kakao.maps.LatLngBounds();

    const walk = (node) => {
      if(!node) return;
      // LatLng이면 has getLat/getLng
      if(typeof node.getLat === "function"){
        bounds.extend(node);
        return;
      }
      if(Array.isArray(node)){
        node.forEach(walk);
      }
    };
    walk(path);
    return bounds;
  }

  function heatColorByRatio(r){
    // r: 0..1 (1이 뜨거움)
    // 임의: r에 따라 fillOpacity/색상 변경
    // 카카오 폴리곤은 hex 지정
    // 여기서는 r에 따라 밝기만 변경(보라 계열)
    const base = { r:124, g:92, b:255 };
    const dark = { r:60, g:40, b:140 };
    const mix = (a,b,t)=> Math.round(a + (b-a)*t);
    const rr = mix(dark.r, base.r, r);
    const gg = mix(dark.g, base.g, r);
    const bb = mix(dark.b, base.b, r);
    return "#" + [rr,gg,bb].map(x => x.toString(16).padStart(2,"0")).join("");
  }

  function countForFeature(level, featName, sidoContext){
    // 현재 데이터 + 선택 vendor 필터를 고려한 집계
    // level별 조인 키
    const scope = state.entries.filter(e => {
      // vendor 필터는 적용
      if(state.vendor && e.vendor !== state.vendor) return false;

      // 상위 선택(sido/sigungu/dong)도 적용 (geo 레벨과 상관없이 현재 선택을 우선)
      if(state.sido && e.sido !== state.sido) return false;
      if(state.sigungu && e.sigungu !== state.sigungu) return false;
      if(state.dong && e.dong !== state.dong) return false;

      return true;
    });

    const n = normalizeRegionNameByLevel(level, featName, sidoContext);

    if(level === "sido"){
      return scope.filter(e => e.sido === n).reduce((s,e)=> s+e.count, 0);
    }
    if(level === "sigungu"){
      // 시도 컨텍스트가 있으면 그 안에서만 찾는 게 안정적
      const sido = state.sido || sidoContext || null;
      return scope.filter(e => (!sido || e.sido === sido) && e.sigungu === n).reduce((s,e)=> s+e.count, 0);
    }
    if(level === "dong"){
      const sido = state.sido || sidoContext || null;
      const sig = state.sigungu || null;
      return scope.filter(e =>
        (!sido || e.sido === sido) &&
        (!sig || e.sigungu === sig) &&
        e.dong === n
      ).reduce((s,e)=> s+e.count, 0);
    }
    return 0;
  }

  async function fetchJson(url){
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  }

  function geoLevelLabel(level){
    if(level === "sido") return "시/도";
    if(level === "sigungu") return "시군구";
    if(level === "dong") return "동(읍면동)";
    return level;
  }

  function updateGeoLevelTag(){
    el.geoLevelTag.textContent = `경계: ${geoLevelLabel(state.geoLevel)}`;
  }

  function getSidoKey(sidoName){
    const n = normalizeSido(sidoName);
    return SIDO_TO_KEY[n] || null;
  }

  function getSigunguKey(sidoName, sigunguName){
    const k = SIGUNGU_KEY_MAP[`${sidoName}|${sigunguName}`];
    return k || null;
  }

  function geoUrlForLevel(level){
    if(level === "sido"){
      return `${GEO_BASE}/sido.geojson`;
    }
    if(level === "sigungu"){
      const sidoKey = getSidoKey(state.sido);
      if(!sidoKey) return null;
      return `${GEO_BASE}/sigungu/${sidoKey}.geojson`;
    }
    if(level === "dong"){
      const sidoKey = getSidoKey(state.sido);
      const sigKey = getSigunguKey(state.sido, state.sigungu);
      if(!sidoKey || !sigKey) return null;
      return `${GEO_BASE}/dong/${sidoKey}/${sigKey}.geojson`;
    }
    return null;
  }

  async function loadAndRenderGeo(){
    clearGeo();
    updateGeoLevelTag();

    const url = geoUrlForLevel(state.geoLevel);
    if(!url){
      // 파일키 매핑이 없어서 로드 불가
      if(state.geoLevel === "dong"){
        toast("동 경계 로드 실패: SIGUNGU_KEY_MAP 매핑/파일 경로 필요", "danger");
        return;
      }
      toast("경계 로드 실패: 시/도 선택 또는 파일 매핑 확인", "danger");
      return;
    }

    let geo;
    try{
      geo = await fetchJson(url);
    }catch(e){
      toast(`경계 파일 없음(404): ${url}`, "danger");
      return;
    }

    const features = Array.isArray(geo.features) ? geo.features : [];
    if(features.length === 0){
      toast("경계 데이터가 비어있습니다(GeoJSON features 없음).", "danger");
      return;
    }

    // 카운트 집계로 heat/label 만들기 위해 max 구함
    const counts = [];
    for(const f of features){
      const rawName = getFeatureName(f.properties || {});
      const name = normalizeRegionNameByLevel(state.geoLevel, rawName, state.sido);
      const c = countForFeature(state.geoLevel, name, state.sido);
      counts.push(c);
    }
    const max = Math.max(1, ...counts);

    features.forEach((f, idx) => {
      const props = f.properties || {};
      const rawName = getFeatureName(props);
      const name = normalizeRegionNameByLevel(state.geoLevel, rawName, state.sido);
      const path = geomToPaths(f.geometry);
      if(!path) return;

      const c = counts[idx] || 0;
      const ratio = Math.min(1, c / max);

      const polygon = new kakao.maps.Polygon({
        path,
        strokeWeight: 2,
        strokeColor: ratio > 0 ? "rgba(110,231,255,.55)" : "rgba(255,255,255,.20)",
        strokeOpacity: 0.95,
        fillColor: ratio > 0 ? heatColorByRatio(Math.max(0.25, ratio)) : "#1b2437",
        fillOpacity: ratio > 0 ? (0.18 + ratio * 0.25) : 0.08,
      });

      polygon.setMap(map);

      const bounds = computeBoundsFromPaths(path);
      const center = bounds.getCenter();

      // label overlay (카운트가 0이어도 표시할지 여부: 0이면 숨김)
      let overlay = null;
      if(c > 0){
        const content = `<div class="mwLabel">${escapeHtml(name)} <span class="c">${c}</span></div>`;
        overlay = new kakao.maps.CustomOverlay({
          position: center,
          content,
          yAnchor: 1,
        });
        overlay.setMap(map);
        geoOverlays.push(overlay);
      }

      kakao.maps.event.addListener(polygon, "mouseover", () => {
        polygon.setOptions({ strokeWeight: 3, strokeColor: "rgba(167,139,250,.85)" });
      });
      kakao.maps.event.addListener(polygon, "mouseout", () => {
        polygon.setOptions({
          strokeWeight: 2,
          strokeColor: ratio > 0 ? "rgba(110,231,255,.55)" : "rgba(255,255,255,.20)",
        });
      });

      kakao.maps.event.addListener(polygon, "click", () => {
        // 선택 로직
        if(state.geoLevel === "sido"){
          state.searchMode = false; state.searchResults = [];
          state.sido = normalizeSido(name);
          state.sigungu = null; state.dong = null;
          // 시도 클릭 시: 다음 경계는 시군구
          state.geoLevel = "sigungu";
          // 줌/센터
          map.setBounds(bounds);
          update();
          loadAndRenderGeo();
          return;
        }

        if(state.geoLevel === "sigungu"){
          state.searchMode = false; state.searchResults = [];
          state.sigungu = name;
          state.dong = null;
          state.geoLevel = "dong";
          map.setBounds(bounds);
          update();
          loadAndRenderGeo();
          return;
        }

        if(state.geoLevel === "dong"){
          state.searchMode = false; state.searchResults = [];
          state.dong = name;
          map.setBounds(bounds);
          update();
          // 동 클릭은 더 내려갈 곳 없음
          return;
        }
      });

      geoPolygons.push(polygon);
      lastGeoFeatures.push({ name, count:c, center, bounds });
    });

    toast(`경계 로드 완료: ${geoLevelLabel(state.geoLevel)} (${features.length}개)`);
  }

  function geoUpOneLevel(){
    if(state.geoLevel === "dong"){
      state.geoLevel = "sigungu";
      state.dong = null;
      update();
      loadAndRenderGeo();
      return;
    }
    if(state.geoLevel === "sigungu"){
      state.geoLevel = "sido";
      state.sigungu = null;
      state.dong = null;
      state.sido = null;
      update();
      loadAndRenderGeo();
      return;
    }
    // sido면 그대로
    toast("이미 최상위(시/도)입니다.");
  }

  /* =========================
     5) UI 렌더링
     ========================= */
  function renderCrumbs(){
    el.crumbs.innerHTML = "";

    const add = (label, active, onClick) => {
      const b = document.createElement("button");
      b.className = "crumb" + (active ? " active" : "");
      b.textContent = label;
      b.type = "button";
      b.addEventListener("click", onClick);
      el.crumbs.appendChild(b);
    };

    add("전체", !state.sido && !state.searchMode, () => {
      state.searchMode = false;
      state.searchResults = [];
      state.sido = null; state.sigungu = null; state.dong = null;
      state.vendor = null;
      state.geoLevel = "sido";
      update();
      loadAndRenderGeo();
    });

    if(state.searchMode){
      add("검색결과", true, () => {});
      return;
    }

    if(state.sido){
      add(state.sido, !!state.sido && !state.sigungu, () => {
        state.sigungu = null; state.dong = null;
        state.vendor = null;
        state.geoLevel = "sigungu";
        update();
        loadAndRenderGeo();
      });
    }
    if(state.sigungu){
      add(state.sigungu, !!state.sigungu && !state.dong, () => {
        state.dong = null;
        state.vendor = null;
        state.geoLevel = "dong";
        update();
        loadAndRenderGeo();
      });
    }
    if(state.dong){
      add(state.dong, true, () => {});
    }
  }

  function renderVendorChips(){
    el.vendorChips.innerHTML = "";

    const base = state.searchMode ? state.searchResults : state.entries;
    const scope = base.filter(e => {
      if(state.searchMode) return true;
      if(state.sido && e.sido !== state.sido) return false;
      if(state.sigungu && e.sigungu !== state.sigungu) return false;
      if(state.dong && e.dong !== state.dong) return false;
      return true;
    });

    const groups = groupBy(scope, e => e.vendor).sort((a,b)=> b.count - a.count);

    const allCount = groups.reduce((s,g)=> s+g.count, 0);
    const allChip = document.createElement("button");
    allChip.type = "button";
    allChip.className = "chip" + (!state.vendor ? " active" : "");
    allChip.innerHTML = `<span>전체 업체</span><span class="badge">${allCount}</span>`;
    allChip.addEventListener("click", () => { state.vendor = null; update(); loadAndRenderGeo(); });
    el.vendorChips.appendChild(allChip);

    for(const g of groups){
      const c = document.createElement("button");
      c.type = "button";
      c.className = "chip" + (state.vendor === g.key ? " active" : "");
      c.innerHTML = `<span>${escapeHtml(g.key)}</span><span class="badge">${g.count}</span>`;
      c.addEventListener("click", () => {
        state.vendor = (state.vendor === g.key) ? null : g.key;
        update();
        loadAndRenderGeo(); // heat/label 갱신
      });
      el.vendorChips.appendChild(c);
    }
  }

  function makeItem(name, meta, count){
    const it = document.createElement("div");
    it.className = "item";
    it.innerHTML = `
      <div class="left">
        <div class="name">${escapeHtml(name)}</div>
        <div class="meta">${escapeHtml(meta)}</div>
      </div>
      <span class="badge">${count}</span>
    `;
    return it;
  }

  function renderList(){
    el.list.innerHTML = "";

    if(state.searchMode){
      el.panelTitle.textContent = "검색 결과";
      if(state.searchResults.length === 0){
        el.list.innerHTML = `<div class="empty">검색 결과가 없습니다.</div>`;
        return;
      }
      const sorted = [...state.searchResults].sort((a,b)=> b.count - a.count);
      for(const e of sorted.slice(0, 100)){
        const it = document.createElement("div");
        it.className = "item";
        it.innerHTML = `
          <div class="left">
            <div class="name">${escapeHtml(e.sido)} · ${escapeHtml(e.sigungu)} · ${escapeHtml(e.dong)}</div>
            <div class="meta">${escapeHtml(e.vendor)} · ${e.count}건</div>
          </div>
          <span class="badge">이동</span>
        `;
        it.addEventListener("click", () => {
          state.searchMode = false;
          state.searchResults = [];
          state.sido = e.sido;
          state.sigungu = e.sigungu;
          state.dong = e.dong;
          state.vendor = e.vendor;
          state.geoLevel = "dong";
          update();
          loadAndRenderGeo();
        });
        el.list.appendChild(it);
      }
      return;
    }

    const lvl = uiLevel();
    const scope = filteredEntries();

    if(lvl === "sido"){
      el.panelTitle.textContent = "시/도 (지도 클릭 또는 아래 목록)";
      const groups = groupBy(scope, e=> e.sido).sort((a,b)=> a.key.localeCompare(b.key,"ko"));
      for(const g of groups){
        const it = makeItem(g.key, `${g.vendors.size}개 업체 · ${g.count}건`, g.count);
        it.addEventListener("click", () => {
          state.sido = normalizeSido(g.key);
          state.sigungu = null; state.dong = null; state.vendor = null;
          state.geoLevel = "sigungu";
          update();
          loadAndRenderGeo();
        });
        el.list.appendChild(it);
      }
      return;
    }

    if(lvl === "sigungu"){
      el.panelTitle.textContent = "시/군/구";
      const groups = groupBy(scope, e=> e.sigungu).sort((a,b)=> b.count - a.count);
      for(const g of groups){
        const it = makeItem(g.key, `${g.vendors.size}개 업체 · ${g.count}건`, g.count);
        it.addEventListener("click", () => {
          state.sigungu = g.key; state.dong = null; state.vendor = null;
          state.geoLevel = "dong";
          update();
          loadAndRenderGeo();
        });
        el.list.appendChild(it);
      }
      if(groups.length === 0){
        el.list.innerHTML = `<div class="empty">선택된 시/도에 데이터가 없습니다.</div>`;
      }
      return;
    }

    if(lvl === "dong"){
      el.panelTitle.textContent = "동 (읍/면/동)";
      const groups = groupBy(scope, e=> e.dong).sort((a,b)=> b.count - a.count);
      for(const g of groups){
        const it = makeItem(g.key, `${g.vendors.size}개 업체 · ${g.count}건`, g.count);
        it.addEventListener("click", () => {
          state.dong = g.key;
          update();
        });
        el.list.appendChild(it);
      }
      if(groups.length === 0){
        el.list.innerHTML = `<div class="empty">선택된 시/군/구에 데이터가 없습니다.</div>`;
      }
      return;
    }

    // detail
    el.panelTitle.textContent = "동 상세 (업체별)";
    const byVendor = groupBy(scope, e=> e.vendor).sort((a,b)=> b.count - a.count);
    for(const g of byVendor){
      const it = makeItem(g.key, `총 ${g.count}건`, g.count);
      it.addEventListener("click", () => {
        state.vendor = (state.vendor === g.key) ? null : g.key;
        update();
        loadAndRenderGeo();
      });
      el.list.appendChild(it);
    }
    if(byVendor.length === 0){
      el.list.innerHTML = `<div class="empty">선택된 조건에 데이터가 없습니다.</div>`;
    }
  }

  function renderDetail(){
    const scope = filteredEntries();
    const total = scope.reduce((s,e)=> s+e.count, 0);

    el.pillSel.textContent = selectionLabel() + (state.vendor ? ` · ${state.vendor}` : "");
    if(total === 0){
      el.detail.className = "empty";
      el.detail.innerHTML = "선택된 조건에 데이터가 없습니다.";
      return;
    }

    const uniqDong = new Set(scope.map(e=> e.dong)).size;
    const uniqSigungu = new Set(scope.map(e=> e.sigungu)).size;
    const uniqSido = new Set(scope.map(e=> e.sido)).size;
    const vendors = groupBy(scope, e=> e.vendor).sort((a,b)=> b.count - a.count);

    const topLines = vendors.slice(0, 8)
      .map(v => `<div style="display:flex; justify-content:space-between; gap:10px; padding:8px 10px; border:1px solid var(--line); border-radius:12px; background: rgba(255,255,255,.04);">
                  <div style="font-weight:900; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${escapeHtml(v.key)}</div>
                  <div style="color:var(--muted); font-weight:900;">${v.count}건</div>
                </div>`).join("");

    el.detail.className = "";
    el.detail.innerHTML = `
      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;">
        <div class="pill"><b>${total}</b> 건</div>
        <div class="pill">시/도 <b>${uniqSido}</b></div>
        <div class="pill">시/군/구 <b>${uniqSigungu}</b></div>
        <div class="pill">동 <b>${uniqDong}</b></div>
        <div class="pill">업체 <b>${vendors.length}</b></div>
      </div>

      <div style="font-weight:900; margin:10px 0 8px;">업체별 집계</div>
      <div style="display:flex; flex-direction:column; gap:8px;">${topLines}</div>
      <div style="height:10px"></div>
      <div class="hint">
        지도 경계(GeoJSON)와 라우트 데이터의 “명칭”이 맞아야 자동 조인이 됩니다.<br/>
        (예: 데이터는 “용인시 수지구”, 경계는 “수지구”만 주면 매칭 실패 가능)
      </div>
    `;
  }

  function refreshStats(){
    const totalRaw = (el.raw.value || "").split(/\r?\n/).filter(s=>s.trim()).length;
    const uniq = state.entries.length;
    const vendors = new Set(state.entries.map(e=>e.vendor)).size;
    el.stats.innerHTML = `
      <span>원본 라인 <b>${totalRaw}</b></span>
      <span>유니크(업체+지역) <b>${uniq}</b></span>
      <span>업체수 <b>${vendors}</b></span>
    `;
  }

  function applyEntries(entries){
    state.entries = entries;
    saveEntries(entries);

    // 데이터 바뀌면 선택이 유효한지 최소 검증
    const exists = (key, val) => entries.some(e => e[key] === val);
    if(state.sido && !exists("sido", state.sido)) state.sido = null;
    if(state.sigungu && !exists("sigungu", state.sigungu)) state.sigungu = null;
    if(state.dong && !exists("dong", state.dong)) state.dong = null;
    if(state.vendor && !exists("vendor", state.vendor)) state.vendor = null;

    update();
    loadAndRenderGeo(); // heat/label 갱신
  }

  function doSearch(){
    const q = (el.q.value || "").trim();
    if(!q){ toast("검색어를 입력하세요."); return; }
    const ql = q.toLowerCase();
    const hits = state.entries.filter(e =>
      (e.sido||"").toLowerCase().includes(ql) ||
      (e.sigungu||"").toLowerCase().includes(ql) ||
      (e.dong||"").toLowerCase().includes(ql) ||
      (e.vendor||"").toLowerCase().includes(ql)
    );

    state.searchMode = true;
    state.searchResults = hits;
    state.vendor = null;
    update();
    toast(`검색 결과 ${hits.length}건`);
  }

  function update(){
    const total = state.entries.reduce((s,e)=> s+e.count, 0);
    el.pillData.textContent = `데이터: ${total}건`;
    el.pillSel.textContent = selectionLabel() + (state.vendor ? ` · ${state.vendor}` : "");

    renderCrumbs();
    renderVendorChips();
    renderList();
    renderDetail();
    refreshStats();
    updateGeoLevelTag();
  }

  /* =========================
     6) 이벤트 바인딩
     ========================= */
  function bind(){
    el.btnSearch.addEventListener("click", doSearch);
    el.q.addEventListener("keydown", (e)=> { if(e.key === "Enter") doSearch(); });

    el.btnReset.addEventListener("click", () => {
      state.searchMode = false;
      state.searchResults = [];
      state.sido = null; state.sigungu = null; state.dong = null;
      state.vendor = null;
      state.geoLevel = "sido";
      update();
      loadAndRenderGeo();
      toast("전체 보기로 초기화");
    });

    el.btnCopy.addEventListener("click", async () => {
      const scope = filteredEntries();
      const total = scope.reduce((s,e)=> s+e.count, 0);
      const vendors = groupBy(scope, e=> e.vendor).sort((a,b)=> b.count - a.count);
      const lines = [
        `[CoupangLand 요약]`,
        `선택: ${selectionLabel()}${state.vendor ? " · "+state.vendor : ""}`,
        `총 ${total}건`,
        `업체: ` + vendors.map(v=> `${v.key}(${v.count})`).join(", "),
      ];
      try{
        await navigator.clipboard.writeText(lines.join("\n"));
        toast("요약을 클립보드에 복사했습니다.");
      }catch(e){
        toast("복사 실패(브라우저 권한 확인).", "danger");
      }
    });

    el.btnClear.addEventListener("click", () => {
      localStorage.removeItem(LS_KEY);
      state.entries = [];
      state.searchMode = false;
      state.searchResults = [];
      state.sido = null; state.sigungu = null; state.dong = null;
      state.vendor = null;
      state.geoLevel = "sido";
      el.raw.value = "";
      update();
      clearGeo();
      toast("데이터를 초기화했습니다.", "danger");
    });

    el.btnParse.addEventListener("click", () => {
      const entries = parseRaw(el.raw.value || "");
      applyEntries(entries);
      toast("파싱/적용 완료");
    });

    el.btnLoadSample.addEventListener("click", () => {
      el.raw.value = sampleText();
      toast("샘플을 로드했습니다.");
      refreshStats();
    });

    el.btnExport.addEventListener("click", async () => {
      const rows = state.entries
        .slice()
        .sort((a,b)=> (a.sido+b.sigungu+b.dong+a.vendor).localeCompare(b.sido+b.sigungu+b.dong+a.vendor))
        .map(e => `${e.sido}\t${e.sigungu}\t${e.dong}\t${e.vendor}\t${e.count}`);
      const out = ["sido\tsigungu\tdong\tvendor\tcount", ...rows].join("\n");
      try{
        await navigator.clipboard.writeText(out);
        toast("유니크 목록(TSV)을 복사했습니다.");
      }catch(e){
        toast("내보내기 실패(브라우저 권한 확인).", "danger");
      }
    });

    el.btnGeoUp.addEventListener("click", geoUpOneLevel);
    el.btnGeoReload.addEventListener("click", loadAndRenderGeo);
  }

  /* =========================
     7) 부트스트랩
     ========================= */
  function initMap(){
    // Kakao Map 초기화
    map = new kakao.maps.Map($("#kakaoMap"), {
      center: new kakao.maps.LatLng(36.45, 127.85),
      level: 13
    });

    // 확대/축소 컨트롤
    const zoomControl = new kakao.maps.ZoomControl();
    map.addControl(zoomControl, kakao.maps.ControlPosition.RIGHT);

    // 기본 지도 타입 컨트롤(선택)
    const typeControl = new kakao.maps.MapTypeControl();
    map.addControl(typeControl, kakao.maps.ControlPosition.TOPRIGHT);
  }

  async function boot(){
    initMap();

    const saved = loadEntries();
    if(saved && saved.length){
      state.entries = saved;
      // 원본은 저장하지 않음(원하면 같이 저장하도록 바꿀 수 있음)
      el.raw.value = "";
    } else {
      el.raw.value = sampleText();
      state.entries = parseRaw(el.raw.value);
      saveEntries(state.entries);
    }

    bind();
    update();
    // 최초: 시/도 경계 로드
    await loadAndRenderGeo();
  }

  // DOM 준비 후 실행
  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
})();
</script>
</body>
</html>
