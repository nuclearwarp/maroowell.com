<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>마루웰 라우트 편집기</title>

  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a2d;
      --panel2:#0c1627;
      --txt:#e6eefc;
      --muted:#93a4c7;
      --line:rgba(255,255,255,.08);
      --btn:#162744;
      --btn2:#1a2f55;
      --danger:#6b1b1b;
      --ok:#1a5a3a;
      --warn:#6a4b13;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; background:#0a0f1a;}
    .wrap{display:flex; height:100%;}
    .left{
      width:360px; min-width:340px; max-width:420px;
      background:linear-gradient(180deg,var(--bg),#070b13);
      color:var(--txt);
      border-right:1px solid var(--line);
      padding:14px 14px 10px 14px;
      overflow:auto;
    }
    .title{font-size:18px; font-weight:800; letter-spacing:.2px; margin:2px 0 10px;}
    .subtitle{font-size:12px; color:var(--muted); margin:-6px 0 14px;}
    .group{background:rgba(255,255,255,.03); border:1px solid var(--line); border-radius:12px; padding:10px; margin:10px 0;}
    .label{font-size:12px; color:var(--muted); margin:6px 0 6px;}
    input[type="text"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
    }
    input[type="text"]:focus{border-color:rgba(255,255,255,.25)}
    .row{display:flex; gap:8px; align-items:center;}
    .row > *{flex:1}
    .btn{
      padding:10px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:var(--btn);
      color:var(--txt);
      cursor:pointer;
      font-weight:700;
      font-size:13px;
      white-space:nowrap;
    }
    .btn:hover{background:var(--btn2)}
    .btn.danger{background:rgba(107,27,27,.35); border-color:rgba(255,60,60,.22)}
    .btn.danger:hover{background:rgba(107,27,27,.55)}
    .btn.ok{background:rgba(26,90,58,.35); border-color:rgba(0,255,140,.18)}
    .btn.ok:hover{background:rgba(26,90,58,.55)}
    .btn.warn{background:rgba(106,75,19,.35); border-color:rgba(255,180,0,.18)}
    .btn.warn:hover{background:rgba(106,75,19,.55)}
    .help{font-size:12px; color:var(--muted); line-height:1.5; margin-top:8px;}
    .logWrap{
      border-radius:12px;
      border:1px solid var(--line);
      overflow:hidden;
      background:rgba(0,0,0,.25);
      margin-top:10px;
    }
    .logHeader{
      padding:8px 10px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between;
      font-size:12px; color:var(--muted);
    }
    .log{
      height:170px;
      overflow:auto;
      padding:8px 10px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      white-space:pre-wrap;
      color:#d9e5ff;
    }
    .pill{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      font-size:12px;
      color:var(--muted);
    }
    .map{flex:1; position:relative;}
    #map{position:absolute; inset:0;}
    .floatingHint{
      position:absolute;
      top:10px; left:10px;
      background:rgba(0,0,0,.55);
      color:#fff;
      border:1px solid rgba(255,255,255,.14);
      border-radius:10px;
      padding:8px 10px;
      font-size:12px;
      max-width:520px;
      display:none;
      z-index:20;
    }
    .sep{height:1px; background:var(--line); margin:10px 0;}
    .small{font-size:11px; color:var(--muted);}
  </style>

  <!-- Kakao Maps (Drawing 라이브러리 제거: a.e is not a function 근원 차단) -->
  <!-- 본인 앱키로 교체 -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&autoload=false&libraries=services"></script>
</head>

<body>
<div class="wrap">
  <div class="left">
    <div class="title">마루웰 라우트 편집기</div>

    <div class="group">
      <div class="label">캠프 이름 (예: 평양1)</div>
      <input id="campInput" type="text" value="일산2" />

      <div class="label">라우트 코드 (예: 101, 101A) — 비우면 camp 전체 표시</div>
      <input id="codeInput" type="text" value="126" />

      <div class="sep"></div>

      <div class="label">벤더 정보(서브라우트 단위)</div>
      <input id="vendorNameInput" type="text" placeholder="벤더 이름" />
      <div style="height:8px"></div>
      <input id="vendorBizInput" type="text" placeholder="사업자번호 (예: 259-15-01828)" />

      <div style="height:10px"></div>
      <div class="row">
        <button id="vendorSaveBtn" class="btn ok">벤더 저장(선택/입력코드)</button>
        <button id="vendorClearBtn" class="btn danger">벤더 비우기</button>
      </div>

      <div class="help">
        - 벤더 저장: 선택된 라우트(id)가 있으면 그 row 수정, 없으면 camp+code 기준 업서트<br/>
        - 벤더 검색 기능은 제외(요청사항 반영)
      </div>
    </div>

    <div class="group">
      <div class="row">
        <button id="loadBtn" class="btn">불러오기(GET)</button>
        <button id="drawNewBtn" class="btn warn">새로 그리기</button>
        <button id="drawAddBtn" class="btn warn">구역 추가</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="addrBtn" class="btn">주소검색</button>
        <button id="saveBtn" class="btn ok">저장(POST)</button>
        <button id="deletePolyBtn" class="btn danger">폴리곤 삭제</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="alignBtn" class="btn">지도 정렬(OSM)</button>
        <button id="labelToggleBtn" class="btn">라우트 라벨 ON</button>
        <button id="resetBtn" class="btn">지도 초기화</button>
      </div>

      <div class="help">
        - 편집: 지도에서 라우트(폴리곤) 클릭 → 꼭짓점 핸들 표시(드래그로 수정)<br/>
        - 새로 그리기: 지도 클릭으로 점 추가, <b>더블클릭</b>으로 완료, 우클릭으로 마지막 점 취소, ESC로 취소<br/>
        - 구역 추가: 같은 코드에 폴리곤을 하나 더 추가(다구역 지원)<br/>
        - 폴리곤 삭제: 해당 코드의 polygon_wgs84를 null로 저장(행 삭제 아님)
      </div>
    </div>

    <div class="logWrap">
      <div class="logHeader">
        <span class="pill" id="statusPill">READY</span>
        <span class="small" id="selectedInfo">선택: 없음</span>
      </div>
      <div class="log" id="log"></div>
    </div>

    <div class="help small" style="margin-top:10px;">
      - 문제 원인: DrawingManager.put / 잘못된 path 데이터 형태가 카카오 내부에서 a.e 호출로 터짐<br/>
      - 해결: Drawing 라이브러리 의존 제거 + LatLng 기반 편집기로 교체<br/>
      - API 오류: 백엔드에서 "subsubroutes.color" 컬럼을 찾지 못함 → 백엔드 SQL 쿼리 수정 필요
    </div>
  </div>

  <div class="map">
    <div id="map"></div>
    <div class="floatingHint" id="hint"></div>
  </div>
</div>

<script>
(() => {
  // ====== 환경 설정 ======
  const API_BASE = "https://route.maroowell.com"; // 필요시 변경
  const ROUTE_ENDPOINT = `${API_BASE}/route`;
  const OSM_ENDPOINT = `${API_BASE}/osm`;

  // ====== DOM ======
  const $ = (id) => document.getElementById(id);
  const campInput = $("campInput");
  const codeInput = $("codeInput");
  const vendorNameInput = $("vendorNameInput");
  const vendorBizInput = $("vendorBizInput");

  const loadBtn = $("loadBtn");
  const drawNewBtn = $("drawNewBtn");
  const drawAddBtn = $("drawAddBtn");
  const addrBtn = $("addrBtn");
  const saveBtn = $("saveBtn");
  const deletePolyBtn = $("deletePolyBtn");
  const alignBtn = $("alignBtn");
  const labelToggleBtn = $("labelToggleBtn");
  const resetBtn = $("resetBtn");
  const vendorSaveBtn = $("vendorSaveBtn");
  const vendorClearBtn = $("vendorClearBtn");

  const logEl = $("log");
  const statusPill = $("statusPill");
  const selectedInfo = $("selectedInfo");
  const hintEl = $("hint");

  // ====== 로그 ======
  const ts = () => {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    const ss = String(d.getSeconds()).padStart(2,"0");
    return `[${hh}:${mm}:${ss}]`;
  };
  function setStatus(t, kind="READY") {
    statusPill.textContent = kind;
    statusPill.style.borderColor =
      kind === "ERR" ? "rgba(255,60,60,.35)" :
      kind === "WARN" ? "rgba(255,180,0,.30)" :
      kind === "OK" ? "rgba(0,255,140,.22)" :
      "rgba(255,255,255,.10)";
    statusPill.style.background =
      kind === "ERR" ? "rgba(255,60,60,.12)" :
      kind === "WARN" ? "rgba(255,180,0,.10)" :
      kind === "OK" ? "rgba(0,255,140,.08)" :
      "rgba(255,255,255,.04)";
    if (t) log(`${kind} ${t}`);
  }
  function log(msg) {
    logEl.textContent += `${ts()} ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function hint(msg, show=true) {
    hintEl.textContent = msg;
    hintEl.style.display = show ? "block" : "none";
  }

  // ====== 상태 ======
  let map, geocoder;

  /** @type {Array<any>} */
  let routeRows = []; // API에서 받은 row들

  /**
   * rowId -> { row, polygons: kakao.maps.Polygon[], labels: kakao.maps.CustomOverlay[] }
   */
  const overlayById = new Map();

  // 편집(버텍스 핸들) 상태
  let selectedRouteId = null;
  let editHandles = []; // kakao.maps.Marker[]
  let editPolygons = []; // kakao.maps.Polygon[]
  let labelOn = true;

  // 그리기 상태
  let drawMode = null; // "new" | "add" | null
  let drawPoints = []; // kakao.maps.LatLng[]
  let drawMarkers = []; // kakao.maps.Marker[]
  let drawLine = null; // kakao.maps.Polyline

  // OSM 오버레이
  let osmOverlays = [];

  // ====== 컬러 팔레트(인접 색 구분 강화) ======
  // (Hue 균등 + 대비 큰 팔레트)
  const COLOR_PALETTE = [
    "#00C2FF", "#FF4D6D", "#FFD166", "#06D6A0", "#A78BFA",
    "#F97316", "#22C55E", "#E11D48", "#3B82F6", "#F59E0B",
    "#14B8A6", "#8B5CF6", "#84CC16", "#EC4899", "#0EA5E9",
    "#EF4444", "#10B981", "#FBBF24", "#6366F1", "#FB7185"
  ];
  function hashCode(str) {
    let h = 0;
    for (let i=0;i<str.length;i++){
      h = (h<<5) - h + str.charCodeAt(i);
      h |= 0;
    }
    return Math.abs(h);
  }
  function colorFor(code) {
    const idx = hashCode(code) % COLOR_PALETTE.length;
    return COLOR_PALETTE[idx];
  }

  // ====== API ======
  async function apiGet(url) {
    const res = await fetch(url, { method:"GET" });
    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}
    if (!res.ok) {
      const msg = json?.error || text || `HTTP ${res.status}`;
      throw new Error(msg);
    }
    return json;
  }
  async function apiJson(method, url, body) {
    const res = await fetch(url, {
      method,
      headers: { "Content-Type":"application/json" },
      body: body ? JSON.stringify(body) : undefined
    });
    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}
    if (!res.ok) {
      const msg = json?.error || text || `HTTP ${res.status}`;
      throw new Error(msg);
    }
    return json;
  }

  // ====== 유틸: polygon_wgs84 파싱 ======
  function parsePolygonWgs84(v) {
    if (!v) return null;
    if (Array.isArray(v)) return v;
    if (typeof v === "string") {
      try {
        const p = JSON.parse(v);
        if (Array.isArray(p)) return p;
      } catch {}
    }
    return null;
  }

  // ====== 지도 오버레이 정리 ======
  function clearAllOverlays() {
    stopEditing();
    stopDraw(true);
    clearOsm();

    for (const {polygons, labels} of overlayById.values()) {
      polygons.forEach(p => p.setMap(null));
      labels.forEach(l => l.setMap(null));
    }
    overlayById.clear();
    routeRows = [];
    selectedRouteId = null;
    selectedInfo.textContent = "선택: 없음";
  }

  function clearOsm() {
    osmOverlays.forEach(o => o.setMap(null));
    osmOverlays = [];
  }

  // ====== 라벨 ======
  function centroidOfLatLngs(latlngs) {
    let latSum=0, lngSum=0;
    for (const ll of latlngs) { latSum += ll.getLat(); lngSum += ll.getLng(); }
    return new kakao.maps.LatLng(latSum/latlngs.length, lngSum/latlngs.length);
  }
  function createLabelOverlay(text, position, color) {
    const el = document.createElement("div");
    el.style.padding = "4px 8px";
    el.style.borderRadius = "999px";
    el.style.background = "rgba(0,0,0,.55)";
    el.style.color = "#fff";
    el.style.fontSize = "12px";
    el.style.border = "1px solid rgba(255,255,255,.18)";
    el.style.whiteSpace = "nowrap";
    el.style.boxShadow = "0 2px 10px rgba(0,0,0,.35)";
    el.style.transform = "translateY(-2px)";
    el.innerHTML = `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color};margin-right:6px;vertical-align:middle;"></span>${escapeHtml(text)}`;

    return new kakao.maps.CustomOverlay({
      position,
      content: el,
      yAnchor: 1.0,
      zIndex: 10
    });
  }
  function escapeHtml(s) {
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ====== 폴리곤 생성 ======
  function makePolygon(latlngs, strokeColor, fillColor, zIndex=1) {
    return new kakao.maps.Polygon({
      path: latlngs, // 반드시 LatLng[]
      strokeWeight: 4,
      strokeColor,
      strokeOpacity: 0.9,
      strokeStyle: "solid",
      fillColor,
      fillOpacity: 0.25,
      zIndex
    });
  }

  // ====== 데이터 표시 ======
  function renderRoutes(rows) {
    clearAllOverlays();
    routeRows = rows || [];

    if (!routeRows.length) {
      setStatus("표시할 데이터가 없습니다.", "WARN");
      return;
    }

    let bounds = new kakao.maps.LatLngBounds();
    let any = false;

    for (const row of routeRows) {
      const id = row.id;
      const code = row.full_code || row.code || row.route_code || "";
      const camp = row.camp || row.camp_name || "";
      const color = row.color || colorFor(code);
      const poly = parsePolygonWgs84(row.polygon_wgs84);

      const polygons = [];
      const labels = [];

      if (poly && Array.isArray(poly) && poly.length > 0) {
        // poly: [ [ [lng,lat], ... ], [ [lng,lat], ... ] , ...]
        // 또는: [ [ {lat, lng}, ... ], [ {lat, lng}, ... ] , ...]
        for (let i=0;i<poly.length;i++) {
          const ring = poly[i];
          if (!Array.isArray(ring) || ring.length < 3) continue;

          // 두 형식 모두 지원: [lng, lat] 배열 또는 {lat, lng} 객체
          const latlngs = ring.map(pt => {
            if (pt && typeof pt === 'object' && 'lat' in pt && 'lng' in pt) {
              // {lat, lng} 형식
              return new kakao.maps.LatLng(pt.lat, pt.lng);
            } else if (Array.isArray(pt) && pt.length >= 2) {
              // [lng, lat] 형식
              return new kakao.maps.LatLng(pt[1], pt[0]);
            }
            return null;
          }).filter(ll => ll !== null);

          if (latlngs.length < 3) continue;

          const p = makePolygon(latlngs, color, color, 1);
          p.setMap(map);

          // 클릭으로 편집 진입
          kakao.maps.event.addListener(p, "click", () => {
            startEditing(id);
          });

          polygons.push(p);
          any = true;
          latlngs.forEach(ll => bounds.extend(ll));

          if (labelOn) {
            const c = centroidOfLatLngs(latlngs);
            const label = createLabelOverlay(code, c, color);
            label.setMap(map);
            labels.push(label);
          }
        }
      }

      overlayById.set(id, { row, polygons, labels });
    }

    if (any) {
      map.setBounds(bounds);
      setStatus(`불러오기 완료. 표시 ${routeRows.length}개`, "OK");
    } else {
      setStatus(`불러오기 완료. 표시 가능한 polygon_wgs84 row가 없습니다. (${routeRows.length}개)`, "WARN");
    }
  }

  // ====== 편집(버텍스 핸들) ======
  let VERTEX_IMG = null;
  let MID_IMG = null;

  function makeHandleImage(fill="#ffffff", stroke="#111827") {
    // SVG 데이터 URI
    const svg =
      `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18">
        <circle cx="9" cy="9" r="7" fill="${fill}" stroke="${stroke}" stroke-width="2"/>
      </svg>`;
    const uri = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    return new kakao.maps.MarkerImage(uri, new kakao.maps.Size(18,18), { offset: new kakao.maps.Point(9,9) });
  }

  function stopEditing() {
    editHandles.forEach(m => m.setMap(null));
    editHandles = [];
    editPolygons = [];

    // 선택 강조 해제(원복)
    for (const {row, polygons} of overlayById.values()) {
      const base = row.color || colorFor(row.full_code || "");
      polygons.forEach(p => {
        p.setOptions({
          strokeColor: base,
          fillColor: base,
          strokeWeight: 4,
          fillOpacity: 0.25,
          zIndex: 1
        });
      });
    }
  }

  function startEditing(routeId) {
    if (!overlayById.has(routeId)) return;

    stopDraw(true); // 그리기 중이면 중단
    stopEditing();

    selectedRouteId = routeId;
    const pack = overlayById.get(routeId);
    const { row, polygons } = pack;

    const code = row.full_code || "";
    const camp = row.camp || "";
    selectedInfo.textContent = `선택: ${camp} / ${code} (id=${routeId})`;

    // 벤더 UI 로드
    vendorNameInput.value = row.vendor || "";
    vendorBizInput.value = row.vendor_business_number || "";

    // 선택 폴리곤이 없으면(= polygon_wgs84 null) 편집할 게 없음 → 새로 그리기 유도
    if (!polygons || polygons.length === 0) {
      setStatus(`선택 대상 ${code}는 polygon이 없습니다. "새로 그리기"로 생성하세요.`, "WARN");
      return;
    }

    // 강조
    polygons.forEach(p => {
      p.setOptions({ strokeWeight: 6, fillOpacity: 0.30, zIndex: 5 });
    });

    editPolygons = polygons.slice();

    // 각 폴리곤별로 핸들 생성
    rebuildHandles();
    setStatus(`편집 모드: ${code} (꼭짓점 드래그로 수정)`, "OK");
  }

  function rebuildHandles() {
    // 기존 제거
    editHandles.forEach(m => m.setMap(null));
    editHandles = [];

    for (const polygon of editPolygons) {
      const path = polygon.getPath(); // kakao.maps.LatLng[]
      if (!path || path.length < 3) continue;

      // Vertex handles
      for (let i=0;i<path.length;i++) {
        const vMarker = new kakao.maps.Marker({
          position: path[i],
          draggable: true,
          image: VERTEX_IMG,
          zIndex: 20
        });
        vMarker.setMap(map);

        // 드래그 중/후 갱신
        kakao.maps.event.addListener(vMarker, "drag", () => {
          const newPos = vMarker.getPosition();
          const newPath = polygon.getPath();
          newPath.setAt(i, newPos);
          polygon.setPath(newPath);
          // 라벨 위치도 업데이트(선택된 라우트만)
          updateSelectedLabels();
        });
        kakao.maps.event.addListener(vMarker, "dragend", () => {
          rebuildHandles(); // 미드포인트 재생성 포함
        });

        // 우클릭: 점 삭제(최소 3개 유지)
        kakao.maps.event.addListener(vMarker, "rightclick", () => {
          const pth = polygon.getPath();
          if (pth.length <= 3) {
            setStatus("점 삭제 불가: 최소 3개 꼭짓점 유지 필요", "WARN");
            return;
          }
          pth.removeAt(i);
          polygon.setPath(pth);
          updateSelectedLabels();
          rebuildHandles();
        });

        editHandles.push(vMarker);
      }

      // Midpoint handles (점 추가)
      for (let i=0;i<path.length;i++) {
        const a = path[i];
        const b = path[(i+1)%path.length];

        const mid = new kakao.maps.LatLng(
          (a.getLat()+b.getLat())/2,
          (a.getLng()+b.getLng())/2
        );

        const midMarker = new kakao.maps.Marker({
          position: mid,
          clickable: true,
          image: MID_IMG,
          zIndex: 19
        });
        midMarker.setMap(map);

        kakao.maps.event.addListener(midMarker, "click", () => {
          const pth = polygon.getPath();
          pth.insertAt(i+1, mid);
          polygon.setPath(pth);
          updateSelectedLabels();
          rebuildHandles();
        });

        editHandles.push(midMarker);
      }
    }
  }

  function updateSelectedLabels() {
    if (!selectedRouteId) return;
    const pack = overlayById.get(selectedRouteId);
    if (!pack) return;
    const { row, polygons, labels } = pack;
    if (!labelOn) return;

    // 라벨 제거 후 재생성
    labels.forEach(l => l.setMap(null));
    pack.labels = [];

    const code = row.full_code || "";
    const color = row.color || colorFor(code);

    for (const p of polygons) {
      const path = p.getPath();
      if (!path || path.length < 3) continue;
      const c = centroidOfLatLngs(path);
      const label = createLabelOverlay(code, c, color);
      label.setMap(map);
      pack.labels.push(label);
    }
  }

  // ====== 그리기 모드 ======
  function stopDraw(silent=false) {
    drawMode = null;
    drawPoints = [];
    drawMarkers.forEach(m => m.setMap(null));
    drawMarkers = [];
    if (drawLine) { drawLine.setMap(null); drawLine = null; }
    if (!silent) hint("", false);
  }

  function beginDraw(mode) {
    const camp = campInput.value.trim();
    const code = codeInput.value.trim();
    if (!camp) { setStatus("camp가 비었습니다.", "ERR"); return; }
    if (!code) { setStatus("code가 비었습니다. (새로 그리기/구역 추가는 code 필수)", "ERR"); return; }

    stopEditing();
    stopDraw(true);

    drawMode = mode; // new | add
    drawPoints = [];
    drawMarkers = [];

    if (drawLine) drawLine.setMap(null);
    drawLine = new kakao.maps.Polyline({
      path: [],
      strokeWeight: 3,
      strokeColor: "#ffffff",
      strokeOpacity: 0.9,
      strokeStyle: "shortdash"
    });
    drawLine.setMap(map);

    hint("그리기 모드: 지도 클릭으로 점 추가 · 더블클릭으로 완료 · 우클릭으로 마지막 점 취소 · ESC로 취소", true);
    setStatus(mode === "new" ? "새로 그리기 시작" : "구역 추가 시작", "OK");
  }

  function addDrawPoint(latlng) {
    drawPoints.push(latlng);

    const m = new kakao.maps.Marker({
      position: latlng,
      zIndex: 30
    });
    m.setMap(map);
    drawMarkers.push(m);

    drawLine.setPath(drawPoints);
  }

  function popDrawPoint() {
    if (drawPoints.length === 0) return;
    drawPoints.pop();
    const m = drawMarkers.pop();
    if (m) m.setMap(null);
    drawLine.setPath(drawPoints);
  }

  function finishDraw() {
    if (drawPoints.length < 3) {
      setStatus("폴리곤 생성 실패: 점이 3개 이상 필요", "WARN");
      return;
    }

    const camp = campInput.value.trim();
    const code = codeInput.value.trim();
    const color = colorFor(code);

    // 선택 라우트 row가 있으면 그걸 기준으로. 없으면 camp+code로 가상의 row를 만든다고 생각(저장 시 업서트)
    let rowId = selectedRouteId;
    let row = null;

    if (rowId && overlayById.has(rowId)) {
      row = overlayById.get(rowId).row;
      // 선택된 row가 다른 코드면(입력 바꿨는데) 혼동 방지: 입력 code 우선
    }

    // 기존 폴리곤 제거(새로 그리기)
    if (drawMode === "new") {
      if (rowId && overlayById.has(rowId)) {
        const pack = overlayById.get(rowId);
        pack.polygons.forEach(p => p.setMap(null));
        pack.labels.forEach(l => l.setMap(null));
        pack.polygons = [];
        pack.labels = [];
      } else {
        // 선택이 없는데 새로 그리기면: 현재 camp+code와 매칭되는 row가 이미 로드되어 있으면 그걸 찾아 제거
        for (const [id, pack] of overlayById.entries()) {
          const r = pack.row;
          if ((r.camp||"") === camp && (r.full_code||"") === code) {
            rowId = id;
            pack.polygons.forEach(p => p.setMap(null));
            pack.labels.forEach(l => l.setMap(null));
            pack.polygons = [];
            pack.labels = [];
            break;
          }
        }
      }
    }

    // 폴리곤 생성
    const poly = makePolygon(drawPoints.slice(), color, color, 5);
    poly.setMap(map);
    kakao.maps.event.addListener(poly, "click", () => {
      // 클릭하면 편집 대상으로 유지
      if (rowId) startEditing(rowId);
    });

    // rowId가 없으면 임시로 생성(저장하면 실제 row 생김). 이 경우 id 맵핑이 없어서 편집 상태 관리를 위해 임시 ID를 부여.
    if (!rowId) {
      rowId = `tmp_${camp}_${code}`;
      // overlayById는 id key가 string이어도 됨(맵 기준)
      overlayById.set(rowId, {
        row: { id: rowId, camp, full_code: code, color, polygon_wgs84: null, vendor: vendorNameInput.value.trim(), vendor_business_number: vendorBizInput.value.trim() },
        polygons: [],
        labels: []
      });
    }

    const pack = overlayById.get(rowId);
    pack.row.camp = camp;
    pack.row.full_code = code;
    pack.row.color = color;

    pack.polygons.push(poly);

    if (labelOn) {
      const c = centroidOfLatLngs(drawPoints);
      const label = createLabelOverlay(code, c, color);
      label.setMap(map);
      pack.labels.push(label);
    }

    // 그리기 종료 -> 즉시 편집 모드로 전환
    stopDraw(true);
    selectedRouteId = rowId;
    selectedInfo.textContent = `선택: ${camp} / ${code} (id=${rowId})`;
    editPolygons = pack.polygons.slice();
    rebuildHandles();
    hint("", false);

    setStatus(`폴리곤 생성 완료: ${drawMode === "new" ? "교체" : "추가"} 1개`, "OK");
  }

  // ====== 저장 데이터 만들기 ======
  function getCurrentEditedPolygonWgs84ById(id) {
    const pack = overlayById.get(id);
    if (!pack) return null;
    const polys = pack.polygons;
    if (!polys || polys.length === 0) return null;

    // return: [ [ [lng,lat], ... ], [ [lng,lat], ... ] ]
    const out = [];
    for (const p of polys) {
      const path = p.getPath();
      if (!path || path.length < 3) continue;
      const ring = [];
      for (let i=0;i<path.length;i++) {
        const ll = path[i];
        ring.push([ ll.getLng(), ll.getLat() ]);
      }
      out.push(ring);
    }
    return out.length ? out : null;
  }

  // ====== 불러오기 ======
  async function loadRoutes() {
    try {
      stopEditing();
      stopDraw(true);
      clearOsm();

      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("camp가 비었습니다.", "ERR"); return; }

      const url = new URL(ROUTE_ENDPOINT);
      url.searchParams.set("camp", camp);
      url.searchParams.set("mode", "prefix");
      if (code) url.searchParams.set("code", code);

      setStatus(`GET /route 요청: ${url.toString()}`, "OK");
      const data = await apiGet(url.toString());
      
      if (!data || !data.rows) {
        setStatus("서버 응답 데이터가 올바르지 않습니다.", "ERR");
        log(`응답: ${JSON.stringify(data)}`);
        return;
      }
      
      renderRoutes(data.rows);

      // 입력한 code가 있고, 해당 row가 존재하면 자동 선택
      if (code) {
        for (const [id, pack] of overlayById.entries()) {
          if ((pack.row.camp||"") === camp && (pack.row.full_code||"") === code) {
            startEditing(id);
            break;
          }
        }
      }
    } catch (e) {
      console.error(e);
      const errMsg = e.message || String(e);
      if (errMsg.includes("column") && errMsg.includes("does not exist")) {
        setStatus(`데이터베이스 스키마 오류: ${errMsg}. 백엔드 API를 확인하세요.`, "ERR");
        log("힌트: 백엔드에서 존재하지 않는 컬럼을 참조하고 있습니다.");
        log("백엔드 서버의 SQL 쿼리와 데이터베이스 스키마를 확인하세요.");
      } else {
        setStatus(`불러오기 실패: ${errMsg}`, "ERR");
      }
    }
  }

  // ====== 저장(POST) ======
  async function saveCurrent() {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("camp가 비었습니다.", "ERR"); return; }
      if (!code) { setStatus("code가 비었습니다.", "ERR"); return; }

      // 선택된 id 기준으로 폴리곤 취합. 선택이 없으면 camp+code로 찾기
      let id = selectedRouteId;
      if (!id || !overlayById.has(id)) {
        // camp+code로 검색
        for (const [rid, pack] of overlayById.entries()) {
          if ((pack.row.camp||"") === camp && (pack.row.full_code||"") === code) {
            id = rid;
            break;
          }
        }
      }

      const polygon_wgs84 = id ? getCurrentEditedPolygonWgs84ById(id) : null;

      const payload = {
        id: (typeof id === "number" ? id : undefined), // tmp_면 제외
        camp,
        code,
        polygon_wgs84,
        color: colorFor(code),
        vendor: vendorNameInput.value.trim() || null,
        vendor_business_number: vendorBizInput.value.trim() || null
      };

      setStatus("POST /route 요청", "OK");
      const res = await apiJson("POST", ROUTE_ENDPOINT, payload);
      setStatus(`저장 완료`, "OK");

      // 저장 후 재조회(실제 id 반영)
      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`저장 실패: ${e.message}`, "ERR");
    }
  }

  // ====== 폴리곤 삭제 (polygon_wgs84=null) ======
  async function deletePolygon() {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("camp가 비었습니다.", "ERR"); return; }
      if (!code) { setStatus("code가 비었습니다.", "ERR"); return; }

      // 우선 선택 id가 숫자면 id로, 아니면 camp+code로
      let id = selectedRouteId;
      const payload = (typeof id === "number") ? { id } : { camp, code };

      setStatus("DELETE /route 요청 (polygon_wgs84=null)", "OK");
      await apiJson("DELETE", ROUTE_ENDPOINT, payload);
      setStatus("폴리곤 삭제 완료", "OK");

      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`폴리곤 삭제 실패: ${e.message}`, "ERR");
    }
  }

  // ====== 벤더 저장/비우기 ======
  async function saveVendorOnly(clear=false) {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("camp가 비었습니다.", "ERR"); return; }
      if (!code) { setStatus("code가 비었습니다.", "ERR"); return; }

      let id = selectedRouteId;
      const payload = {
        id: (typeof id === "number" ? id : undefined),
        camp,
        code,
        vendor: clear ? null : (vendorNameInput.value.trim() || null),
        vendor_business_number: clear ? null : (vendorBizInput.value.trim() || null),
        // polygon은 건드리지 않음
        polygon_wgs84: undefined
      };

      setStatus(clear ? "벤더 비우기 저장" : "벤더 저장", "OK");
      await apiJson("POST", ROUTE_ENDPOINT, payload);
      setStatus(clear ? "벤더 비우기 완료" : "벤더 저장 완료", "OK");
      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`벤더 저장 실패: ${e.message}`, "ERR");
    }
  }

  // ====== 주소 검색 ======
  function searchAddress() {
    const q = prompt("주소 또는 키워드 입력");
    if (!q) return;
    geocoder.addressSearch(q, (result, status) => {
      if (status !== kakao.maps.services.Status.OK || !result?.length) {
        setStatus("주소 검색 실패", "WARN");
        return;
      }
      const r = result[0];
      const lat = Number(r.y);
      const lng = Number(r.x);
      const pos = new kakao.maps.LatLng(lat, lng);
      map.setCenter(pos);
      map.setLevel(4);
      setStatus(`주소 검색: ${q} (이동 완료)`, "OK");
    });
  }

  // ====== OSM 정렬(Overpass) ======
  async function alignWithOsm() {
    try {
      clearOsm();

      const b = map.getBounds();
      const sw = b.getSouthWest();
      const ne = b.getNorthEast();

      const bbox = `${sw.getLng()},${sw.getLat()},${ne.getLng()},${ne.getLat()}`;
      const url = new URL(OSM_ENDPOINT);
      url.searchParams.set("bbox", bbox);

      setStatus(`GET /osm 요청: ${url.toString()}`, "OK");
      const data = await apiGet(url.toString());

      const roads = data?.roads || [];
      const buildings = data?.buildings || [];

      // roads: polyline
      for (const r of roads) {
        if (!r.coords || r.coords.length < 2) continue;
        const path = r.coords.map(([lng,lat]) => new kakao.maps.LatLng(lat,lng));
        const pl = new kakao.maps.Polyline({
          path,
          strokeWeight: 2,
          strokeColor: "#ffffff",
          strokeOpacity: 0.35,
          strokeStyle: "solid",
          zIndex: 0
        });
        pl.setMap(map);
        osmOverlays.push(pl);
      }

      // buildings: polygon (outline)
      for (const g of buildings) {
        if (!g.coords || g.coords.length < 3) continue;
        const path = g.coords.map(([lng,lat]) => new kakao.maps.LatLng(lat,lng));
        const pg = new kakao.maps.Polygon({
          path,
          strokeWeight: 1,
          strokeColor: "#ffffff",
          strokeOpacity: 0.18,
          strokeStyle: "solid",
          fillColor: "#ffffff",
          fillOpacity: 0.05,
          zIndex: 0
        });
        pg.setMap(map);
        osmOverlays.push(pg);
      }

      setStatus(`OSM 표시 완료: roads ${roads.length}, buildings ${buildings.length}`, "OK");
    } catch (e) {
      console.error(e);
      setStatus(`OSM 정렬 실패: ${e.message}`, "ERR");
    }
  }

  // ====== 라벨 토글 ======
  function toggleLabels() {
    labelOn = !labelOn;
    labelToggleBtn.textContent = labelOn ? "라우트 라벨 ON" : "라우트 라벨 OFF";

    // 전체 라벨 재구성
    for (const [id, pack] of overlayById.entries()) {
      pack.labels.forEach(l => l.setMap(null));
      pack.labels = [];

      if (!labelOn) continue;

      const row = pack.row;
      const code = row.full_code || "";
      const color = row.color || colorFor(code);

      for (const p of pack.polygons) {
        const path = p.getPath();
        if (!path || path.length < 3) continue;
        const c = centroidOfLatLngs(path);
        const label = createLabelOverlay(code, c, color);
        label.setMap(map);
        pack.labels.push(label);
      }
    }
  }

  // ====== 초기화 ======
  function resetMap() {
    clearAllOverlays();
    clearOsm();
    stopDraw(true);
    hint("", false);
    setStatus("지도 초기화 완료.", "OK");
  }

  // ====== 지도 이벤트(그리기 모드) ======
  function attachMapEvents() {
    // 클릭: 점 추가
    kakao.maps.event.addListener(map, "click", (mouseEvent) => {
      if (!drawMode) return;
      const latlng = mouseEvent.latLng;
      addDrawPoint(latlng);
    });

    // 우클릭: 마지막 점 취소
    kakao.maps.event.addListener(map, "rightclick", () => {
      if (!drawMode) return;
      popDrawPoint();
    });

    // 더블클릭: 완료(기본 줌 방지)
    kakao.maps.event.addListener(map, "dblclick", () => {
      if (!drawMode) return;
      finishDraw();
    });

    // ESC: 취소
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && drawMode) {
        stopDraw();
        setStatus("그리기 취소", "WARN");
      }
    });
  }

  // ====== 초기 구동 ======
  function init() {
    kakao.maps.load(() => {
      const center = new kakao.maps.LatLng(37.4936, 126.9019); // 대략 대림역 근처
      map = new kakao.maps.Map($("map"), { center, level: 6 });
      geocoder = new kakao.maps.services.Geocoder();

      // 핸들 이미지 초기화 (kakao.maps.load 이후에만 가능)
      VERTEX_IMG = makeHandleImage("#ffffff", "#0b1220");
      MID_IMG = makeHandleImage("#93a4c7", "#0b1220");

      attachMapEvents();

      // 버튼 바인딩
      loadBtn.addEventListener("click", loadRoutes);
      drawNewBtn.addEventListener("click", () => beginDraw("new"));
      drawAddBtn.addEventListener("click", () => beginDraw("add"));
      addrBtn.addEventListener("click", searchAddress);
      saveBtn.addEventListener("click", saveCurrent);
      deletePolyBtn.addEventListener("click", deletePolygon);
      alignBtn.addEventListener("click", alignWithOsm);
      labelToggleBtn.addEventListener("click", toggleLabels);
      resetBtn.addEventListener("click", resetMap);

      vendorSaveBtn.addEventListener("click", () => saveVendorOnly(false));
      vendorClearBtn.addEventListener("click", () => saveVendorOnly(true));

      setStatus("지도 로드 완료", "OK");

      // 자동 로드 (실패 시 사용자에게 안내)
      loadRoutes().catch((err) => {
        log("자동 로드 실패. 백엔드 API 확인이 필요합니다.");
        setStatus("자동 로드 실패 (백엔드 API 오류). 새로 그리기는 가능합니다.", "WARN");
      });
    });
  }

  // 전역 에러 로깅(카카오 내부 Script error도 최소한 표면화)
  window.addEventListener("error", (ev) => {
    const msg = ev?.message || "Script error.";
    log(`ERR window.error: ${msg}`);
  });

  init();
})();
</script>
</body>
</html>
