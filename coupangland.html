<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>CoupangLand (프론트 임시 MVP)</title>
  <meta name="description" content="시/도→시군구→동 단위로 대리점/라우트 현황을 폴리곤 기반으로 조회합니다. (백엔드 없음 / localStorage 저장)" />
  <meta name="robots" content="noindex,nofollow" />

  <style>
    :root{
      --bg:#07101c;
      --panel:#0b1626;
      --panel2:#0e1c30;
      --line:rgba(255,255,255,.08);
      --line2:rgba(255,255,255,.12);
      --text:#e9f1ff;
      --muted:rgba(233,241,255,.70);
      --muted2:rgba(233,241,255,.50);
      --accent:#7c5cff;
      --accent2:#2be7ff;
      --danger:#ff3b6a;
      --ok:#3dff9c;
      --shadow:0 10px 30px rgba(0,0,0,.45);
      --radius:18px;
      --radius2:14px;
      --radius3:12px;
      --chip:#111f36;
      --chip2:#0f233d;
      --btn:#122743;
      --btnH:#173157;
      --input:#0c1b2f;
      --mapStroke:#cfe3ff;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif;
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(124,92,255,.20), transparent 55%),
        radial-gradient(1000px 800px at 80% 0%, rgba(43,231,255,.12), transparent 55%),
        radial-gradient(1200px 900px at 50% 110%, rgba(255,59,106,.10), transparent 60%),
        var(--bg);
      color:var(--text);
    }
    a{ color:inherit; }
    .wrap{
      max-width: 1400px;
      margin: 0 auto;
      padding: 18px 18px 26px;
    }

    /* header */
    .topbar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      padding: 14px 16px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .brand{
      display:flex;
      gap:12px;
      align-items:flex-start;
    }
    .dot{
      width:10px; height:10px;
      border-radius:999px;
      margin-top:6px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.25) 35%, rgba(255,255,255,0) 70%), var(--accent);
      box-shadow: 0 0 18px rgba(124,92,255,.6);
    }
    .brand h1{
      margin:0;
      font-size: 18px;
      letter-spacing: .2px;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .pill{
      font-size:12px;
      color:rgba(255,255,255,.85);
      border:1px solid var(--line2);
      background: rgba(124,92,255,.14);
      padding: 4px 10px;
      border-radius: 999px;
    }
    .subtitle{
      margin-top:6px;
      color:var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }
    .btn{
      appearance:none;
      border:1px solid var(--line2);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color:var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: .15s ease;
      font-weight: 700;
      font-size: 13px;
    }
    .btn:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.18); }
    .btn:active{ transform: translateY(0); }
    .btn.primary{
      border-color: rgba(124,92,255,.55);
      box-shadow: 0 0 0 1px rgba(124,92,255,.25) inset;
      background: linear-gradient(180deg, rgba(124,92,255,.22), rgba(124,92,255,.10));
    }
    .btn.danger{
      border-color: rgba(255,59,106,.55);
      box-shadow: 0 0 0 1px rgba(255,59,106,.20) inset;
      background: linear-gradient(180deg, rgba(255,59,106,.16), rgba(255,59,106,.06));
    }

    /* layout */
    .grid{
      margin-top: 14px;
      display:grid;
      grid-template-columns: 520px 1fr;
      gap: 14px;
      align-items: stretch;
    }
    @media (max-width: 1100px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height: 680px;
    }
    .cardHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 12px 14px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .cardHeader h2{
      margin:0;
      font-size: 14px;
      letter-spacing:.2px;
    }
    .badge{
      font-size:12px;
      border:1px solid var(--line2);
      color:rgba(255,255,255,.82);
      background: rgba(255,255,255,.03);
      padding: 6px 10px;
      border-radius: 999px;
    }
    .cardBody{
      padding: 12px 14px 14px;
    }

    /* search */
    .row{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .row + .row{ margin-top: 10px; }
    .input{
      width:100%;
      border:1px solid var(--line2);
      background: rgba(7,16,28,.45);
      color: var(--text);
      padding: 11px 12px;
      border-radius: 12px;
      outline:none;
      font-size: 13px;
    }
    .input::placeholder{ color: rgba(233,241,255,.45); }
    .miniBtn{
      border:1px solid var(--line2);
      background: rgba(17,31,54,.55);
      color: var(--text);
      padding: 11px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 800;
      min-width: 72px;
    }
    .miniBtn:hover{ background: rgba(23,49,87,.55); }

    /* chips */
    .chips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .chip{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(17,31,54,.55);
      border:1px solid var(--line2);
      color: rgba(255,255,255,.9);
      font-size: 12px;
      cursor:pointer;
      user-select:none;
    }
    .chip strong{
      font-weight: 900;
      font-size: 12px;
    }
    .chip.active{
      border-color: rgba(124,92,255,.55);
      background: rgba(124,92,255,.15);
      box-shadow: 0 0 0 1px rgba(124,92,255,.20) inset;
    }
    .chip .count{
      font-size: 11px;
      color: rgba(233,241,255,.70);
      border:1px solid rgba(255,255,255,.14);
      padding: 2px 7px;
      border-radius: 999px;
    }

    /* map */
    .mapWrap{
      margin-top: 10px;
      border-radius: var(--radius2);
      border:1px solid var(--line);
      overflow:hidden;
      background: rgba(0,0,0,.20);
      height: 420px;
      position:relative;
    }
    #map{
      width:100%;
      height:100%;
    }
    .mapHint{
      position:absolute;
      left:12px;
      right:12px;
      bottom:12px;
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid var(--line2);
      background: rgba(7,16,28,.62);
      color: rgba(233,241,255,.80);
      font-size: 12px;
      line-height: 1.35;
      backdrop-filter: blur(8px);
      pointer-events:none;
    }
    .mapHint b{ color: rgba(255,255,255,.92); }

    /* list boxes */
    .sectionTitle{
      margin: 12px 0 8px;
      font-size: 13px;
      font-weight: 900;
      letter-spacing: .2px;
    }
    .list{
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: rgba(7,16,28,.35);
      overflow:hidden;
    }
    .listItem{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,.06);
      cursor:pointer;
      user-select:none;
    }
    .listItem:first-child{ border-top:0; }
    .listItem:hover{ background: rgba(255,255,255,.04); }
    .liLeft{
      display:flex;
      gap:10px;
      align-items:center;
      min-width:0;
    }
    .liName{
      font-weight: 900;
      font-size: 13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .liSub{
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .liRight{
      display:flex;
      gap:8px;
      align-items:center;
      flex-shrink:0;
    }
    .pillCount{
      font-size: 11px;
      border:1px solid rgba(255,255,255,.14);
      padding: 3px 8px;
      border-radius: 999px;
      color: rgba(233,241,255,.80);
      background: rgba(255,255,255,.03);
    }

    /* textarea */
    textarea{
      width:100%;
      min-height: 130px;
      resize: vertical;
      border:1px solid var(--line2);
      background: rgba(7,16,28,.45);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      outline:none;
      font-size: 13px;
      line-height: 1.4;
    }
    .muted{
      color: var(--muted2);
      font-size: 12px;
      line-height: 1.35;
    }
    .tiny{
      margin-top: 8px;
      color: rgba(233,241,255,.62);
      font-size: 11px;
      line-height: 1.35;
    }

    /* right detail */
    .detailEmpty{
      border:1px dashed rgba(255,255,255,.18);
      border-radius: var(--radius2);
      padding: 14px;
      background: rgba(7,16,28,.25);
      color: rgba(233,241,255,.72);
      font-size: 13px;
    }
    .kv{
      display:grid;
      grid-template-columns: 130px 1fr;
      gap:10px;
      padding: 10px 12px;
      border-top:1px solid rgba(255,255,255,.06);
    }
    .kv:first-child{ border-top:0; }
    .k{
      color: rgba(233,241,255,.70);
      font-size: 12px;
      font-weight: 800;
    }
    .v{
      font-size: 12px;
      color: rgba(255,255,255,.92);
      word-break: break-word;
    }
    .divider{
      height:1px;
      background: rgba(255,255,255,.06);
      margin: 12px 0;
    }

    /* overlay label */
    .regionLabel{
      padding: 4px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(7,16,28,.60);
      color: rgba(255,255,255,.92);
      font-size: 12px;
      font-weight: 900;
      box-shadow: 0 8px 18px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      white-space:nowrap;
    }
    .regionLabel small{
      font-weight: 900;
      color: rgba(43,231,255,.95);
      margin-left:6px;
    }

    /* toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(7,16,28,.82);
      border:1px solid rgba(255,255,255,.16);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: .2s ease;
      z-index: 9999;
    }
    .toast.show{ opacity:1; }

    .warn{
      color: rgba(255,255,255,.92);
      font-weight: 900;
    }
    .warn small{
      display:block;
      margin-top:6px;
      font-weight: 700;
      color: rgba(233,241,255,.70);
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="dot"></div>
      <div>
        <h1>CoupangLand <span class="pill">프론트 임시 MVP</span></h1>
        <div class="subtitle">
          시/도 지도 기반 → 시/군/구 → 동 단위로 대리점/라우트 현황을 드릴다운 조회합니다. (백엔드 없음 / localStorage 저장)
        </div>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="btnResetView" type="button">전체 보기</button>
      <button class="btn" id="btnCopySummary" type="button">현재 화면 요약 복사</button>
      <button class="btn danger" id="btnClearAll" type="button">데이터 초기화</button>
    </div>
  </div>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="cardHeader">
        <h2>지도 기반 조회</h2>
        <span class="badge" id="badgeData">데이터: 0건</span>
      </div>
      <div class="cardBody">
        <div class="row">
          <input class="input" id="q" placeholder="검색: 예) 영등포구 / 대림동 / 용인시 수지구 / 투네스트" />
          <button class="miniBtn" id="btnSearch" type="button">검색</button>
        </div>

        <div class="chips" id="chipsScope"></div>
        <div class="chips" id="chipsVendors"></div>

        <div class="mapWrap">
          <div id="map"></div>
          <div class="mapHint" id="mapHint">
            <b>사용법</b>: 폴리곤을 클릭하면 아래 단계로 내려갑니다. (시/도 → 시군구 → 동)<br/>
            업체 필터(마루웰/투네스트 등)로 조회 범위를 좁힐 수 있습니다.
          </div>
        </div>

        <div class="sectionTitle" id="listTitle">목록</div>
        <div class="list" id="listBox"></div>

        <div class="divider"></div>

        <div class="sectionTitle">데이터 입력/수정 (관리용)</div>
        <textarea id="raw" spellcheck="false" placeholder="예)
서울특별시 영등포구 대림동 | 마루웰
서울특별시 강서구 염창동 | 투네스트
경기도 용인시 수지구 동천동 | 투네스트

- 구/동만 들어오면(예: '영등포구 대림동') 가능한 범위에서 자동 추정합니다.
- 같은 라인이 여러 번 있어도 유니크로 정리됩니다."></textarea>

        <div class="row">
          <button class="btn primary" id="btnApply" type="button">파싱/적용</button>
          <button class="btn" id="btnSample" type="button">샘플 로드</button>
          <button class="btn" id="btnExport" type="button">유니크 목록 내보내기</button>
        </div>

        <div class="tiny" id="statsLine">-</div>
        <div class="tiny">
          경계 데이터 소스: southkorea/southkorea-maps(시/도·시군구), raqoon886/Local_HangJeongDong(동/행정동).
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="cardHeader">
        <h2>현재 선택 상세</h2>
        <span class="badge" id="badgeSel">-</span>
      </div>
      <div class="cardBody">
        <div class="detailEmpty" id="detailBox">
          선택된 조건에 데이터가 없습니다.<br/><br/>
          <div class="muted">
            구현 의도(요청하신 로직):
            <ul style="margin:8px 0 0 18px; padding:0; color:rgba(233,241,255,.70);">
              <li>시/도 클릭 시: 해당 시/도에 존재하는 업체(예: 마루웰/투네스트) 집계 노출</li>
              <li>시군구 클릭 시: 해당 시군구에 있는 업체만 노출</li>
              <li>동 클릭 시: 해당 동에 있는 업체/라우트만 노출</li>
            </ul>
          </div>
        </div>

        <div class="divider"></div>

        <div class="sectionTitle">경계 데이터 상태</div>
        <div class="list">
          <div class="kv">
            <div class="k">시/도 GeoJSON</div>
            <div class="v" id="dsProvinces">대기</div>
          </div>
          <div class="kv">
            <div class="k">시군구 TopoJSON</div>
            <div class="v" id="dsMunicipal">대기</div>
          </div>
          <div class="kv">
            <div class="k">동 GeoJSON</div>
            <div class="v" id="dsDong">대기</div>
          </div>
        </div>

        <div class="divider"></div>

        <div class="sectionTitle">디버그/메모</div>
        <div class="muted" id="debugNote" style="white-space:pre-wrap;">
- 이 MVP는 “정확한 경계 데이터”를 카카오지도 위에 올리는 구조입니다.
- 동(행정동) 경계는 용량이 커서 “선택된 시/도만” 로드합니다.
- 데이터에 ‘서울특별시’ 같은 시/도 표기가 빠져도, 가능한 범위에서 자동 추정합니다.
        </div>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<!-- topojson-client -->
<script src="https://unpkg.com/topojson-client@3/dist/topojson-client.min.js"></script>

<!-- Kakao 지도 SDK (사용자 제공 키) -->
<script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3"></script>

<script>
(function(){
  "use strict";

  /*********************
   * CONFIG / SOURCES
   *********************/
  const SOURCES = {
    // 시/도 경계 (GeoJSON)
    provincesGeo: "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2012/json/provinces-geo-simple.json",
    // 시군구 경계 (TopoJSON)
    municipalitiesTopo: "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2018/json/skorea-municipalities-2018-topo-simple.json",
    // 동(행정동) 경계 (시/도별 파일)
    hangjeongdongBase: "https://raw.githubusercontent.com/raqoon886/Local_HangJeongDong/master/hangjeongdong_"
  };

  // Local_HangJeongDong 파일명은 “광역시/도 공식명”과 대부분 동일합니다.
  // (예: hangjeongdong_서울특별시.geojson, hangjeongdong_경기도.geojson …)
  const SIDO_FILE = {
    "서울특별시":"서울특별시",
    "부산광역시":"부산광역시",
    "대구광역시":"대구광역시",
    "인천광역시":"인천광역시",
    "광주광역시":"광주광역시",
    "대전광역시":"대전광역시",
    "울산광역시":"울산광역시",
    "세종특별자치시":"세종특별자치시",
    "경기도":"경기도",
    "강원특별자치도":"강원특별자치도",
    "강원도":"강원도",
    "충청북도":"충청북도",
    "충청남도":"충청남도",
    "전북특별자치도":"전북특별자치도",
    "전라북도":"전라북도",
    "전라남도":"전라남도",
    "경상북도":"경상북도",
    "경상남도":"경상남도",
    "제주특별자치도":"제주특별자치도"
  };

  // 약칭/별칭 정규화(사용자 입력)
  const SIDO_ALIASES = new Map([
    ["서울","서울특별시"], ["서울시","서울특별시"], ["서울특별시","서울특별시"],
    ["부산","부산광역시"], ["부산시","부산광역시"], ["부산광역시","부산광역시"],
    ["대구","대구광역시"], ["대구시","대구광역시"], ["대구광역시","대구광역시"],
    ["인천","인천광역시"], ["인천시","인천광역시"], ["인천광역시","인천광역시"],
    ["광주","광주광역시"], ["광주시","광주광역시"], ["광주광역시","광주광역시"],
    ["대전","대전광역시"], ["대전시","대전광역시"], ["대전광역시","대전광역시"],
    ["울산","울산광역시"], ["울산시","울산광역시"], ["울산광역시","울산광역시"],
    ["세종","세종특별자치시"], ["세종시","세종특별자치시"], ["세종특별자치시","세종특별자치시"],
    ["경기","경기도"], ["경기도","경기도"],
    ["강원","강원도"], ["강원도","강원도"], ["강원특별자치도","강원특별자치도"],
    ["충북","충청북도"], ["충청북도","충청북도"],
    ["충남","충청남도"], ["충청남도","충청남도"],
    ["전북","전라북도"], ["전라북도","전라북도"], ["전북특별자치도","전북특별자치도"],
    ["전남","전라남도"], ["전라남도","전라남도"],
    ["경북","경상북도"], ["경상북도","경상북도"],
    ["경남","경상남도"], ["경상남도","경상남도"],
    ["제주","제주특별자치도"], ["제주도","제주특별자치도"], ["제주특별자치도","제주특별자치도"]
  ]);

  // 기본 업체(라인에 업체가 없을 때)
  const DEFAULT_VENDOR = "마루웰";

  const STORAGE_KEY = "coupangland_routes_v1";
  const STORAGE_RAW_KEY = "coupangland_raw_v1";

  /*********************
   * STATE
   *********************/
  const state = {
    // selection scope
    level: "SIDO", // SIDO | SIGUNGU | DONG
    sido: null,
    sigungu: null,
    dong: null,

    // vendor filter
    vendor: null, // null means ALL

    // data
    entries: [], // {vendor, sido, sigungu, dong}
    uniqueKeys: new Set(),

    // boundary caches
    map: null,
    polygons: [], // current kakao polygons (for clearing)
    overlays: [], // label overlays
    provincesGeo: null, // GeoJSON
    municipalitiesTopo: null, // TopoJSON raw
    municipalitiesGeo: null, // derived GeoJSON features
    sigunguToSido: new Map(), // "영등포구" -> "서울특별시" (if unique)
    dongGeoBySido: new Map(), // sido -> GeoJSON

    // ui
    lastSearch: "",
    loaded: {
      provinces: false,
      municipalities: false,
      dong: false
    }
  };

  /*********************
   * DOM
   *********************/
  const el = {
    badgeData: document.getElementById("badgeData"),
    chipsScope: document.getElementById("chipsScope"),
    chipsVendors: document.getElementById("chipsVendors"),
    listTitle: document.getElementById("listTitle"),
    listBox: document.getElementById("listBox"),
    detailBox: document.getElementById("detailBox"),
    badgeSel: document.getElementById("badgeSel"),
    q: document.getElementById("q"),
    btnSearch: document.getElementById("btnSearch"),
    btnResetView: document.getElementById("btnResetView"),
    btnCopySummary: document.getElementById("btnCopySummary"),
    btnClearAll: document.getElementById("btnClearAll"),
    raw: document.getElementById("raw"),
    btnApply: document.getElementById("btnApply"),
    btnSample: document.getElementById("btnSample"),
    btnExport: document.getElementById("btnExport"),
    statsLine: document.getElementById("statsLine"),
    toast: document.getElementById("toast"),
    dsProvinces: document.getElementById("dsProvinces"),
    dsMunicipal: document.getElementById("dsMunicipal"),
    dsDong: document.getElementById("dsDong"),
    debugNote: document.getElementById("debugNote")
  };

  /*********************
   * UTIL
   *********************/
  function toast(msg){
    el.toast.textContent = msg;
    el.toast.classList.add("show");
    setTimeout(()=> el.toast.classList.remove("show"), 1600);
  }

  function safeJsonParse(s, fallback){
    try{ return JSON.parse(s); }catch(e){ return fallback; }
  }

  function normalizeWS(s){
    return (s||"").toString().replace(/\s+/g," ").trim();
  }

  function normalizeDongName(d){
    // "대림1동" -> "대림동" 정도로 맞추기(최소한의 완화)
    // "제1동" 같은 형태 제거
    let x = (d||"").toString().trim();
    x = x.replace(/제?\s*\d+\s*동$/,"동");
    x = x.replace(/\d+동$/,"동");
    x = x.replace(/\s+/g,"");
    return x;
  }

  function isSidoToken(tok){
    if(!tok) return false;
    return tok.endsWith("도") || tok.endsWith("시") || tok.endsWith("특별시") || tok.endsWith("광역시") || tok.endsWith("특별자치시") || tok.endsWith("특별자치도");
  }

  function isSigunguToken(tok){
    if(!tok) return false;
    return tok.endsWith("시") || tok.endsWith("군") || tok.endsWith("구");
  }

  function isDongToken(tok){
    if(!tok) return false;
    return tok.endsWith("동") || tok.endsWith("읍") || tok.endsWith("면") || tok.endsWith("리");
  }

  function canonicalSido(sidoRaw){
    const s = normalizeWS(sidoRaw);
    return SIDO_ALIASES.get(s) || s;
  }

  function encodePathComponent(s){
    return encodeURIComponent(s);
  }

  function buildDongUrl(sido){
    const key = SIDO_FILE[sido] || sido;
    return SOURCES.hangjeongdongBase + encodePathComponent(key) + ".geojson";
  }

  function uniq(arr){
    return Array.from(new Set(arr));
  }

  function groupCount(items){
    const m = new Map();
    for(const k of items){
      m.set(k, (m.get(k)||0)+1);
    }
    return m;
  }

  function sortByCountThenName(map){
    return Array.from(map.entries()).sort((a,b)=>{
      if(b[1]!==a[1]) return b[1]-a[1];
      return a[0].localeCompare(b[0], "ko");
    });
  }

  function copyToClipboard(text){
    if(navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(text);
    }
    const ta = document.createElement("textarea");
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
    return Promise.resolve();
  }

  /*********************
   * DATA PARSING
   *********************/
  function parseLinesToEntries(rawText){
    const lines = (rawText||"").split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
    const out = [];
    let rawLineCount = 0;

    for(const line of lines){
      rawLineCount++;

      // vendor separator: "|" or ","
      let locPart = line;
      let vendorPart = null;

      if(line.includes("|")){
        const parts = line.split("|").map(p=>p.trim()).filter(Boolean);
        locPart = parts[0] || "";
        vendorPart = parts[1] || null;
      }else if(line.includes(",")){
        // "지역, 업체" 형태도 허용
        const parts = line.split(",").map(p=>p.trim()).filter(Boolean);
        if(parts.length>=2){
          locPart = parts[0];
          vendorPart = parts.slice(1).join(" ");
        }
      }

      const vendor = normalizeWS(vendorPart || DEFAULT_VENDOR) || DEFAULT_VENDOR;

      const tokens = normalizeWS(locPart).split(" ").filter(Boolean);

      // 케이스 A) [시도] [시군구...] [동]
      // 케이스 B) [시군구] [동]  (시도 생략)
      // 케이스 C) [시군구] [시군구] [동] (예: 용인시 수지구 동천동) (시도 생략)
      // 케이스 D) [시도] [시군구] [시군구] [동] (시도 포함)

      let sido = null;
      let sigungu = null;
      let dong = null;

      if(tokens.length === 0) continue;

      if(isSidoToken(tokens[0]) || SIDO_ALIASES.has(tokens[0])){
        sido = canonicalSido(tokens[0]);
        if(tokens.length >= 3){
          // [시도] [시군구] [동] OR [시도] [시군구] [시군구] [동]
          if(tokens.length === 3){
            sigungu = tokens[1];
            dong = tokens[2];
          }else{
            // 마지막은 동으로 보고, 그 전을 시군구로 합침(용인시 수지구 등)
            dong = tokens[tokens.length-1];
            sigungu = tokens.slice(1, tokens.length-1).join(" ");
          }
        }else{
          // 시도만 있는 라인은 스킵
          continue;
        }
      }else{
        // 시도 생략 케이스
        if(tokens.length === 2){
          sigungu = tokens[0];
          dong = tokens[1];
        }else{
          dong = tokens[tokens.length-1];
          sigungu = tokens.slice(0, tokens.length-1).join(" ");
        }
      }

      // 최소한 시군구+동은 있어야 등록
      if(!sigungu || !dong) continue;

      out.push({
        vendor,
        sido,      // null일 수 있음(추후 추정)
        sigungu: normalizeWS(sigungu),
        dong: normalizeWS(dong)
      });
    }

    return { entries: out, rawLineCount };
  }

  function rebuildUnique(entries){
    state.uniqueKeys.clear();
    const uniqEntries = [];
    for(const e of entries){
      const key = [
        e.vendor,
        e.sido || "",
        e.sigungu || "",
        e.dong || ""
      ].join("||");
      if(!state.uniqueKeys.has(key)){
        state.uniqueKeys.add(key);
        uniqEntries.push(e);
      }
    }
    state.entries = uniqEntries;
  }

  /*********************
   * BOUNDARY LOADING
   *********************/
  async function fetchJson(url){
    const r = await fetch(url, { cache:"force-cache" });
    if(!r.ok) throw new Error("HTTP " + r.status + " " + url);
    return r.json();
  }

  function setDsStatus(which, msg){
    if(which==="provinces") el.dsProvinces.textContent = msg;
    if(which==="municipalities") el.dsMunicipal.textContent = msg;
    if(which==="dong") el.dsDong.textContent = msg;
  }

  // 안전하게 feature name 찾기
  function featureName(props){
    if(!props) return "";
    return (
      props.name ||
      props.NAME ||
      props.Name ||
      props.adm_nm ||
      props.sido ||
      props.sidonm ||
      props.SIDO_NM ||
      props.sigungu ||
      props.sggnm ||
      props.SGG_NM ||
      props.EMD_NM ||
      props.emdnm ||
      props.CTP_KOR_NM ||
      props.SIG_KOR_NM ||
      ""
    ).toString().trim();
  }

  function parseFullNameGuess(fullName){
    // "서울특별시 영등포구", "경기도 용인시", "경기도 용인시 수지구" 등
    const t = normalizeWS(fullName).split(" ").filter(Boolean);
    if(t.length<2) return { sido:null, sigungu:null };
    const sido = canonicalSido(t[0]);
    const sigungu = t.slice(1).join(" ");
    return { sido, sigungu };
  }

  async function ensureProvinces(){
    if(state.provincesGeo) return state.provincesGeo;
    setDsStatus("provinces", "로드 중…");
    try{
      const j = await fetchJson(SOURCES.provincesGeo);
      state.provincesGeo = j;
      state.loaded.provinces = true;
      setDsStatus("provinces", "OK");
      return j;
    }catch(err){
      state.loaded.provinces = false;
      setDsStatus("provinces", "실패: " + (err.message||err));
      throw err;
    }
  }

  async function ensureMunicipalities(){
    if(state.municipalitiesGeo) return state.municipalitiesGeo;
    setDsStatus("municipalities", "로드 중…");
    try{
      const topo = await fetchJson(SOURCES.municipalitiesTopo);
      state.municipalitiesTopo = topo;

      // TopoJSON -> GeoJSON
      // objects 키가 다양할 수 있어 첫 번째 object를 사용
      const objKey = Object.keys(topo.objects||{})[0];
      if(!objKey) throw new Error("TopoJSON objects 없음");
      const geo = topojson.feature(topo, topo.objects[objKey]);
      state.municipalitiesGeo = geo;

      // sigungu -> sido 매핑(시도 추정용)
      // feature name이 "서울특별시 영등포구" 같이 들어있는 경우가 많음
      const tempMap = new Map(); // sigunguName -> Set(sido)
      for(const f of (geo.features||[])){
        const nm = featureName(f.properties) || "";
        const parsed = parseFullNameGuess(nm);
        if(parsed.sido && parsed.sigungu){
          const sig = parsed.sigungu;
          if(!tempMap.has(sig)) tempMap.set(sig, new Set());
          tempMap.get(sig).add(parsed.sido);
        }
      }
      state.sigunguToSido.clear();
      for(const [sig, set] of tempMap.entries()){
        if(set.size === 1){
          state.sigunguToSido.set(sig, Array.from(set)[0]);
        }
      }

      state.loaded.municipalities = true;
      setDsStatus("municipalities", "OK");
      return geo;
    }catch(err){
      state.loaded.municipalities = false;
      setDsStatus("municipalities", "실패: " + (err.message||err));
      throw err;
    }
  }

  async function ensureDongGeo(sido){
    if(!sido) throw new Error("sido 없음");
    const key = canonicalSido(sido);
    if(state.dongGeoBySido.has(key)) return state.dongGeoBySido.get(key);

    setDsStatus("dong", "로드 중… (" + key + ")");
    try{
      const url = buildDongUrl(key);
      const j = await fetchJson(url);
      state.dongGeoBySido.set(key, j);
      state.loaded.dong = true;
      setDsStatus("dong", "OK (" + key + ")");
      return j;
    }catch(err){
      state.loaded.dong = false;
      setDsStatus("dong", "실패: " + (err.message||err));
      throw err;
    }
  }

  /*********************
   * INFER / NORMALIZE ENTRIES
   *********************/
  function inferMissingSido(){
    // entries 중 sido 누락된 것들을 sigunguToSido로 가능한 범위에서 채움
    let changed = 0;
    for(const e of state.entries){
      if(e.sido) continue;
      const inferred = state.sigunguToSido.get(e.sigungu);
      if(inferred){
        e.sido = inferred;
        changed++;
      }
    }
    return changed;
  }

  /*********************
   * FILTERING / AGG
   *********************/
  function selectionLabel(){
    const parts = [];
    if(state.sido) parts.push(state.sido);
    if(state.sigungu) parts.push(state.sigungu);
    if(state.dong) parts.push(state.dong);
    if(parts.length === 0) return "전체";
    return parts.join(" / ");
  }

  function entryMatchesSelection(e){
    if(state.vendor && e.vendor !== state.vendor) return false;
    if(state.sido && e.sido !== state.sido) return false;
    if(state.sigungu && e.sigungu !== state.sigungu) return false;
    if(state.dong && normalizeDongName(e.dong) !== normalizeDongName(state.dong)) return false;
    return true;
  }

  function getFiltered(){
    return state.entries.filter(entryMatchesSelection);
  }

  function aggByLevel(level, entries){
    // level: "SIDO"|"SIGUNGU"|"DONG"
    const keys = [];
    for(const e of entries){
      if(level==="SIDO"){
        if(e.sido) keys.push(e.sido);
      }else if(level==="SIGUNGU"){
        if(e.sigungu) keys.push(e.sigungu);
      }else{
        if(e.dong) keys.push(e.dong);
      }
    }
    return groupCount(keys);
  }

  function aggVendors(entries){
    const keys = entries.map(e=>e.vendor);
    return groupCount(keys);
  }

  function uniqueLocationCount(entries){
    const s = new Set();
    for(const e of entries){
      s.add([e.vendor, e.sido||"", e.sigungu||"", normalizeDongName(e.dong||"")].join("||"));
    }
    return s.size;
  }

  /*********************
   * KAKAO MAP DRAWING
   *********************/
  function clearMapOverlays(){
    for(const p of state.polygons){
      try{ p.setMap(null); }catch(e){}
    }
    for(const o of state.overlays){
      try{ o.setMap(null); }catch(e){}
    }
    state.polygons = [];
    state.overlays = [];
  }

  function geoCoordsToLatLngPath(coords){
    // coords: [[lng,lat], ...]
    const path = [];
    for(const pt of coords){
      if(!pt || pt.length < 2) continue;
      path.push(new kakao.maps.LatLng(pt[1], pt[0]));
    }
    return path;
  }

  function geomToPaths(geom){
    // returns array of "path arrays" (for multipolygon we return multiple)
    if(!geom) return [];
    const type = geom.type;
    const c = geom.coordinates;
    const out = [];

    if(type === "Polygon"){
      // c: [ring1, ring2...]
      if(Array.isArray(c) && c[0]){
        out.push(geoCoordsToLatLngPath(c[0]));
      }
    }else if(type === "MultiPolygon"){
      // c: [ [ring1...], [ring1...] ... ]
      for(const poly of (c||[])){
        if(poly && poly[0]){
          out.push(geoCoordsToLatLngPath(poly[0]));
        }
      }
    }else if(type === "MultiLineString" || type==="LineString"){
      // ignore
    }
    return out;
  }

  function boundsFromPath(path){
    const b = new kakao.maps.LatLngBounds();
    for(const ll of path){
      b.extend(ll);
    }
    return b;
  }

  function centroidFromPath(path){
    // simple average centroid (good enough for label)
    let sumLat = 0, sumLng = 0, n = 0;
    for(const ll of path){
      sumLat += ll.getLat();
      sumLng += ll.getLng();
      n++;
    }
    if(n===0) return null;
    return new kakao.maps.LatLng(sumLat/n, sumLng/n);
  }

  function makeLabelOverlay(position, name, count){
    const div = document.createElement("div");
    div.className = "regionLabel";
    div.textContent = name;
    if(typeof count === "number"){
      const sm = document.createElement("small");
      sm.textContent = String(count);
      div.appendChild(sm);
    }
    return new kakao.maps.CustomOverlay({
      position,
      content: div,
      yAnchor: 1
    });
  }

  function colorForCount(count){
    // count 기반 강조(단순)
    if(count >= 10) return "rgba(43,231,255,.22)";
    if(count >= 5) return "rgba(124,92,255,.20)";
    if(count >= 1) return "rgba(255,255,255,.08)";
    return "rgba(255,255,255,.03)";
  }

  function strokeForActive(active){
    return active ? "rgba(124,92,255,.90)" : "rgba(207,227,255,.55)";
  }

  function fillOpacityForActive(active){
    return active ? 0.28 : 0.18;
  }

  function drawGeoFeatures(geo, options){
    // options: { getName(f), onClick(name, feature), countsMap, activeName }
    clearMapOverlays();

    const counts = options.countsMap || new Map();
    const activeName = options.activeName || null;

    let overallBounds = null;

    for(const f of (geo.features||[])){
      const nm = (options.getName ? options.getName(f) : featureName(f.properties)) || "";
      if(!nm) continue;

      const paths = geomToPaths(f.geometry);
      if(paths.length===0) continue;

      const count = counts.get(nm) || 0;
      const isActive = (activeName && nm === activeName);

      for(const path of paths){
        if(path.length < 3) continue;

        const poly = new kakao.maps.Polygon({
          path,
          strokeWeight: 2,
          strokeColor: strokeForActive(isActive),
          strokeOpacity: 0.9,
          strokeStyle: "solid",
          fillColor: colorForCount(count),
          fillOpacity: fillOpacityForActive(isActive)
        });

        poly.setMap(state.map);
        state.polygons.push(poly);

        // bounds
        const b = boundsFromPath(path);
        if(!overallBounds) overallBounds = b;
        else overallBounds.extend(b.getSouthWest()), overallBounds.extend(b.getNorthEast());

        // click
        if(options.onClick){
          kakao.maps.event.addListener(poly, "click", function(){
            options.onClick(nm, f);
          });
        }
      }

      // label overlay (count>0 or active)
      const representativePath = paths[0];
      const center = centroidFromPath(representativePath);
      if(center && (count > 0 || nm === activeName)){
        const ov = makeLabelOverlay(center, nm, count);
        ov.setMap(state.map);
        state.overlays.push(ov);
      }
    }

    if(overallBounds){
      state.map.setBounds(overallBounds);
    }
  }

  /*********************
   * UI RENDER
   *********************/
  function renderBadge(){
    el.badgeData.textContent = "데이터: " + state.entries.length + "건";
  }

  function renderScopeChips(){
    // scope chips: breadcrumb + back
    const items = [];
    items.push({ key:"ALL", label:"전체", active: !state.sido && !state.sigungu && !state.dong });
    if(state.sido) items.push({ key:"SIDO", label: state.sido, active: !!state.sido && !state.sigungu && !state.dong });
    if(state.sigungu) items.push({ key:"SIGUNGU", label: state.sigungu, active: !!state.sigungu && !state.dong });
    if(state.dong) items.push({ key:"DONG", label: state.dong, active: !!state.dong });

    // back step
    const canBack = !!(state.sido || state.sigungu || state.dong);

    el.chipsScope.innerHTML = "";
    for(const it of items){
      const c = document.createElement("div");
      c.className = "chip" + (it.active ? " active" : "");
      c.innerHTML = "<strong>" + escapeHtml(it.label) + "</strong>";
      c.addEventListener("click", ()=>{
        if(it.key==="ALL"){
          setSelection({ level:"SIDO", sido:null, sigungu:null, dong:null });
        }else if(it.key==="SIDO"){
          setSelection({ level:"SIGUNGU", sido:state.sido, sigungu:null, dong:null });
        }else if(it.key==="SIGUNGU"){
          setSelection({ level:"DONG", sido:state.sido, sigungu:state.sigungu, dong:null });
        }else if(it.key==="DONG"){
          // no-op
        }
      });
      el.chipsScope.appendChild(c);
    }

    if(canBack){
      const c = document.createElement("div");
      c.className = "chip";
      c.innerHTML = "<strong>← 한 단계 위</strong>";
      c.addEventListener("click", ()=>{
        if(state.dong){
          setSelection({ level:"DONG", sido:state.sido, sigungu:state.sigungu, dong:null });
        }else if(state.sigungu){
          setSelection({ level:"SIGUNGU", sido:state.sido, sigungu:null, dong:null });
        }else if(state.sido){
          setSelection({ level:"SIDO", sido:null, sigungu:null, dong:null });
        }
      });
      el.chipsScope.appendChild(c);
    }
  }

  function renderVendorChips(){
    const filteredForVendorAgg = state.entries.filter(e=>{
      // vendor chip는 “현재 선택 조건(시도/시군구/동)”에 대해 vendor만 집계
      if(state.sido && e.sido !== state.sido) return false;
      if(state.sigungu && e.sigungu !== state.sigungu) return false;
      if(state.dong && normalizeDongName(e.dong) !== normalizeDongName(state.dong)) return false;
      return true;
    });

    const m = aggVendors(filteredForVendorAgg);
    const rows = sortByCountThenName(m);

    el.chipsVendors.innerHTML = "";

    // ALL chip
    const allCount = uniqueLocationCount(filteredForVendorAgg);
    const allChip = document.createElement("div");
    allChip.className = "chip" + (!state.vendor ? " active" : "");
    allChip.innerHTML = "<strong>전체 업체</strong> <span class='count'>" + allCount + "</span>";
    allChip.addEventListener("click", ()=>{
      state.vendor = null;
      refresh();
    });
    el.chipsVendors.appendChild(allChip);

    for(const [vendor, count] of rows){
      const c = document.createElement("div");
      c.className = "chip" + (state.vendor === vendor ? " active" : "");
      c.innerHTML = "<strong>" + escapeHtml(vendor) + "</strong> <span class='count'>" + count + "</span>";
      c.addEventListener("click", ()=>{
        state.vendor = (state.vendor === vendor) ? null : vendor;
        refresh();
      });
      el.chipsVendors.appendChild(c);
    }
  }

  function escapeHtml(s){
    return (s||"").toString()
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }

  function renderList(){
    const filtered = getFiltered();

    el.listBox.innerHTML = "";

    // 어떤 레벨 목록을 보여줄지:
    // - 선택이 없으면 SIDO 목록
    // - sido 선택되면 SIGUNGU 목록
    // - sigungu 선택되면 DONG 목록
    // - dong 선택되면 업체/라인 상세 목록
    let mode = "SIDO";
    if(state.sido && !state.sigungu) mode = "SIGUNGU";
    if(state.sigungu && !state.dong) mode = "DONG";
    if(state.dong) mode = "DETAIL";

    if(mode === "SIDO"){
      el.listTitle.textContent = "시/도";
      const m = aggByLevel("SIDO", filtered);
      const rows = sortByCountThenName(m);
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>표시할 데이터가 없습니다.</div></div>";
        return;
      }
      for(const [name, count] of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(name)}</div>
              <div class="liSub">클릭해서 시군구 보기</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">${count}</span></div>
        `;
        item.addEventListener("click", ()=>{
          setSelection({ level:"SIGUNGU", sido:name, sigungu:null, dong:null });
        });
        el.listBox.appendChild(item);
      }
    }else if(mode === "SIGUNGU"){
      el.listTitle.textContent = "시/군/구 (선택: " + state.sido + ")";
      const m = aggByLevel("SIGUNGU", filtered);
      const rows = sortByCountThenName(m);
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>선택된 시/도에 데이터가 없습니다.</div></div>";
        return;
      }
      for(const [name, count] of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(name)}</div>
              <div class="liSub">클릭해서 동 보기</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">${count}</span></div>
        `;
        item.addEventListener("click", ()=>{
          setSelection({ level:"DONG", sido:state.sido, sigungu:name, dong:null });
        });
        el.listBox.appendChild(item);
      }
    }else if(mode === "DONG"){
      el.listTitle.textContent = "동/읍/면 (선택: " + state.sigungu + ")";
      const m = aggByLevel("DONG", filtered);
      const rows = sortByCountThenName(m);
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>선택된 시군구에 데이터가 없습니다.</div></div>";
        return;
      }
      for(const [name, count] of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(name)}</div>
              <div class="liSub">클릭해서 업체/상세 보기</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">${count}</span></div>
        `;
        item.addEventListener("click", ()=>{
          setSelection({ level:"DONG", sido:state.sido, sigungu:state.sigungu, dong:name });
        });
        el.listBox.appendChild(item);
      }
    }else{
      el.listTitle.textContent = "상세 (선택: " + state.dong + ")";
      const rows = filtered.slice().sort((a,b)=>{
        const A = a.vendor.localeCompare(b.vendor, "ko");
        if(A!==0) return A;
        const B = (a.sigungu||"").localeCompare(b.sigungu||"", "ko");
        if(B!==0) return B;
        return (a.dong||"").localeCompare(b.dong||"", "ko");
      });
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>해당 동에 데이터가 없습니다.</div></div>";
        return;
      }
      for(const e of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(e.vendor)}</div>
              <div class="liSub">${escapeHtml((e.sido||"?") + " / " + e.sigungu + " / " + e.dong)}</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">1</span></div>
        `;
        el.listBox.appendChild(item);
      }
    }
  }

  function renderDetail(){
    const filtered = getFiltered();
    el.badgeSel.textContent = selectionLabel() + (state.vendor ? (" / " + state.vendor) : "");

    if(filtered.length===0){
      el.detailBox.className = "detailEmpty";
      el.detailBox.innerHTML = "선택된 조건에 데이터가 없습니다.";
      return;
    }

    const vendors = sortByCountThenName(aggVendors(filtered));
    const uniqCnt = uniqueLocationCount(filtered);

    const byDong = aggByLevel("DONG", filtered);
    const topDong = sortByCountThenName(byDong).slice(0, 12);

    const html = [];
    html.push("<div class='list' style='margin-bottom:12px;'>");
    html.push(kvRow("선택 범위", selectionLabel()));
    html.push(kvRow("업체 필터", state.vendor ? state.vendor : "전체"));
    html.push(kvRow("유니크(업체+지역)", String(uniqCnt)));
    html.push("</div>");

    html.push("<div class='sectionTitle'>업체 분포</div>");
    html.push("<div class='list'>");
    for(const [v, c] of vendors){
      html.push(kvRow(v, String(c)));
    }
    html.push("</div>");

    html.push("<div class='divider'></div>");
    html.push("<div class='sectionTitle'>상위 동(Top 12)</div>");
    html.push("<div class='list'>");
    for(const [d, c] of topDong){
      html.push(kvRow(d, String(c)));
    }
    html.push("</div>");

    el.detailBox.className = "";
    el.detailBox.innerHTML = html.join("");
  }

  function kvRow(k,v){
    return `
      <div class="kv">
        <div class="k">${escapeHtml(k)}</div>
        <div class="v">${escapeHtml(v)}</div>
      </div>
    `;
  }

  function renderStatsLine(extra){
    const rawLines = (el.raw.value||"").split(/\r?\n/).filter(x=>x.trim()).length;
    el.statsLine.textContent = `원본 라인 ${rawLines} / 유니크(업체+지역) ${state.entries.length}` + (extra ? (" / " + extra) : "");
  }

  /*********************
   * SELECTION / FLOW
   *********************/
  function setSelection(next){
    state.level = next.level || state.level;
    state.sido = next.sido ?? state.sido;
    state.sigungu = next.sigungu ?? state.sigungu;
    state.dong = next.dong ?? state.dong;

    // 선택 정합성: dong 선택이면 반드시 sido/sigungu도 있어야(가능한 범위에서)
    refresh();
  }

  async function refresh(){
    renderBadge();
    renderScopeChips();
    renderVendorChips();
    renderList();
    renderDetail();
    renderStatsLine();

    // 지도 렌더링
    await renderMapBySelection();
    persist();
  }

  function persist(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state.entries));
    localStorage.setItem(STORAGE_RAW_KEY, el.raw.value || "");
  }

  function restore(){
    const saved = safeJsonParse(localStorage.getItem(STORAGE_KEY), []);
    if(Array.isArray(saved) && saved.length){
      state.entries = saved.map(x=>({
        vendor: normalizeWS(x.vendor||DEFAULT_VENDOR) || DEFAULT_VENDOR,
        sido: x.sido ? canonicalSido(x.sido) : null,
        sigungu: normalizeWS(x.sigungu||""),
        dong: normalizeWS(x.dong||"")
      })).filter(x=>x.sigungu && x.dong);
      rebuildUnique(state.entries);
    }
    const rawSaved = localStorage.getItem(STORAGE_RAW_KEY);
    if(rawSaved){
      el.raw.value = rawSaved;
    }
  }

  function resetView(){
    state.level = "SIDO";
    state.sido = null;
    state.sigungu = null;
    state.dong = null;
    state.vendor = null;
    el.q.value = "";
    refresh();
  }

  /*********************
   * MAP: render by selection level
   *********************/
  function ensureMap(){
    if(state.map) return;

    // 대한민국 대략 중앙
    const center = new kakao.maps.LatLng(36.5, 127.8);
    state.map = new kakao.maps.Map(document.getElementById("map"), {
      center,
      level: 13
    });

    // 다크 톤 오버레이(실제 타일 스타일을 바꿀 수 없으니, 폴리곤/라벨로 고급스럽게 보이게 만듦)
  }

  async function renderMapBySelection(){
    ensureMap();

    // 기본: 시/도 폴리곤
    // sido 선택: 시군구 폴리곤(가능한 범위)
    // sigungu 선택: 동 폴리곤(해당 시/도 파일 로드)
    // dong 선택: 동 폴리곤에서 해당 dong 강조

    // counts는 “현재 vendor 필터 + 현재 상위 선택” 기준으로 해당 레벨 집계
    if(!state.sido){
      // SIDO level map
      try{
        const provinces = await ensureProvinces();
        await ensureMunicipalities(); // 추정 맵 구축용
        inferMissingSido();
        rebuildUnique(state.entries);

        const filtered = getFiltered();
        const counts = aggByLevel("SIDO", filtered);
        const countsMap = counts;

        // getName: provinces는 name이 시/도일 가능성이 큼. (아니면 props.name)
        drawGeoFeatures(provinces, {
          getName: (f)=>{
            const nm = featureName(f.properties);
            // alias 정리
            return canonicalSido(nm);
          },
          countsMap: countsMap,
          activeName: null,
          onClick: (sidoName)=>{
            setSelection({ level:"SIGUNGU", sido: canonicalSido(sidoName), sigungu:null, dong:null });
          }
        });
      }catch(err){
        clearMapOverlays();
        toast("시/도 경계 로드 실패");
      }
      return;
    }

    // SIDO is selected
    // 우선 시군구 폴리곤 시도
    try{
      await ensureMunicipalities();
      inferMissingSido();
      rebuildUnique(state.entries);

      const filtered = getFiltered();

      // 현재 시도에 있는 시군구 집계
      const sigCount = aggByLevel("SIGUNGU", filtered);

      // municipalitiesGeo에서 해당 시도 소속 feature만 필터
      const all = state.municipalitiesGeo;
      const feat = [];
      for(const f of (all.features||[])){
        const nm = featureName(f.properties);
        const parsed = parseFullNameGuess(nm);
        if(parsed.sido && canonicalSido(parsed.sido) === canonicalSido(state.sido)){
          // 시군구 이름은 parsed.sigungu로 통일
          const clone = Object.assign({}, f);
          clone.__displayName = parsed.sigungu;
          feat.push(clone);
        }
      }

      if(feat.length > 0 && !state.sigungu){
        // 시군구 레벨 표시
        const geo = { type:"FeatureCollection", features: feat };
        const countsMap = new Map();
        for(const [k,v] of sigCount.entries()){
          countsMap.set(k, v);
        }

        drawGeoFeatures(geo, {
          getName: (f)=> f.__displayName || featureName(f.properties),
          countsMap,
          activeName: null,
          onClick: (sigName)=>{
            setSelection({ level:"DONG", sido: state.sido, sigungu: sigName, dong:null });
          }
        });
        return;
      }

      // sigungu 선택 상태거나, 해당 시도 시군구 폴리곤이 부족한 케이스 → 동 경계로
      await renderDongLevel();
    }catch(err){
      // municipalities가 실패하면 동 레벨로라도 보여주기
      await renderDongLevel().catch(()=>{
        clearMapOverlays();
        toast("경계 데이터 로드 실패");
      });
    }
  }

  async function renderDongLevel(){
    // 동 경계는 “선택된 시/도”만 로드
    if(!state.sido){
      await renderMapBySelection();
      return;
    }
    const dongGeo = await ensureDongGeo(state.sido);
    inferMissingSido();
    rebuildUnique(state.entries);

    const filtered = getFiltered();

    // dongGeo features는 행정동 단위이므로, 시군구/동 필터를 props에서 걸어야 함
    // properties에 adm_nm(예: 서울특별시 영등포구 대림1동) 등이 존재하는 경우가 많음
    const features = [];
    const targetSigungu = state.sigungu ? normalizeWS(state.sigungu) : null;

    // 집계: 현재 선택(시도+시군구) 하에서 "동"을 카운트
    const dongCount = aggByLevel("DONG", filtered);

    // dong 표시용: 입력값(법정동 등)과 행정동명이 다를 수 있어 normalizeDongName으로 완화
    const countsMap = new Map();
    for(const [d,c] of dongCount.entries()){
      countsMap.set(normalizeDongName(d), c);
    }

    for(const f of (dongGeo.features||[])){
      const nm = featureName(f.properties);
      const adm = normalizeWS(nm);

      // 시군구 선택이면 포함되는 것만
      if(targetSigungu){
        // adm_nm 안에 "영등포구" 또는 "용인시 수지구" 등이 포함되는지
        if(!adm.includes(targetSigungu)) continue;
      }
      // 시/도는 파일 자체가 이미 시/도별이라 생략
      const clone = Object.assign({}, f);
      clone.__admName = adm;
      features.push(clone);
    }

    const geo = { type:"FeatureCollection", features };

    // activeName: dong 선택이면 normalizeDongName(dong)로 비교
    const activeNormDong = state.dong ? normalizeDongName(state.dong) : null;

    drawGeoFeatures(geo, {
      getName: (f)=>{
        // label은 "… 동"만 보여주기
        const adm = f.__admName || featureName(f.properties);
        const toks = normalizeWS(adm).split(" ");
        const last = toks[toks.length-1] || adm;
        return last;
      },
      countsMap: new Map(Array.from(countsMap.entries()).map(([k,v])=>[k,v])),
      activeName: null,
      onClick: (dongName)=>{
        // 폴리곤은 행정동명(대림1동)일 수 있음 → 선택 동에는 그대로 세팅
        if(!state.sigungu){
          toast("시군구를 먼저 선택하세요");
          return;
        }
        setSelection({ level:"DONG", sido: state.sido, sigungu: state.sigungu, dong: dongName });
      }
    });

    // dong 선택 시 “강조”를 위해 다시 stroke를 바꾸는 간단 처리(현재 drawGeoFeatures는 featureName 기준이라 한 번 더)
    // 단, dong명이 normalize된 카운트 키와 다를 수 있어 실제 강조는 상세/목록에서 주로 확인.
    // 여기서는 안내만.
    if(state.dong){
      toast("동 선택: " + state.dong);
    }
  }

  /*********************
   * SEARCH
   *********************/
  function doSearch(){
    const q = normalizeWS(el.q.value);
    if(!q){
      toast("검색어를 입력하세요");
      return;
    }
    state.lastSearch = q;

    // 검색 로직:
    // 1) vendor명이 포함되면 vendor 필터 적용
    // 2) 시/도/시군구/동 키워드 포함되면 해당 선택으로 점프(가능한 범위)
    // 단, 너무 공격적인 자동 선택은 피하고 “가장 구체적인 토큰” 우선

    const allVendors = uniq(state.entries.map(e=>e.vendor));
    let vendorHit = null;
    for(const v of allVendors){
      if(v && q.includes(v)){
        vendorHit = v;
        break;
      }
    }
    if(vendorHit){
      state.vendor = vendorHit;
    }

    // 지역 토큰 추출
    const tokens = q.split(" ").filter(Boolean);

    let sido = null, sigungu = null, dong = null;

    // 가장 먼저 시도 찾기
    for(const t of tokens){
      if(SIDO_ALIASES.has(t) || isSidoToken(t)){
        sido = canonicalSido(t);
        break;
      }
    }

    // 동/시군구는 뒤에서부터 추정
    for(let i=tokens.length-1; i>=0; i--){
      const t = tokens[i];
      if(!dong && isDongToken(t)) dong = t;
      if(!sigungu && isSigunguToken(t)) sigungu = t;
    }

    // "용인시 수지구" 같이 띄어쓰기로 들어오면 sigungu를 합쳐야 함
    if(tokens.length>=2){
      for(let i=0;i<tokens.length-1;i++){
        const a=tokens[i], b=tokens[i+1];
        if(isSigunguToken(a) && isSigunguToken(b)){
          sigungu = a + " " + b;
          break;
        }
      }
    }

    // 시도 누락이면 sigunguToSido로 추정
    if(!sido && sigungu){
      const inferred = state.sigunguToSido.get(sigungu);
      if(inferred) sido = inferred;
    }

    // 선택 적용 우선순위: dong가 있으면 dong까지, 없으면 sigungu까지, 없으면 sido까지
    if(sido && sigungu && dong){
      setSelection({ level:"DONG", sido, sigungu, dong });
    }else if(sido && sigungu){
      setSelection({ level:"DONG", sido, sigungu, dong:null });
    }else if(sido){
      setSelection({ level:"SIGUNGU", sido, sigungu:null, dong:null });
    }else{
      toast("지역을 특정할 수 없습니다(예: '서울특별시 강서구 염창동')");
      refresh();
    }
  }

  /*********************
   * EVENTS
   *********************/
  el.btnApply.addEventListener("click", async ()=>{
    const { entries, rawLineCount } = parseLinesToEntries(el.raw.value);

    // 기존 데이터 대체(요청하신 MVP 흐름: “임시로 보여주는 페이지”)
    rebuildUnique(entries);

    // 시군구->시도 추정 위해 시군구 경계 먼저 로드
    try{
      await ensureMunicipalities();
      const changed = inferMissingSido();
      rebuildUnique(state.entries);
      renderStatsLine("시도 자동추정 " + changed + "건");
      toast("적용 완료 (유니크 " + state.entries.length + ")");
      refresh();
    }catch(e){
      renderStatsLine("경계 로드 실패로 시도 자동추정 불가");
      toast("적용 완료(경계 로드 실패)");
      refresh();
    }

    persist();
  });

  el.btnSample.addEventListener("click", ()=>{
    el.raw.value =
`영등포구 대림동 | 마루웰
영등포구 대림동 | 마루웰
분당구 대장동 | 투네스트
용인시 수지구 동천동 | 투네스트
영등포구 신길동 | 마루웰
대구광역시 중구 칠성동 | 마루웰
대구광역시 중구 동인동 | 마루웰
서울특별시 강서구 염창동 | 투네스트
서울특별시 강서구 염창동 | 마루웰
경기도 용인시 수지구 동천동 | 마루웰`;
    toast("샘플 로드");
    renderStatsLine();
  });

  el.btnExport.addEventListener("click", ()=>{
    // 유니크 목록을 "시도 시군구 동 | 업체" 형태로 복사/다운로드(간단히 복사)
    const lines = state.entries
      .slice()
      .sort((a,b)=>{
        const A=(a.sido||"").localeCompare(b.sido||"", "ko");
        if(A!==0) return A;
        const B=(a.sigungu||"").localeCompare(b.sigungu||"", "ko");
        if(B!==0) return B;
        const C=normalizeDongName(a.dong||"").localeCompare(normalizeDongName(b.dong||""), "ko");
        if(C!==0) return C;
        return (a.vendor||"").localeCompare(b.vendor||"", "ko");
      })
      .map(e=>{
        const loc = [e.sido||"", e.sigungu||"", e.dong||""].filter(Boolean).join(" ");
        return loc + " | " + e.vendor;
      });
    const text = lines.join("\n");
    copyToClipboard(text).then(()=>{
      toast("유니크 목록 복사됨");
    });
  });

  el.btnSearch.addEventListener("click", doSearch);
  el.q.addEventListener("keydown", (ev)=>{
    if(ev.key==="Enter") doSearch();
  });

  el.btnResetView.addEventListener("click", resetView);

  el.btnCopySummary.addEventListener("click", ()=>{
    const filtered = getFiltered();
    const uniqCnt = uniqueLocationCount(filtered);
    const vendors = sortByCountThenName(aggVendors(filtered));
    const topDong = sortByCountThenName(aggByLevel("DONG", filtered)).slice(0, 10);

    const summary =
`[CoupangLand 요약]
선택: ${selectionLabel()}
업체필터: ${state.vendor ? state.vendor : "전체"}
유니크(업체+지역): ${uniqCnt}

[업체 분포]
${vendors.map(([v,c])=>`- ${v}: ${c}`).join("\n") || "- (없음)"}

[Top 동]
${topDong.map(([d,c])=>`- ${d}: ${c}`).join("\n") || "- (없음)"}
`;
    copyToClipboard(summary).then(()=> toast("요약 복사됨"));
  });

  el.btnClearAll.addEventListener("click", ()=>{
    if(!confirm("localStorage의 CoupangLand 데이터를 모두 삭제할까요?")) return;
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(STORAGE_RAW_KEY);
    state.entries = [];
    state.uniqueKeys.clear();
    el.raw.value = "";
    resetView();
    toast("초기화 완료");
  });

  /*********************
   * INIT
   *********************/
  async function init(){
    ensureMap();
    restore();
    renderBadge();
    renderScopeChips();
    renderVendorChips();
    renderList();
    renderDetail();
    renderStatsLine();

    // 경계 데이터는 “가능하면” 미리 준비(시도 추정용)
    try{
      await ensureMunicipalities();
      const changed = inferMissingSido();
      if(changed>0){
        rebuildUnique(state.entries);
        persist();
      }
    }catch(e){
      // ignore
    }

    // 초기 지도 렌더
    await refresh();
  }

  init();

})();
</script>
</body>
</html>
