<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>CoupangLand</title>

  <!-- Kakao 지도 SDK (autoload=false로 로딩) -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&autoload=false"></script>
  <!-- TopoJSON -->
  <script src="https://unpkg.com/topojson-client@3/dist/topojson-client.min.js"></script>

  <style>
    :root{
      --bg:#f3f5f9;
      --card:#ffffff;
      --text:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --primary:#2563eb;
      --shadow: 0 10px 25px rgba(17,24,39,.08);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, "Noto Sans KR", "Malgun Gothic", Arial, sans-serif;
    }

    /* Header */
    .topbar{
      margin: 18px auto 14px;
      width: min(1400px, calc(100% - 28px));
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{
      display:flex;
      align-items:baseline;
      gap:10px;
      user-select:none;
    }
    .brand .logo{
      font-weight:900;
      font-size: 30px;
      letter-spacing:-0.02em;
      line-height: 1;
    }
    .coupang-letter.c{color:#521110;}
    .coupang-letter.o{color:#521110;}
    .coupang-letter.u{color:#521110;}
    .coupang-letter.p{color:#d73227;}
    .coupang-letter.a{color:#e99923;}
    .coupang-letter.n{color:#92ba3e;}
    .coupang-letter.g{color:#50a3d9;}
    .brand .land{
      font-weight:900;
      font-size: 30px;
      letter-spacing:-0.02em;
      color:#8b5a2b;
      line-height: 1;
    }

    .actions{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .btn{
      border:1px solid var(--line);
      background:#fff;
      color:var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight:700;
      cursor:pointer;
      box-shadow: 0 6px 14px rgba(17,24,39,.06);
    }
    .btn:hover{filter:brightness(0.98)}
    .btn.primary{
      border-color: rgba(37,99,235,.35);
      background: rgba(37,99,235,.08);
      color:#1d4ed8;
    }
    .btn.danger{
      border-color: rgba(239,68,68,.35);
      background: rgba(239,68,68,.08);
      color:#b91c1c;
    }

    /* Layout */
    .wrap{
      width: min(1400px, calc(100% - 28px));
      margin: 0 auto 24px;
      display:grid;
      grid-template-columns: 1.7fr 0.8fr;
      gap: 16px;
      align-items:start;
    }
    .card{
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border:1px solid rgba(229,231,235,.8);
      overflow:hidden;
    }
    .card .hd{
      padding: 14px 16px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card .hd h2{
      margin:0;
      font-size: 16px;
      font-weight: 900;
      letter-spacing:-0.01em;
    }
    .badge{
      font-size:12px;
      font-weight:800;
      padding: 6px 10px;
      border-radius: 999px;
      background:#f1f5ff;
      border:1px solid rgba(37,99,235,.20);
      color:#1d4ed8;
      white-space:nowrap;
    }
    .bd{padding: 14px 16px;}

    /* Controls */
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .input{
      flex:1;
      min-width: 240px;
      border:1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight:700;
      outline:none;
      background:#fff;
    }
    select.input{cursor:pointer}
    .subchips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
      align-items:center;
    }
    .chip{
      border:1px solid rgba(37,99,235,.22);
      background:#fff;
      color:#1d4ed8;
      border-radius: 999px;
      padding: 7px 10px;
      font-weight:900;
      cursor:pointer;
      user-select:none;
    }
    .chip.gray{
      border-color: var(--line);
      color:#374151;
    }
    .chip:hover{filter:brightness(.98)}
    .chip.active{
      background: rgba(37,99,235,.10);
    }

    /* Map */
    #map{
      width:100%;
      height: 72vh;
      min-height: 520px;
      border-radius: 16px;
      overflow:hidden;
      border: 1px solid rgba(229,231,235,.9);
      background:#eef2ff;
      margin-top: 12px;
    }

    /* Lists under map */
    .listbox{
      margin-top: 12px;
      border-top:1px dashed var(--line);
      padding-top: 12px;
    }
    .list-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .list-title .t{
      font-weight:900;
      font-size: 13px;
      color:#111827;
    }
    .list{
      max-height: 220px;
      overflow:auto;
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 6px;
      background:#fff;
    }
    .li{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding: 10px 10px;
      border-radius: 12px;
      cursor:pointer;
      border:1px solid transparent;
      font-weight:800;
    }
    .li:hover{
      background:#f8fafc;
      border-color: rgba(37,99,235,.12);
    }
    .li.active{
      background: rgba(37,99,235,.08);
      border-color: rgba(37,99,235,.22);
      color:#1d4ed8;
    }
    .li small{color:var(--muted); font-weight:800}

    /* Right panel */
    .kv{
      display:grid;
      grid-template-columns: 90px 1fr;
      gap: 10px;
      align-items:center;
      padding: 8px 0;
      border-bottom:1px solid #f3f4f6;
      font-size: 13px;
    }
    .kv:last-child{border-bottom:0}
    .k{color:var(--muted); font-weight:900}
    .v{font-weight:900}
    .box{
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 10px 12px;
      background:#fbfcff;
      font-size: 13px;
      color:#111827;
      white-space:pre-wrap;
      line-height: 1.55;
    }
    .section{
      margin-top:12px;
    }
    .section h3{
      margin: 0 0 8px 0;
      font-size: 13px;
      font-weight: 1000;
      letter-spacing:-0.01em;
    }

    /* Data admin */
    details.admin{
      margin-top: 12px;
      border-top: 1px dashed var(--line);
      padding-top: 12px;
    }
    details.admin summary{
      cursor:pointer;
      font-weight: 1000;
      color:#111827;
      list-style:none;
    }
    details.admin summary::-webkit-details-marker{display:none}
    textarea{
      width:100%;
      min-height: 190px;
      border-radius: 14px;
      border:1px solid var(--line);
      padding: 10px 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.45;
      outline:none;
      margin-top:10px;
    }
    .help{
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
      font-weight: 800;
      line-height: 1.45;
    }

    /* Temporary click toast (숫자만) */
    .overlay-count-toast{
      background:#2563eb;
      color:#fff;
      border-radius: 999px;
      padding: 8px 10px;
      font-weight: 1000;
      font-size: 14px;
      box-shadow: 0 12px 24px rgba(37,99,235,.25);
      border: 1px solid rgba(255,255,255,.22);
      white-space:nowrap;
    }

    /* Map name label */
    .map-name-label{
      background: rgba(255,255,255,.88);
      color:#111827;
      border-radius: 10px;
      padding: 3px 6px;
      font-weight: 900;
      font-size: 11px;
      border: 1px solid rgba(17,24,39,.14);
      box-shadow: 0 8px 16px rgba(17,24,39,.10);
      white-space:nowrap;
    }

    /* Map count badge (항상 표시 옵션) */
    .map-count-badge{
      background:#2563eb;
      color:#fff;
      border-radius: 999px;
      padding: 2px 6px;
      font-weight: 1000;
      font-size: 11px;
      box-shadow: 0 10px 18px rgba(37,99,235,.20);
      border: 1px solid rgba(255,255,255,.20);
      white-space:nowrap;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-label="coupang">
        <span class="coupang-letter c">c</span><span class="coupang-letter o">o</span><span class="coupang-letter u">u</span><span class="coupang-letter p">p</span><span class="coupang-letter a">a</span><span class="coupang-letter n">n</span><span class="coupang-letter g">g</span>
      </div>
      <div class="land">Land</div>
    </div>
    <div class="actions">
      <button class="btn primary" id="btnAll">전체 보기</button>
      <button class="btn" id="btnCopy">현재 화면 요약 복사</button>
      <button class="btn danger" id="btnReset">데이터 초기화</button>
    </div>
  </div>

  <div class="wrap">
    <!-- Left -->
    <div class="card">
      <div class="hd">
        <h2>지도 기반 조회</h2>
        <div class="badge" id="badgeCount">데이터: 0건</div>
      </div>
      <div class="bd">
        <div class="row">
          <input class="input" id="q" placeholder="검색: 예) 대구 / 대구광역시 / 중구 / 칠성동 / 영등포구 / 마루웰" />
          <button class="btn" id="btnSearch">검색</button>
          <select class="input" id="vendorSel" style="max-width:220px">
            <option value="">업체: 전체</option>
          </select>
        </div>

        <div class="subchips" id="crumbs">
          <div class="chip gray active" data-action="scopeAll">전체</div>
          <div class="chip gray" data-action="scopeUp">← 한 단계 위</div>
        </div>

        <div id="map"></div>

        <div class="listbox">
          <div class="list-title">
            <div class="t" id="listTitle">시/도</div>
            <small id="listHint" style="color:var(--muted); font-weight:900;">폴리곤 또는 목록 클릭</small>
          </div>
          <div class="list" id="levelList"></div>
        </div>

        <details class="admin" open>
          <summary>데이터 입력/수정 (관리용)</summary>
          <textarea id="raw"></textarea>
          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="btnApply">파싱/적용</button>
            <button class="btn" id="btnSample">샘플 로드</button>
          </div>
          <div class="help">
            입력 형식: "시도 시군구 동(읍/면/동) 업체명" (공백 구분)<br/>
            시도 생략 라인(예: "영등포구 대림동 마루웰")도 최대한 추정하지만,
            정확도를 위해 가능하면 시도를 포함해 주세요.
          </div>
        </details>
      </div>
    </div>

    <!-- Right -->
    <div class="card">
      <div class="hd">
        <h2>현재 선택 상세</h2>
        <div class="badge" id="badgeScope">전체</div>
      </div>
      <div class="bd">
        <div id="kvArea"></div>

        <div class="section">
          <h3>업체 분포 (가나다순)</h3>
          <div class="box" id="vendorBox">표시할 데이터가 없습니다.</div>
        </div>

        <div class="section">
          <h3>동별 업체 (동 가나다순 / 업체 가나다순)</h3>
          <div class="box" id="dongBox">표시할 데이터가 없습니다.</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  /* ===== 옵션 ===== */
  const SHOW_BADGE_ON_MAP = true; // 폴리곤 중앙 숫자 배지(0이면 숨김). 원치 않으면 false.

  /* ---------------------------
   * 0) Sample Data
   * --------------------------- */
  const SAMPLE_DATA = `영등포구 대림동 마루웰
영등포구 대림동 마루웰
분당구 대장동 투네스트
용인시 수지구 동천동 투네스트
용인시 수지구 동천동 마루웰
용인시 수지구 동천동 강동물류
영등포구 신길동 마루웰
대구광역시 중구 칠성동 마루웰
대구광역시 중구 동인동 마루웰
서울특별시 강서구 염창동 투네스트
서울특별시 강서구 염창동 마루웰
경기도 용인시 수지구 동천동 마루웰
대구광역시 달서구 월성동 지엔제이
대구광역시 중구 대봉동 123로지스
대구광역시 중구 동인동 123로지스
대구광역시 달성군 화원읍 태호물류
대구광역시 동구 검사동 정직한물류
대구광역시 달서구 감삼동 에스제이
대구광역시 수성구 만촌동 수성영업소
용인시 기흥구 마북동 성하
용인시 기흥구 마북동 타이탄
경기도 화성시 영천동 씨제이대한통운 서울장지
경기도 용인시 기흥구 하갈동 신화종합물류
경기도 용인시 기흥구 영덕동 신화종합물류
경기도 용인시 기흥구 보정동 CTR종합물류
경기도 성남시 분당구 분당동 천상로지스틱스
경기도 성남시 분당구 정자동 아이비그룹
경기도 고양시 일산서구 일산동 HR그룹
경기도 고양시 일산서구 일산동 삼보로직스
경기도 고양시 일산서구 일산동 YS물류
경기도 고양시 일산서구 일산동 JK글로벌로직스
경기도 고양시 일산서구 주엽동 가화컴퍼니
경기도 고양시 일산서구 주엽동 삼보로직스
대구광역시 북구 국우동 제일로지스
대구광역시 북구 학정동 제일로지스
대구광역시 북구 동호동 제일로지스
대구광역시 북구 사수동 제일로지스
대구광역시 북구 금호동 제일로지스
대구광역시 북구 팔달동 제일로지스
대구광역시 북구 침산동 제일로지스
대구광역시 북구 대현동 제일로지스
대구광역시 동구 신천동 제일로지스
대구광역시 동구 신암동 제일로지스
대구광역시 수성구 두산동 제일로지스
대구광역시 수성구 파동 제일로지스
경상북도 경산시 중산동 제일로지스
경상북도 경산시 정평동 제일로지스
경상북도 경산시 대평동 제일로지스
경상북도 경산시 백천동 제일로지스
경상북도 경산시 유곡동 제일로지스
경상북도 경산시 평산동 제일로지스
경상북도 경산시 점천동 제일로지스
경상북도 경산시 신천동 제일로지스
경상북도 경산시 내동 제일로지스
경상북도 경산시 남방동 제일로지스
경상북도 경산시 여천동 제일로지스
경상북도 경산시 남산면 제일로지스
경상북도 경산시 사동 제일로지스
경상북도 경산시 계양동 제일로지스
경상북도 경산시 삼풍동 제일로지스
경상북도 경산시 갑제동 제일로지스
경상북도 경산시 압량읍 제일로지스
경상북도 경산시 진량읍 제일로지스
대구광역시 동구 지묘동 제일로지스
대구광역시 동구 숙천동 제일로지스
대구광역시 동구 사복동 제일로지스
대구광역시 동구 내곡동 제일로지스
대구광역시 수성구 범어동 제일로지스
대구광역시 달서구 두류동 제일로지스
대구광역시 달서구 성당동 제일로지스
대구광역시 남구 대명동 제일로지스
대구광역시 북구 칠성동 제일로지스
대구광역시 북구 동변동 제일로지스
대구광역시 북구 서변동 제일로지스`;

  const LS_KEY = "coupangland_raw_v3";

  /* ---------------------------
   * 1) State
   * --------------------------- */
  const state = {
    map: null,
    toastOverlay: null,

    records: [],
    vendors: [],

    scope: { level: "all", sido: null, sgg: null }, // all | sido | sgg
    vendorFilter: "",

    // boundary caches
    sidoData: null,
    sggData: null,
    dongCacheBySido: new Map(),

    // polygon layers (group[])
    layerSido: [],
    layerSgg: [],
    layerDong: [],

    // selected keys
    selectedSidoKey: null,
    selectedSggKey: null,

    // async cancel token
    renderToken: 0,
  };

  /* ---------------------------
   * 2) Utils: Normalization
   * --------------------------- */
  const SIDO_KOR_LIST = [
    "서울특별시","부산광역시","대구광역시","인천광역시","광주광역시","대전광역시","울산광역시","세종특별자치시",
    "경기도","강원특별자치도","충청북도","충청남도","전북특별자치도","전라남도","경상북도","경상남도","제주특별자치도"
  ];

  const SIDO_ALIAS = new Map([
    ["서울","서울특별시"],["서울시","서울특별시"],["seoul","서울특별시"],
    ["부산","부산광역시"],["busan","부산광역시"],
    ["대구","대구광역시"],["daegu","대구광역시"],
    ["인천","인천광역시"],["incheon","인천광역시"],
    ["광주","광주광역시"],["gwangju","광주광역시"],
    ["대전","대전광역시"],["daejeon","대전광역시"],
    ["울산","울산광역시"],["ulsan","울산광역시"],
    ["세종","세종특별자치시"],["sejong","세종특별자치시"],
    ["경기","경기도"],["gyeonggi","경기도"],
    ["강원","강원특별자치도"],["gangwon","강원특별자치도"],
    ["충북","충청북도"],["충남","충청남도"],
    ["전북","전북특별자치도"],["전남","전라남도"],
    ["경북","경상북도"],["경남","경상남도"],
    ["제주","제주특별자치도"],["jeju","제주특별자치도"],
  ]);

  const SIDO_ENG_TO_KOR = new Map([
    ["Seoul","서울특별시"],["Busan","부산광역시"],["Daegu","대구광역시"],["Incheon","인천광역시"],
    ["Gwangju","광주광역시"],["Daejeon","대전광역시"],["Ulsan","울산광역시"],["Sejong","세종특별자치시"],
    ["Gyeonggi-do","경기도"],["Gangwon-do","강원특별자치도"],["Chungcheongbuk-do","충청북도"],["Chungcheongnam-do","충청남도"],
    ["Jeollabuk-do","전북특별자치도"],["Jeollanam-do","전라남도"],["Gyeongsangbuk-do","경상북도"],["Gyeongsangnam-do","경상남도"],
    ["Jeju-do","제주특별자치도"],
  ]);

  function normSido(input) {
    if (!input) return null;
    const s = String(input).trim();
    if (!s) return null;
    const low = s.toLowerCase();

    if (SIDO_ALIAS.has(low)) return SIDO_ALIAS.get(low);
    if (SIDO_ALIAS.has(s)) return SIDO_ALIAS.get(s);

    if (SIDO_ENG_TO_KOR.has(s)) return SIDO_ENG_TO_KOR.get(s);
    if (SIDO_ENG_TO_KOR.has(s.replace(/\s+/g,""))) return SIDO_ENG_TO_KOR.get(s.replace(/\s+/g,""));

    if (SIDO_KOR_LIST.includes(s)) return s;

    for (const kor of SIDO_KOR_LIST) {
      if (s.includes(kor)) return kor;
    }

    const first = s.split(/\s+/)[0];
    if (SIDO_ALIAS.has(first.toLowerCase())) return SIDO_ALIAS.get(first.toLowerCase());

    return null;
  }

  function cleanSpaces(s){ return String(s||"").trim().replace(/\s+/g," "); }

  function extractNameFromProps(props) {
    if (!props) return "";
    const keys = [
      "CTP_KOR_NM","SIDO_NM","sido","sido_nm",
      "SIG_KOR_NM","sgg_nm","name","NAME","name_local","name_kor",
      "adm_nm","ADM_NM","EMD_KOR_NM","emd_nm",
    ];
    for (const k of keys){
      if (props[k]) return String(props[k]).trim();
    }
    const ks = Object.keys(props);
    for (const k of ks){
      if (typeof props[k] === "string" && props[k].length <= 40) return props[k].trim();
    }
    return "";
  }

  function getDongUrlBySidoKor(sidoKor) {
    const fname = `hangjeongdong_${sidoKor}.geojson`;
    return `https://raw.githubusercontent.com/raqoon886/Local_HangJeongDong/master/${encodeURIComponent(fname)}`;
  }

  /* ---------------------------
   * 3) Data parse
   * --------------------------- */
  function parseRaw(rawText) {
    const lines = String(rawText||"").split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
    const recs = [];
    for (const line of lines) {
      const parts = line.split(/\s+/).filter(Boolean);
      if (parts.length < 3) continue;

      const vendor = parts[parts.length - 1];
      const addr = parts.slice(0, parts.length - 1);

      let sido = normSido(addr[0]);
      let rest = addr.slice(1);

      if (!sido) {
        const first = addr[0];
        if (/(영등포구|강서구|마포구|송파구|강남구|관악구|서초구|동작구|구로구|금천구|양천구|은평구|서대문구|중구|종로구|동대문구|성동구|광진구|중랑구|노원구|도봉구|강북구)/.test(first)) sido = "서울특별시";
        else if (/(용인시|성남시|고양시|화성시|수원시|부천시|안양시|평택시|남양주시|김포시|시흥시|광명시)/.test(first)) sido = "경기도";
        else if (/(달서구|수성구|달성군|동구|북구|남구|서구)/.test(first)) sido = "대구광역시";
        else sido = null;

        rest = addr;
      }

      const dong = rest[rest.length - 1];
      const sgg = cleanSpaces(rest.slice(0, -1).join(" "));
      recs.push({
        sido: sido || "",
        sgg: sgg || "",
        dong: dong || "",
        vendor: vendor || "",
        raw: line
      });
    }
    return recs;
  }

  function buildVendors(records){
    const set = new Set();
    for (const r of records) if (r.vendor) set.add(r.vendor);
    return Array.from(set).sort((a,b)=>a.localeCompare(b,"ko"));
  }

  function uniqueCount(records){
    const set = new Set();
    for (const r of records){
      const k = `${r.vendor}|${r.sido}|${r.sgg}|${r.dong}`;
      set.add(k);
    }
    return set.size;
  }

  function filterRecords(){
    const { level, sido, sgg } = state.scope;
    const v = state.vendorFilter;

    return state.records.filter(r => {
      if (v && r.vendor !== v) return false;
      if (level === "all") return true;
      if (level === "sido") return r.sido === sido;
      if (level === "sgg") return r.sido === sido && r.sgg === sgg;
      return true;
    });
  }

  function vendorDistribution(records){
    const m = new Map();
    for (const r of records){
      m.set(r.vendor, (m.get(r.vendor)||0) + 1);
    }
    const arr = Array.from(m.entries()).sort((a,b)=>a[0].localeCompare(b[0],"ko"));
    return arr;
  }

  function dongVendors(records){
    const m = new Map();
    for (const r of records){
      const d = r.dong || "";
      if (!m.has(d)) m.set(d, new Map());
      const mv = m.get(d);
      mv.set(r.vendor, (mv.get(r.vendor)||0) + 1);
    }
    const dongList = Array.from(m.entries()).sort((a,b)=>a[0].localeCompare(b[0],"ko"));
    const lines = [];
    for (const [dong, mv] of dongList){
      const vlist = Array.from(mv.entries()).sort((a,b)=>a[0].localeCompare(b[0],"ko"));
      const vstr = vlist.map(([vn,c])=>`${vn}(${c})`).join(", ");
      lines.push(`- ${dong}: ${vstr}`);
    }
    return lines.join("\n");
  }

  /* ---------------------------
   * 3.5) Count logic: "업체가 몇개" (유니크 업체 수)
   * --------------------------- */
  function countUniqueVendorsIn({level, sido, sgg, dong}){
    const vset = new Set();
    for (const r of state.records){
      if (state.vendorFilter && r.vendor !== state.vendorFilter) continue;

      if (level === "sido"){
        if (r.sido !== sido) continue;
      } else if (level === "sgg"){
        if (r.sido !== sido || r.sgg !== sgg) continue;
      } else if (level === "dong"){
        if (r.sido !== sido || r.sgg !== sgg || r.dong !== dong) continue;
      } else {
        // all
      }
      if (r.vendor) vset.add(r.vendor);
    }
    return vset.size;
  }

  function buildVendorCountMaps(){
    // 현재 vendorFilter 기준으로 각 레벨별 vendor distinct count map 생성
    const mSido = new Map(); // sido -> Set(vendor)
    const mSgg = new Map();  // `${sido}||${sgg}` -> Set(vendor)
    const mDong = new Map(); // `${sido}||${sgg}||${dong}` -> Set(vendor)

    for (const r of state.records){
      if (state.vendorFilter && r.vendor !== state.vendorFilter) continue;
      if (!r.vendor) continue;

      if (r.sido){
        if (!mSido.has(r.sido)) mSido.set(r.sido, new Set());
        mSido.get(r.sido).add(r.vendor);
      }
      if (r.sido && r.sgg){
        const k = `${r.sido}||${r.sgg}`;
        if (!mSgg.has(k)) mSgg.set(k, new Set());
        mSgg.get(k).add(r.vendor);
      }
      if (r.sido && r.sgg && r.dong){
        const k = `${r.sido}||${r.sgg}||${r.dong}`;
        if (!mDong.has(k)) mDong.set(k, new Set());
        mDong.get(k).add(r.vendor);
      }
    }

    const outSido = new Map(Array.from(mSido.entries()).map(([k,set])=>[k,set.size]));
    const outSgg = new Map(Array.from(mSgg.entries()).map(([k,set])=>[k,set.size]));
    const outDong = new Map(Array.from(mDong.entries()).map(([k,set])=>[k,set.size]));
    return { outSido, outSgg, outDong };
  }

  /* ---------------------------
   * 4) Boundary fetch / convert
   * --------------------------- */
  async function fetchJsonWithFallback(urls) {
    let lastErr = null;
    for (const url of urls){
      try{
        const res = await fetch(url, { cache:"force-cache" });
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        return await res.json();
      }catch(e){
        lastErr = e;
      }
    }
    throw lastErr || new Error("fetch failed");
  }

  function topoOrGeoToFeatures(data) {
    if (!data) return [];
    if (data.type === "Topology" && window.topojson) {
      const key = Object.keys(data.objects||{})[0];
      if (!key) return [];
      const geo = topojson.feature(data, data.objects[key]);
      return geo.features || [];
    }
    return data.features || [];
  }

  function coordsToLatLngRing(ring){
    return ring.map(([lng,lat]) => new kakao.maps.LatLng(lat, lng));
  }

  function geomToPolygonPaths(geom){
    if (!geom) return [];
    const t = geom.type;
    const c = geom.coordinates;
    if (t === "Polygon") {
      const rings = c.map(r => coordsToLatLngRing(r));
      return [rings];
    }
    if (t === "MultiPolygon") {
      return c.map(poly => poly.map(r => coordsToLatLngRing(r)));
    }
    return [];
  }

  function boundsOfPaths(paths){
    const b = new kakao.maps.LatLngBounds();
    for (const rings of paths){
      for (const ring of rings){
        for (const p of ring) b.extend(p);
      }
    }
    return b;
  }

  function centerOfBounds(b){
    const sw = b.getSouthWest();
    const ne = b.getNorthEast();
    return new kakao.maps.LatLng(
      (sw.getLat() + ne.getLat()) / 2,
      (sw.getLng() + ne.getLng()) / 2
    );
  }

  function boundsIntersects(a,b){
    const aSW = a.getSouthWest(), aNE = a.getNorthEast();
    const bSW = b.getSouthWest(), bNE = b.getNorthEast();
    const overlapLng = (aSW.getLng() <= bNE.getLng()) && (aNE.getLng() >= bSW.getLng());
    const overlapLat = (aSW.getLat() <= bNE.getLat()) && (aNE.getLat() >= bSW.getLat());
    return overlapLng && overlapLat;
  }

  /* ---------------------------
   * 5) Polygon Layer helpers
   * --------------------------- */
  function clearLayer(layer){
    for (const g of layer){
      for (const poly of (g.polys||[])) poly.setMap(null);
      if (g.nameOverlay) g.nameOverlay.setMap(null);
      if (g.countOverlay) g.countOverlay.setMap(null);
    }
    layer.length = 0;
  }

  function setGroupStyle(group, mode){
    const base = {
      strokeColor: "#2563eb",
      strokeOpacity: 0.85,
      fillColor: "#2563eb",
    };
    let opt;
    if (mode === "selected") opt = { strokeWeight: 5, fillOpacity: 0.10, strokeOpacity: 0.95 };
    else if (mode === "faded") opt = { strokeWeight: 2, fillOpacity: 0.01, strokeOpacity: 0.35 };
    else opt = { strokeWeight: 3, fillOpacity: 0.04, strokeOpacity: 0.70 };

    for (const poly of group.polys){
      poly.setOptions({ ...base, ...opt });
    }
  }

  function setOrUpdateOverlay(group, key, position, className, text, yAnchor){
    if (!text) {
      if (group[key]) group[key].setMap(null);
      group[key] = null;
      return;
    }
    if (!group[key]) {
      const el = document.createElement("div");
      el.className = className;
      el.textContent = text;

      group[key] = new kakao.maps.CustomOverlay({
        position,
        content: el,
        yAnchor: yAnchor ?? 0.5,
        clickable: false,
      });
      group[key].setMap(state.map);
    } else {
      const el = group[key].getContent();
      if (el && el.textContent !== text) el.textContent = text;
      group[key].setPosition(position);
      group[key].setMap(state.map);
    }
  }

  function showCountToast(latlng, count){
    if (!count || count <= 0) return;
    if (state.toastOverlay) state.toastOverlay.setMap(null);

    const el = document.createElement("div");
    el.className = "overlay-count-toast";
    el.textContent = String(count);

    state.toastOverlay = new kakao.maps.CustomOverlay({
      position: latlng,
      content: el,
      yAnchor: 1.2,
      clickable: false,
    });
    state.toastOverlay.setMap(state.map);

    setTimeout(() => {
      if (state.toastOverlay) state.toastOverlay.setMap(null);
    }, 900);
  }

  function drawFeatureGroups(features, layer, onClick, options={}){
    clearLayer(layer);

    for (let i=0; i<features.length; i++){
      const f = features[i];
      const props = f.properties || {};

      const name = options.nameFn
        ? cleanSpaces(options.nameFn(f, i) || "")
        : cleanSpaces(extractNameFromProps(props) || `#${i}`);

      const displayName = options.displayNameFn
        ? cleanSpaces(options.displayNameFn(f, i) || name)
        : name;

      const paths = geomToPolygonPaths(f.geometry);
      if (!paths.length) continue;

      const b = boundsOfPaths(paths);

      const group = {
        key: `${name}__${i}`,
        name,
        displayName,
        feature: f,
        bounds: b,
        center: centerOfBounds(b),
        polys: [],
        nameOverlay: null,
        countOverlay: null,
      };

      for (const rings of paths){
        const poly = new kakao.maps.Polygon({
          map: state.map,
          path: rings,
          strokeWeight: 3,
          strokeColor: "#2563eb",
          strokeOpacity: 0.70,
          fillColor: "#2563eb",
          fillOpacity: 0.04
        });

        kakao.maps.event.addListener(poly, "mouseover", () => {
          poly.setOptions({ fillOpacity: 0.10, strokeOpacity: 0.95 });
        });
        kakao.maps.event.addListener(poly, "mouseout", () => {
          poly.setOptions({ fillOpacity: 0.04, strokeOpacity: 0.70 });
        });
        kakao.maps.event.addListener(poly, "click", (mouseEvent) => {
          onClick(group, mouseEvent.latLng);
        });

        group.polys.push(poly);
      }

      layer.push(group);
    }
  }

  /* ---------------------------
   * 6) Boundary loaders
   * --------------------------- */
  async function ensureSidoBoundaries(){
    if (state.sidoData) return state.sidoData;
    const urls = [
      "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2018/json/skorea-provinces-2018-topo-simple.json",
      "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2018/json/skorea-provinces-2018-geo.json",
      "https://raw.githubusercontent.com/suanlab/dataset/master/southkorea-geojson/skorea-provinces-2018-geo.json"
    ];
    const data = await fetchJsonWithFallback(urls);
    state.sidoData = topoOrGeoToFeatures(data);
    return state.sidoData;
  }

  async function ensureSggBoundaries(){
    if (state.sggData) return state.sggData;
    const urls = [
      "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2018/json/skorea-municipalities-2018-topo-simple.json",
      "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2018/json/skorea-municipalities-2018-geo.json",
      "https://raw.githubusercontent.com/suanlab/dataset/master/southkorea-geojson/skorea-municipalities-2018-geo.json"
    ];
    const data = await fetchJsonWithFallback(urls);
    state.sggData = topoOrGeoToFeatures(data);
    return state.sggData;
  }

  async function ensureDongBoundariesBySidoKor(sidoKor){
    if (state.dongCacheBySido.has(sidoKor)) return state.dongCacheBySido.get(sidoKor);
    const url = getDongUrlBySidoKor(sidoKor);
    const geo = await fetchJsonWithFallback([url]);
    const feats = geo.features || [];
    state.dongCacheBySido.set(sidoKor, feats);
    return feats;
  }

  /* ---------------------------
   * 7) Render / Drilldown
   * --------------------------- */
  function setScopeAll(){
    state.scope = { level:"all", sido:null, sgg:null };
    state.selectedSidoKey = null;
    state.selectedSggKey = null;
    render();
  }

  function setScopeSido(sidoKor){
    state.scope = { level:"sido", sido:sidoKor, sgg:null };
    state.selectedSggKey = null;
    render();
  }

  function setScopeSgg(sidoKor, sgg){
    state.scope = { level:"sgg", sido:sidoKor, sgg:sgg };
    render();
  }

  function scopeUp(){
    if (state.scope.level === "sgg") setScopeSido(state.scope.sido);
    else if (state.scope.level === "sido") setScopeAll();
  }

  function scopeBadgeText(){
    if (state.scope.level === "all") return "전체";
    if (state.scope.level === "sido") return state.scope.sido;
    if (state.scope.level === "sgg") return `${state.scope.sido} / ${state.scope.sgg}`;
    return "전체";
  }

  function updateCrumbs(){
    const crumbs = document.getElementById("crumbs");
    const all = crumbs.querySelector('[data-action="scopeAll"]');
    const up = crumbs.querySelector('[data-action="scopeUp"]');
    all.classList.toggle("active", state.scope.level === "all");
    up.classList.toggle("active", state.scope.level !== "all");
  }

  function fitToBounds(bounds){
    state.map.setBounds(bounds, 30, 30, 30, 30);
  }

  async function render(){
    const token = ++state.renderToken;

    document.getElementById("badgeScope").textContent = scopeBadgeText();
    updateCrumbs();

    const fr = filterRecords();
    document.getElementById("badgeCount").textContent = `데이터: ${state.records.length}건`;

    const kvArea = document.getElementById("kvArea");
    kvArea.innerHTML = "";

    const kv = (k,v) => {
      const div = document.createElement("div");
      div.className = "kv";
      div.innerHTML = `<div class="k">${k}</div><div class="v">${v}</div>`;
      kvArea.appendChild(div);
    };

    kv("선택 범위", scopeBadgeText());
    kv("업체 필터", state.vendorFilter ? state.vendorFilter : "전체");
    kv("유니크", String(uniqueCount(fr)));

    const vd = vendorDistribution(fr);
    document.getElementById("vendorBox").textContent =
      vd.length ? vd.map(([vn,c])=>`- ${vn}: ${c}`).join("\n") : "표시할 데이터가 없습니다.";

    const dv = dongVendors(fr);
    document.getElementById("dongBox").textContent = dv || "표시할 데이터가 없습니다.";

    if (state.scope.level === "all"){
      document.getElementById("listTitle").textContent = "시/도";
      await renderSidoLayer(token);
      renderListSido();
    } else if (state.scope.level === "sido"){
      document.getElementById("listTitle").textContent = `시/군/구 (선택: ${state.scope.sido})`;
      await renderSggLayer(token);
      renderListSgg();
    } else if (state.scope.level === "sgg"){
      document.getElementById("listTitle").textContent = `동/읍/면 (선택: ${state.scope.sido} / ${state.scope.sgg})`;
      await renderDongLayer(token);
      renderListDong();
    }
  }

  function applyLabelsAndBadges(layer, nameFn, countFn){
    for (const g of layer){
      const nm = nameFn(g);
      setOrUpdateOverlay(g, "nameOverlay", g.center, "map-name-label", nm, 0.5);

      if (!SHOW_BADGE_ON_MAP) {
        setOrUpdateOverlay(g, "countOverlay", g.center, "map-count-badge", null, 0.5);
        continue;
      }

      const cnt = countFn(g);
      const txt = (cnt && cnt > 0) ? String(cnt) : null;
      // 배지는 이름과 겹치면 안되니 살짝 위로
      const pos = new kakao.maps.LatLng(g.center.getLat() - 0.015, g.center.getLng());
      setOrUpdateOverlay(g, "countOverlay", pos, "map-count-badge", txt, 0.5);
    }
  }

  async function renderSidoLayer(token){
    const feats = await ensureSidoBoundaries();
    if (token !== state.renderToken) return;

    drawFeatureGroups(feats, state.layerSido, (group, latlng) => {
      const rawName = group.name;
      const sidoKor = normSido(rawName) || normSido(extractNameFromProps(group.feature.properties)) || rawName;

      state.selectedSidoKey = group.key;
      setScopeSido(sidoKor);

      // 클릭 토스트: 해당 시/도 유니크 업체 수 (0이면 표시 없음)
      const cnt = countUniqueVendorsIn({ level:"sido", sido:sidoKor });
      showCountToast(latlng, cnt);
    }, {
      displayNameFn: (f) => {
        const props = f.properties || {};
        const raw = extractNameFromProps(props);
        return normSido(raw) || raw;
      }
    });

    const dataSidoSet = new Set(state.records.map(r=>r.sido).filter(Boolean));
    for (const g of state.layerSido){
      const sidoKor = normSido(g.displayName) || g.displayName;
      if (state.selectedSidoKey && g.key === state.selectedSidoKey) setGroupStyle(g, "selected");
      else if (dataSidoSet.size && !dataSidoSet.has(sidoKor)) setGroupStyle(g, "faded");
      else setGroupStyle(g, "normal");
    }

    // 이름/배지 적용
    const { outSido } = buildVendorCountMaps();
    applyLabelsAndBadges(
      state.layerSido,
      (g) => normSido(g.displayName) || g.displayName,
      (g) => outSido.get(normSido(g.displayName) || g.displayName) || 0
    );

    clearLayer(state.layerSgg);
    clearLayer(state.layerDong);
  }

  async function renderSggLayer(token){
    const sidoKor = state.scope.sido;

    for (const g of state.layerSido){
      const gKor = normSido(g.displayName) || g.displayName;
      if (gKor === sidoKor) { state.selectedSidoKey = g.key; setGroupStyle(g, "selected"); }
      else setGroupStyle(g, "faded");
    }

    const sggFeats = await ensureSggBoundaries();
    if (token !== state.renderToken) return;

    const sidoGroup = state.layerSido.find(g => (normSido(g.displayName)||g.displayName) === sidoKor);
    const sidoBounds = sidoGroup ? sidoGroup.bounds : null;

    const filtered = sidoBounds ? sggFeats.filter(f => {
      const paths = geomToPolygonPaths(f.geometry);
      if (!paths.length) return false;
      const b = boundsOfPaths(paths);
      return boundsIntersects(b, sidoBounds);
    }) : sggFeats;

    drawFeatureGroups(filtered, state.layerSgg, (group, latlng) => {
      const name = cleanSpaces(group.displayName);
      state.selectedSggKey = group.key;
      setScopeSgg(sidoKor, name);

      const cnt = countUniqueVendorsIn({ level:"sgg", sido:sidoKor, sgg:name });
      showCountToast(latlng, cnt);
    }, {
      displayNameFn: (f) => cleanSpaces(extractNameFromProps(f.properties || "")) // 시군구명
    });

    for (const g of state.layerSgg){
      if (state.selectedSggKey && g.key === state.selectedSggKey) setGroupStyle(g, "selected");
      else setGroupStyle(g, "normal");
    }

    // 이름/배지 적용
    const { outSgg } = buildVendorCountMaps();
    applyLabelsAndBadges(
      state.layerSgg,
      (g) => g.displayName,
      (g) => outSgg.get(`${sidoKor}||${g.displayName}`) || 0
    );

    clearLayer(state.layerDong);
    if (sidoBounds) fitToBounds(sidoBounds);
  }

  async function renderDongLayer(token){
    const { sido, sgg } = state.scope;

    for (const g of state.layerSido){
      const gKor = normSido(g.displayName) || g.displayName;
      if (gKor === sido) setGroupStyle(g,"selected");
      else setGroupStyle(g,"faded");
    }
    for (const g of state.layerSgg){
      if (g.displayName === sgg) { state.selectedSggKey = g.key; setGroupStyle(g,"selected"); }
      else setGroupStyle(g,"faded");
    }

    const dongFeats = await ensureDongBoundariesBySidoKor(sido);
    if (token !== state.renderToken) return;

    const dset = new Set(
      state.records
        .filter(r => r.sido===sido && r.sgg===sgg)
        .map(r => r.dong)
        .filter(Boolean)
    );

    const sggGroup = state.layerSgg.find(g => g.displayName === sgg);
    const sggBounds = sggGroup ? sggGroup.bounds : null;

    const filtered = dongFeats.filter(f => {
      const props = f.properties || {};
      const adm = props.adm_nm || props.ADM_NM || "";
      const tks = String(adm).split(/\s+/).filter(Boolean);
      const dongName = tks.length ? tks[tks.length - 1] : extractNameFromProps(props);
      if (dset.size && !dset.has(dongName)) return false;

      if (!sggBounds) return true;
      const paths = geomToPolygonPaths(f.geometry);
      if (!paths.length) return false;
      const b = boundsOfPaths(paths);
      return boundsIntersects(b, sggBounds);
    });

    drawFeatureGroups(filtered, state.layerDong, (group, latlng) => {
      const dongName = group.displayName;
      const cnt = countUniqueVendorsIn({ level:"dong", sido:sido, sgg:sgg, dong:dongName });
      showCountToast(latlng, cnt);
    }, {
      displayNameFn: (f) => {
        const props = f.properties || {};
        const adm = props.adm_nm || props.ADM_NM || "";
        const tks = String(adm).split(/\s+/).filter(Boolean);
        return tks.length ? tks[tks.length - 1] : cleanSpaces(extractNameFromProps(props));
      }
    });

    for (const g of state.layerDong) setGroupStyle(g,"normal");

    // 이름/배지 적용
    const { outDong } = buildVendorCountMaps();
    applyLabelsAndBadges(
      state.layerDong,
      (g) => g.displayName,
      (g) => outDong.get(`${sido}||${sgg}||${g.displayName}`) || 0
    );

    if (sggBounds) fitToBounds(sggBounds);
  }

  /* ---------------------------
   * 8) Lists (under map)
   * --------------------------- */
  function renderList(container, items, activeKey, onClick){
    container.innerHTML = "";
    for (const it of items){
      const div = document.createElement("div");
      div.className = "li" + (it.key===activeKey ? " active" : "");
      div.innerHTML = `<span>${it.label}</span><small>${it.count ?? ""}</small>`;
      div.addEventListener("click", () => onClick(it));
      container.appendChild(div);
    }
    if (!items.length){
      const div = document.createElement("div");
      div.className = "li";
      div.style.cursor = "default";
      div.innerHTML = `<span style="color:var(--muted);font-weight:900">표시할 항목이 없습니다.</span><small></small>`;
      container.appendChild(div);
    }
  }

  function renderListSido(){
    const list = document.getElementById("levelList");
    const m = new Map();
    for (const r of state.records){
      if (!r.sido) continue;
      m.set(r.sido, (m.get(r.sido)||0) + 1);
    }
    const items = Array.from(m.entries())
      .sort((a,b)=>a[0].localeCompare(b[0],"ko"))
      .map(([s,c]) => ({ key:s, label:s, count:c }));
    renderList(list, items, state.scope.sido, (it) => setScopeSido(it.key));
  }

  function renderListSgg(){
    const list = document.getElementById("levelList");
    const { sido } = state.scope;
    const m = new Map();
    for (const r of state.records){
      if (r.sido !== sido) continue;
      if (!r.sgg) continue;
      m.set(r.sgg, (m.get(r.sgg)||0) + 1);
    }
    const items = Array.from(m.entries())
      .sort((a,b)=>a[0].localeCompare(b[0],"ko"))
      .map(([s,c]) => ({ key:s, label:s, count:c }));
    renderList(list, items, state.scope.sgg, (it) => setScopeSgg(sido, it.key));
  }

  function renderListDong(){
    const list = document.getElementById("levelList");
    const { sido, sgg } = state.scope;
    const m = new Map();
    for (const r of state.records){
      if (r.sido !== sido) continue;
      if (r.sgg !== sgg) continue;
      if (!r.dong) continue;
      m.set(r.dong, (m.get(r.dong)||0) + 1);
    }
    const items = Array.from(m.entries())
      .sort((a,b)=>a[0].localeCompare(b[0],"ko"))
      .map(([d,c]) => ({ key:d, label:d, count:c }));
    renderList(list, items, null, (it) => {
      const match = state.layerDong.find(g => g.displayName === it.key);
      if (match) {
        fitToBounds(match.bounds);
        const cnt = countUniqueVendorsIn({ level:"dong", sido, sgg, dong: it.key });
        showCountToast(match.center, cnt);
      }
    });
  }

  /* ---------------------------
   * 9) Search
   * --------------------------- */
  function runSearch(){
    const q = cleanSpaces(document.getElementById("q").value);
    if (!q) return;

    const tokens = q.split(/\s+|\/|,/).filter(Boolean);

    let sido = null;
    for (const t of tokens){
      const s = normSido(t);
      if (s) { sido = s; break; }
    }
    if (!sido && state.scope.level !== "all") sido = state.scope.sido;

    let sgg = null;
    if (sido){
      const candidates = Array.from(new Set(state.records.filter(r=>r.sido===sido).map(r=>r.sgg).filter(Boolean)));
      const joined = tokens.join(" ");
      sgg = candidates.find(c => joined.includes(c)) || null;
    }

    if (sido && sgg) setScopeSgg(sido, sgg);
    else if (sido) setScopeSido(sido);
    else setScopeAll();
  }

  /* ---------------------------
   * 10) UI wiring
   * --------------------------- */
  function syncVendorSelect(){
    const sel = document.getElementById("vendorSel");
    sel.innerHTML = `<option value="">업체: 전체</option>`;
    for (const v of state.vendors){
      const opt = document.createElement("option");
      opt.value = v;
      opt.textContent = v;
      sel.appendChild(opt);
    }
    sel.value = state.vendorFilter || "";
  }

  function applyRaw(rawText){
    state.records = parseRaw(rawText);
    state.vendors = buildVendors(state.records);
    syncVendorSelect();
    document.getElementById("badgeCount").textContent = `데이터: ${state.records.length}건`;
  }

  function copySummary(){
    const fr = filterRecords();
    const scope = scopeBadgeText();
    const vd = vendorDistribution(fr).map(([vn,c])=>`- ${vn}: ${c}`).join("\n") || "- 없음";
    const dv = dongVendors(fr) || "- 없음";

    const text =
`[CoupangLand 요약]
범위: ${scope}
업체필터: ${state.vendorFilter || "전체"}
유니크: ${uniqueCount(fr)}

[업체 분포(가나다)]
${vd}

[동별 업체(동 가나다/업체 가나다)]
${dv}
`;
    navigator.clipboard.writeText(text).then(()=> {
      alert("복사 완료");
    }).catch(()=> {
      prompt("복사 실패(브라우저 제한). 아래 텍스트를 복사:", text);
    });
  }

  function resetData(){
    localStorage.removeItem(LS_KEY);
    document.getElementById("raw").value = SAMPLE_DATA;
    applyRaw(SAMPLE_DATA);
    setScopeAll();
  }

  /* ---------------------------
   * 11) Init Map
   * --------------------------- */
  function initMap(){
    const container = document.getElementById("map");
    state.map = new kakao.maps.Map(container, {
      center: new kakao.maps.LatLng(36.5, 127.9),
      level: 13
    });
    render();
  }

  /* ---------------------------
   * 12) Bootstrap
   * --------------------------- */
  function bootstrap(){
    const saved = localStorage.getItem(LS_KEY);
    const rawEl = document.getElementById("raw");
    rawEl.value = saved || SAMPLE_DATA;

    applyRaw(rawEl.value);

    document.getElementById("btnApply").addEventListener("click", () => {
      const raw = rawEl.value;
      localStorage.setItem(LS_KEY, raw);
      applyRaw(raw);
      setScopeAll();
    });

    document.getElementById("btnSample").addEventListener("click", () => {
      rawEl.value = SAMPLE_DATA;
      localStorage.setItem(LS_KEY, SAMPLE_DATA);
      applyRaw(SAMPLE_DATA);
      setScopeAll();
    });

    document.getElementById("vendorSel").addEventListener("change", (e) => {
      state.vendorFilter = e.target.value || "";
      // 필터 변경 시 지도 라벨/배지도 같이 갱신되어야 하므로 render()
      render();
    });

    document.getElementById("btnSearch").addEventListener("click", runSearch);
    document.getElementById("q").addEventListener("keydown", (e) => {
      if (e.key === "Enter") runSearch();
    });

    document.getElementById("btnAll").addEventListener("click", setScopeAll);
    document.getElementById("btnCopy").addEventListener("click", copySummary);
    document.getElementById("btnReset").addEventListener("click", resetData);

    document.getElementById("crumbs").addEventListener("click", (e) => {
      const chip = e.target.closest(".chip");
      if (!chip) return;
      const act = chip.getAttribute("data-action");
      if (act === "scopeAll") setScopeAll();
      if (act === "scopeUp") scopeUp();
    });

    kakao.maps.load(initMap);
  }

  bootstrap();
})();
</script>
</body>
</html>
