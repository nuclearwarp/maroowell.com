<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>마루웰 라우트 편집기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:#020617;
      color:#e5e7eb;
      height:100vh;
      display:flex;
      flex-direction:column;
    }
    .page{display:flex;flex:1;min-height:0}
    .side{
      width:420px;
      max-width:100%;
      background:#020617;
      border-right:1px solid #111827;
      padding:14px 16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .side h1{
      font-size:15px;
      font-weight:700;
      margin-bottom:4px;
    }
    .side small{font-size:11px;color:#9ca3af}
    label{font-size:12px;color:#9ca3af;margin-top:6px;display:block}
    input{
      width:100%;
      padding:6px 8px;
      font-size:13px;
      border-radius:6px;
      border:1px solid #1f2937;
      background:#020617;
      color:#e5e7eb;
    }
    .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    button{
      padding:6px 12px;
      font-size:12px;
      border-radius:999px;
      border:1px solid #374151;
      background:#020617;
      color:#e5e7eb;
      cursor:pointer;
      white-space:nowrap;
    }
    button.primary{background:#111827;border-color:#111827}
    button.danger{border-color:#7f1d1d;color:#fecaca}
    button:hover{background:#111827}
    #log{
      margin-top:6px;
      padding:6px 8px;
      min-height:80px;
      max-height:140px;
      overflow:auto;
      font-size:11px;
      background:#020617;
      border:1px solid #111827;
      border-radius:6px;
      white-space:pre-wrap;
    }
    .hint{font-size:11px;color:#6b7280;line-height:1.4;margin-top:4px}
    .map-wrap{flex:1;position:relative}
    #map{position:absolute;inset:0}
    .badge{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid #1f2937;
      font-size:10px;
      color:#9ca3af;
    }
    .log-ok{color:#bbf7d0}
    .log-err{color:#fecaca}
    .pill{font-size:11px;color:#a5b4fc}
    @media (max-width:900px){
      .page{flex-direction:column}
      .side{width:100%;border-right:none;border-bottom:1px solid #111827}
    }
  </style>

  <!-- Kakao 지도 -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&libraries=drawing"></script>
</head>
<body>
<div class="page">
  <aside class="side">
    <div>
      <h1>마루웰 라우트 편집기</h1>
      <small>캠프 + 라우트 코드 기반 · Supabase / Cloudflare route API 사용</small>
    </div>

    <div>
      <label for="camp">캠프 이름 (예: 일산2)</label>
      <input id="camp" placeholder="일산2" />
      <label for="route">라우트 코드 (예: 126B, 126B01)</label>
      <input id="route" placeholder="126B01" />
    </div>

    <div class="row">
      <button id="loadBtn" class="primary">불러오기(GET)</button>
      <button id="drawBtn">새로 그리기</button>
      <button id="saveBtn">저장(POST)</button>
      <button id="resetBtn" class="danger">지도 초기화</button>
    </div>

    <div class="hint">
      · <span class="pill">조회/저장은 캠프 + 라우트 둘 다 필수</span><br>
      · <b>GET</b>: 정확히 일치하는 코드(예: 126B01) 또는 <code>mode=prefix</code>로 126B 전체 조회 가능 (백엔드 구현 기준)<br>
      · <b>새로 그리기</b>: 기존 폴리곤 모두 삭제 후, <u>새로 한 개</u>만 그려서 편집/저장합니다.<br>
      · <b>저장</b>: 현재 지도에 그려진 폴리곤 1개를 <code>polygon_wgs84 / center_wgs84</code> 로 Supabase에 업서트.
    </div>

    <div class="badge">
      <span style="width:6px;height:6px;border-radius:999px;background:#22c55e"></span>
      <span id="apiState">API: ready</span>
    </div>

    <div id="log"></div>
  </aside>

  <div class="map-wrap">
    <div id="map"></div>
  </div>
</div>

<script>
/* ------------------ 공통 상태 ------------------ */

const ROUTE_API = "https://route.maroowell.com/route";

let map;
let drawingManager;
let currentPolygon = null;   // 지금 저장 대상이 되는 폴리곤(단 하나)
let viewPolygons = [];       // GET 결과로 뿌려주는 폴리곤들 (읽기 전용)
let isDrawing = false;

const $ = (id) => document.getElementById(id);
const logBox = $("log");

function log(msg, type = "info") {
  const ts = new Date().toTimeString().slice(0,8);
  const prefix = type === "err" ? "[ERR]" : type === "ok" ? "[OK ]" : "[LOG]";
  const colorClass = type === "err" ? "log-err" : type === "ok" ? "log-ok" : "";
  logBox.innerHTML += `<span class="${colorClass}">[${ts}] ${prefix} ${msg}</span>\n`;
  logBox.scrollTop = logBox.scrollHeight;
}

function setApiState(text) {
  $("apiState").textContent = text;
}

/* ------------------ Kakao 지도 초기화 ------------------ */

function initMap() {
  const center = new kakao.maps.LatLng(37.5665, 126.9780);
  map = new kakao.maps.Map($("map"), {
    center,
    level: 7
  });

  drawingManager = new kakao.maps.drawing.DrawingManager({
    map,
    drawingMode: [], // 버튼 누를 때만
    polygonOptions: {
      draggable: true,
      removable: false,
      editable: true,
      strokeWeight: 3,
      strokeColor: "#22c55e",
      strokeOpacity: 0.9,
      strokeStyle: "solid",
      fillColor: "#22c55e",
      fillOpacity: 0.25
    },
    guideTooltip: ["draw", "edit"]
  });

  // 사용자가 다 그렸을 때 호출
  drawingManager.addListener("drawend", function (data) {
    const overlay = data.target;
    if (!overlay || !(overlay instanceof kakao.maps.Polygon)) {
      log("drawend: polygon overlay 아님 (무시)", "err");
      return;
    }

    // 이전 편집 폴리곤 제거
    if (currentPolygon) currentPolygon.setMap(null);
    currentPolygon = overlay;
    isDrawing = false;
    drawingManager.cancel();

    const pts = extractPath(currentPolygon);
    log(`drawend: 새 폴리곤 생성, 점 ${pts.length}개`);
  });
}

/* ------------------ 도우미: 폴리곤 좌표 변환 ------------------ */

/**
 * Kakao polygon.getPath() 가
 *  - MVCArray (getLength/getAt 존재)
 *  - LatLng[] (일반 배열)
 *  - LatLng[][] (멀티폴리곤)
 * 어떤 형태로 와도 전부 {lng,lat}[] 로 변환
 */
function extractPath(poly) {
  if (!poly || typeof poly.getPath !== "function") return [];

  const rawPath = poly.getPath();
  const out = [];

  const pushLatLng = (ll) => {
    if (!ll) return;
    if (typeof ll.getLat === "function") {
      out.push({ lng: ll.getLng(), lat: ll.getLat() });
    } else if (typeof ll.lat === "number" && typeof ll.lng === "number") {
      out.push({ lng: ll.lng, lat: ll.lat });
    }
  };

  // MVCArray 스타일
  if (rawPath && typeof rawPath.getLength === "function" && typeof rawPath.getAt === "function") {
    for (let i = 0; i < rawPath.getLength(); i++) {
      pushLatLng(rawPath.getAt(i));
    }
  }
  // 일반 배열 스타일
  else if (Array.isArray(rawPath)) {
    if (rawPath.length && Array.isArray(rawPath[0])) {
      // [[LatLng,...]] 형태 (멀티폴리곤) → 전부 flatten
      rawPath.forEach(inner => {
        if (!Array.isArray(inner)) return;
        inner.forEach(pushLatLng);
      });
    } else {
      rawPath.forEach(pushLatLng);
    }
  }

  return out;
}

function makePolygonFromWgs(pathArr, editable = false) {
  if (!Array.isArray(pathArr) || pathArr.length < 3) return null;
  const pts = pathArr.map(p => new kakao.maps.LatLng(p.lat, p.lng));
  const poly = new kakao.maps.Polygon({
    path: pts,
    strokeWeight: 3,
    strokeColor: editable ? "#22c55e" : "#3b82f6",
    strokeOpacity: 0.9,
    strokeStyle: "solid",
    fillColor: editable ? "#22c55e" : "#3b82f6",
    fillOpacity: 0.25
  });
  poly.setMap(map);
  return poly;
}

function fitToPolygon(poly) {
  if (!poly) return;
  const path = poly.getPath();
  let bounds = new kakao.maps.LatLngBounds();

  // path도 위와 같이 복잡할 수 있어서 다시 처리
  const addToBounds = (ll) => {
    if (!ll) return;
    if (typeof ll.getLat === "function") {
      bounds.extend(ll);
    } else if (typeof ll.lat === "number" && typeof ll.lng === "number") {
      bounds.extend(new kakao.maps.LatLng(ll.lat, ll.lng));
    }
  };

  if (path && typeof path.getLength === "function" && typeof path.getAt === "function") {
    for (let i = 0; i < path.getLength(); i++) addToBounds(path.getAt(i));
  } else if (Array.isArray(path)) {
    if (path.length && Array.isArray(path[0])) {
      path.forEach(inner => inner.forEach(addToBounds));
    } else {
      path.forEach(addToBounds);
    }
  }
  map.setBounds(bounds);
}

/* ------------------ 버튼: 새로 그리기 ------------------ */

$("drawBtn").onclick = () => {
  // 보기용 폴리곤은 남겨두고, 편집용만 제거
  if (currentPolygon) {
    currentPolygon.setMap(null);
    currentPolygon = null;
  }

  isDrawing = true;
  drawingManager.cancel();
  drawingManager.select(kakao.maps.drawing.OverlayType.POLYGON);
  log("새로 그리기: 다각형 모드 진입. 지도를 클릭해서 영역을 그리세요.");
};

/* ------------------ 버튼: 지도 초기화 ------------------ */

$("resetBtn").onclick = () => {
  if (currentPolygon) currentPolygon.setMap(null);
  currentPolygon = null;

  viewPolygons.forEach(p => p.setMap(null));
  viewPolygons = [];

  drawingManager.cancel();
  isDrawing = false;

  log("지도 초기화 완료.");
};

/* ------------------ 버튼: 불러오기(GET) ------------------ */

$("loadBtn").onclick = async () => {
  const camp = $("camp").value.trim();
  const code = $("route").value.trim();

  if (!camp || !code) {
    alert("캠프 이름과 라우트 코드를 모두 입력해주세요.");
    return;
  }

  try {
    setApiState("API: loading...");
    const params = new URLSearchParams({ camp, code, mode: "prefix" });
    const url = `${ROUTE_API}?${params.toString()}`;

    log(`GET ${url}`);
    const res = await fetch(url);
    const data = await res.json();
    log(JSON.stringify(data));

    // 이전 보기용 폴리곤 제거
    viewPolygons.forEach(p => p.setMap(null));
    viewPolygons = [];

    if (data && Array.isArray(data.rows) && data.rows.length) {
      data.rows.forEach(row => {
        if (!row.polygon_wgs84) return;
        const poly = makePolygonFromWgs(row.polygon_wgs84, false);
        if (poly) viewPolygons.push(poly);
      });
      if (viewPolygons.length) fitToPolygon(viewPolygons[0]);
      log(`GET 결과: ${viewPolygons.length}개 폴리곤 표시`, "ok");
    } else if (data && data.found && data.row) {
      const row = data.row;
      if (row.polygon_wgs84) {
        const poly = makePolygonFromWgs(row.polygon_wgs84, false);
        if (poly) {
          viewPolygons.push(poly);
          fitToPolygon(poly);
        }
      }
      log("GET 결과: 단일 라우트 표시", "ok");
    } else {
      log("GET 결과 없음", "err");
      alert("해당 조건에 맞는 라우트 폴리곤이 없습니다.");
    }
  } catch (err) {
    console.error(err);
    log("GET 중 오류: " + err, "err");
    alert("GET 요청 중 오류가 발생했습니다. 콘솔 로그를 확인해주세요.");
  } finally {
    setApiState("API: ready");
  }
};

/* ------------------ 버튼: 저장(POST) ------------------ */

$("saveBtn").onclick = async () => {
  const camp = $("camp").value.trim();
  const code = $("route").value.trim();

  if (!camp || !code) {
    alert("캠프 이름과 라우트 코드를 모두 입력해주세요.");
    return;
  }

  if (!currentPolygon) {
    alert("저장할 폴리곤이 없습니다. [새로 그리기]로 영역을 그린 후 저장하세요.");
    return;
  }

  const pts = extractPath(currentPolygon);
  if (pts.length < 3) {
    alert("폴리곤 정점이 너무 적습니다. 최소 3개 이상 찍어주세요.");
    return;
  }

  // 중심점은 간단히 평균값으로 계산
  let sx = 0, sy = 0;
  pts.forEach(p => { sx += p.lng; sy += p.lat; });
  const center = { lng: sx / pts.length, lat: sy / pts.length };

  const payload = {
    camp,
    code,
    polygon_wgs84: pts,
    center_wgs84: center
  };

  try {
    setApiState("API: saving...");
    log("POST " + ROUTE_API);
    log(JSON.stringify(payload));

    const res = await fetch(ROUTE_API, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const data = await res.json();
    log("POST 응답: " + JSON.stringify(data), "ok");

    alert("저장 완료! (응답: " + (data.status || "ok") + ")");
  } catch (err) {
    console.error(err);
    log("POST 중 오류: " + err, "err");
    alert("저장 중 오류가 발생했습니다. 콘솔 로그를 확인해주세요.");
  } finally {
    setApiState("API: ready");
  }
};

/* ------------------ 시작 ------------------ */

window.onload = () => {
  initMap();
  log("지도 초기화 완료.");
};
</script>
</body>
</html>
