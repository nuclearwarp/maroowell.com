<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>CoupangLand</title>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#ffffff;
      --line:#e6e8ef;
      --text:#111827;
      --muted:#6b7280;
      --primary:#2563eb;
      --primary-weak:rgba(37, 99, 235, .10);
      --shadow:0 10px 30px rgba(0,0,0,.08);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
      background: linear-gradient(180deg, #f5f7ff 0%, #ffffff 40%, #ffffff 100%);
      color:var(--text);
    }

    .topbar{
      position:sticky;
      top:0;
      z-index:50;
      background: rgba(255,255,255,.9);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .topbar-inner{
      max-width: 1440px;
      margin:0 auto;
      padding:18px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
    }

    .brand{display:flex;align-items:baseline;gap:10px;user-select:none;}
    .brand .coupang{font-weight:900;font-size:34px;letter-spacing:-.6px;line-height:1;}
    .brand .coupang span:nth-child(1){color:#e11d48;}
    .brand .coupang span:nth-child(2){color:#f97316;}
    .brand .coupang span:nth-child(3){color:#f59e0b;}
    .brand .coupang span:nth-child(4){color:#22c55e;}
    .brand .coupang span:nth-child(5){color:#38bdf8;}
    .brand .coupang span:nth-child(6){color:#3b82f6;}
    .brand .coupang span:nth-child(7){color:#1d4ed8;}
    .brand .land{font-weight:900;font-size:34px;letter-spacing:-.6px;color:#7a4a21;line-height:1;}

    .top-actions{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;}
    .btn{
      border:1px solid #cfd6ff;background:#fff;color:#111827;padding:10px 14px;border-radius:12px;
      font-weight:700;cursor:pointer;box-shadow:0 6px 16px rgba(0,0,0,.06);
    }
    .btn.primary{border-color:#a8b7ff;background:#eef2ff;color:#1f2a8a;}
    .btn.danger{border-color:#fca5a5;background:#fff5f5;color:#b91c1c;}

    .wrap{max-width:1440px;margin:0 auto;padding:18px;}

    .grid{display:grid;grid-template-columns: 1.25fr .75fr;gap:16px;align-items:start;}
    @media (max-width: 1100px){.grid{grid-template-columns:1fr}}

    .card{background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;}
    .card-hd{
      padding:16px 16px 10px 16px;border-bottom:1px solid var(--line);
      display:flex;align-items:center;justify-content:space-between;gap:10px;
    }
    .card-hd h2{margin:0;font-size:16px;letter-spacing:-.2px;}
    .pill{font-size:12px;padding:6px 10px;border-radius:999px;background:#f3f4f6;border:1px solid #e5e7eb;color:#111827;font-weight:700;white-space:nowrap;}
    .card-bd{padding:14px 16px 16px 16px;}

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:12px;}
    .input{flex:1;min-width:260px;padding:12px 12px;border:1px solid #e5e7eb;border-radius:12px;outline:none;font-weight:600;}
    .select{padding:12px 12px;border:1px solid #e5e7eb;border-radius:12px;font-weight:700;background:#fff;}

    .crumbs{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;}
    .chip{
      padding:8px 12px;border-radius:999px;border:1px solid #e5e7eb;background:#fff;cursor:pointer;
      font-weight:800;color:#111827;box-shadow:0 6px 14px rgba(0,0,0,.06);
    }
    .chip.active{border-color:#a8b7ff;background:#eef2ff;color:#1f2a8a;}

    .map-wrap{
      position:relative;border-radius:16px;overflow:hidden;border:1px solid #e5e7eb;background:#f8fafc;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.03);
    }
    #map{width:100%;height: 68vh;min-height:560px;max-height:820px;}
    .map-loading{
      position:absolute;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(255,255,255,.55);backdrop-filter: blur(6px);z-index:10;font-weight:900;color:#111827;
    }
    .map-loading.show{display:flex;}

    .section{border:1px solid #e5e7eb;border-radius:14px;padding:12px 12px;background:#fafbff;margin-top:10px;}
    .section h3{margin:0 0 8px 0;font-size:13px;color:#111827;letter-spacing:-.2px;}
    .list{margin:0;padding-left:18px;color:#111827;font-weight:650;font-size:13px;line-height:1.6;}
    .muted{color:var(--muted);font-weight:650;font-size:12px;}

    .region-label{
      display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:999px;border:1px solid rgba(0,0,0,.12);
      background:rgba(255,255,255,.92);box-shadow:0 10px 22px rgba(0,0,0,.10);white-space:nowrap;
      transform: translate(-50%, -50%);pointer-events:auto;cursor:pointer;user-select:none;
    }
    .region-label .name{font-size:11px;font-weight:900;color:#111827;letter-spacing:-.2px;}
    .region-label .count{
      display:inline-flex;align-items:center;justify-content:center;min-width:20px;height:20px;padding:0 6px;
      border-radius:999px;background:#2563eb;color:#fff;font-size:12px;font-weight:900;line-height:1;
    }

    .tiny-toggle{margin-left:auto;display:flex;align-items:center;gap:8px;font-size:12px;color:#111827;font-weight:800;}
    .toggle{border:1px solid #e5e7eb;border-radius:999px;padding:6px 10px;cursor:pointer;background:#fff;user-select:none;}
    .toggle.active{background:#eef2ff;border-color:#a8b7ff;color:#1f2a8a;}

    .admin{margin-top:16px;}
    textarea{width:100%;min-height:160px;border:1px solid #e5e7eb;border-radius:14px;padding:12px;font-weight:650;line-height:1.5;outline:none;resize:vertical;}
    .admin-actions{margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;}
  </style>

  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&libraries=services"></script>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="coupang" aria-label="coupang">
          <span>c</span><span>o</span><span>u</span><span>p</span><span>a</span><span>n</span><span>g</span>
        </div>
        <div class="land">Land</div>
      </div>

      <div class="top-actions">
        <button class="btn primary" id="btnAll">전체 보기</button>
        <button class="btn" id="btnCopy">현재 화면 요약 복사</button>
        <button class="btn danger" id="btnReset">데이터 초기화</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <div class="card-hd">
          <h2>지도 기반 조회</h2>
          <div class="pill" id="dataCountPill">데이터: 0건</div>
        </div>

        <div class="card-bd">
          <div class="row">
            <input class="input" id="q" placeholder="검색: 예) 대구 / 대구광역시 / 중구 / 칠성동 / 영등포구 / 마루웰" />
            <button class="btn" id="btnSearch">검색</button>

            <select class="select" id="vendorSel" title="업체 필터">
              <option value="">업체: 전체</option>
            </select>
          </div>

          <div class="row" style="margin-top:-4px;">
            <div class="crumbs" id="crumbs"></div>

            <div class="tiny-toggle" id="dongToggleWrap" style="display:none;">
              <div class="toggle" id="toggleDataDongs">표시: 데이터 있는 동</div>
              <div class="toggle active" id="toggleAllDongs">표시: 전체 동</div>
            </div>
          </div>

          <div class="map-wrap">
            <div id="map"></div>
            <div class="map-loading" id="mapLoading">경계 불러오는 중…</div>
          </div>

          <div class="admin">
            <div class="muted" style="margin-bottom:8px;">데이터 입력/수정(관리용)</div>
            <textarea id="dataBox"></textarea>
            <div class="admin-actions">
              <button class="btn primary" id="btnApply">파싱/적용</button>
              <button class="btn" id="btnSample">샘플 로드</button>
              <button class="btn" id="btnExport">유니크 목록 내보내기</button>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-hd">
          <h2>현재 선택 상세</h2>
          <div class="pill" id="scopePill">전체</div>
        </div>
        <div class="card-bd">
          <div class="section">
            <h3>선택 범위</h3>
            <div class="muted" id="scopeText">전체</div>
            <div style="height:8px;"></div>
            <div class="muted">업체 필터: <b id="vendorText">전체</b></div>
            <div style="height:8px;"></div>
            <div class="muted">유니크(업체+지역): <b id="uniqText">0</b></div>
          </div>

          <div class="section">
            <h3>업체 분포 (가나다순)</h3>
            <ul class="list" id="vendorDist"></ul>
            <div class="muted" id="vendorDistEmpty" style="display:none;">표시할 데이터가 없습니다.</div>
          </div>

          <div class="section">
            <h3>동별 업체 (동 가나다순 / 업체 가나다순)</h3>
            <ul class="list" id="dongByVendors"></ul>
            <div class="muted" id="dongByVendorsEmpty" style="display:none;">표시할 데이터가 없습니다.</div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
(() => {
  const BOUNDARY = {
    SIDO_URLS: [
      "https://cdn.jsdelivr.net/gh/southkorea/southkorea-maps@master/kostat/2012/json/provinces-geo-simple.json",
      "https://cdn.jsdelivr.net/gh/southkorea/southkorea-maps@master/kostat/2018/json/skorea-provinces-2018-geo.json",
    ],
    SIGUNGU_URLS: [
      "https://cdn.jsdelivr.net/gh/southkorea/southkorea-maps@master/kostat/2018/json/skorea-municipalities-2018-geo.json",
    ],
    DONG_URL_TEMPLATE: (sidoName) => {
      const fname = `hangjeongdong_${sidoName}.geojson`;
      const enc = encodeURIComponent(fname);
      return [
        `https://cdn.jsdelivr.net/gh/raqoon886/Local_HangJeongDong@master/${enc}`,
        `https://raw.githubusercontent.com/raqoon886/Local_HangJeongDong/master/${enc}`,
        `./boundaries/${fname}`,
      ];
    }
  };

  const SAMPLE_TEXT = `영등포구 대림동 마루웰
영등포구 대림동 마루웰
분당구 대장동 투네스트
용인시 수지구 동천동 투네스트
용인시 수지구 동천동 마루웰
용인시 수지구 동천동 강동물류
영등포구 신길동 마루웰
대구광역시 중구 칠성동 마루웰
대구광역시 중구 동인동 마루웰
서울특별시 강서구 염창동 투네스트
서울특별시 강서구 염창동 마루웰
경기도 용인시 수지구 동천동 마루웰
대구광역시 달서구 월성동 지엔제이
대구광역시 중구 대봉동 123로지스
대구광역시 중구 동인동 123로지스
대구광역시 달성군 화원읍 태호물류
대구광역시 동구 검사동 정직한물류
대구광역시 달서구 감삼동 에스제이
대구광역시 수성구 만촌동 수성영업소`;

  const els = {
    map: document.getElementById('map'),
    mapLoading: document.getElementById('mapLoading'),
    q: document.getElementById('q'),
    btnSearch: document.getElementById('btnSearch'),
    btnAll: document.getElementById('btnAll'),
    btnCopy: document.getElementById('btnCopy'),
    btnReset: document.getElementById('btnReset'),
    dataCountPill: document.getElementById('dataCountPill'),
    crumbs: document.getElementById('crumbs'),
    scopePill: document.getElementById('scopePill'),
    scopeText: document.getElementById('scopeText'),
    vendorSel: document.getElementById('vendorSel'),
    vendorText: document.getElementById('vendorText'),
    uniqText: document.getElementById('uniqText'),
    vendorDist: document.getElementById('vendorDist'),
    vendorDistEmpty: document.getElementById('vendorDistEmpty'),
    dongByVendors: document.getElementById('dongByVendors'),
    dongByVendorsEmpty: document.getElementById('dongByVendorsEmpty'),
    dataBox: document.getElementById('dataBox'),
    btnApply: document.getElementById('btnApply'),
    btnSample: document.getElementById('btnSample'),
    btnExport: document.getElementById('btnExport'),
    dongToggleWrap: document.getElementById('dongToggleWrap'),
    toggleDataDongs: document.getElementById('toggleDataDongs'),
    toggleAllDongs: document.getElementById('toggleAllDongs'),
  };

  const state = {
    records: [],
    vendorFilter: "",
    selectedSido: "",
    selectedCity: "",
    selectedDistrict: "",
    selectedDistrictShort: "",
    selectedDistrictFeature: null,
    showAllDongs: true,

    cache: { sido:null, sigungu:null, dongBySido:new Map(), cityMetaBySido:new Map() },
    map: null,
    polygons: [],
    labels: [],
    renderSeq: 0,
    renderInFlight: false,
    pendingRender: false,
  };

  function showLoading(on){ els.mapLoading.classList.toggle('show', !!on); }
  function norm(s){ return (s||"").toString().trim(); }
  function normLoose(s){ return norm(s).replace(/\s+/g,""); }

  function dongCanon(s){
    let x = norm(s);
    if (!x) return "";
    x = x.replace(/\s+/g,"");
    x = x.replace(/제?\d+동$/u, "동");
    x = x.replace(/\d+가$/u, "");
    x = x.replace(/제?\d+가$/u, "");
    return x;
  }

  const SIDO_ALIAS = new Map([
    ["Seoul","서울특별시"],["Busan","부산광역시"],["Daegu","대구광역시"],["Incheon","인천광역시"],
    ["Gwangju","광주광역시"],["Daejeon","대전광역시"],["Ulsan","울산광역시"],["Sejong","세종특별자치시"],
    ["Gyeonggi","경기도"],["Gangwon","강원특별자치도"],["Chungbuk","충청북도"],["Chungnam","충청남도"],
    ["Jeonbuk","전북특별자치도"],["Jeonnam","전라남도"],["Gyeongbuk","경상북도"],["Gyeongnam","경상남도"],
    ["Jeju","제주특별자치도"],
  ]);
  function normalizeSidoName(name){
    const n = norm(name);
    if (SIDO_ALIAS.has(n)) return SIDO_ALIAS.get(n);
    return n;
  }

  function sigunguKey(s){ return normLoose(s); }
  function sameSigungu(a,b){
    const A = sigunguKey(a), B = sigunguKey(b);
    if (!A || !B) return false;
    if (A === B) return true;
    return A.includes(B) || B.includes(A);
  }

  function parseCityDistrict(sigunguDisp){
    const s = norm(sigunguDisp);
    if (!s) return { city:"", district:"" };

    const parts = s.split(/\s+/g).filter(Boolean);
    if (parts.length >= 2 && /(시)$/u.test(parts[0]) && /(구)$/u.test(parts[1])){
      return { city: parts[0], district: parts[1] };
    }

    const m = s.match(/^(.+?시)(.+?구)$/u);
    if (m){
      return { city: m[1], district: m[2] };
    }

    return { city: s, district: "" };
  }

  function cityGroupFromRecordSigungu(sigungu){
    const p = parseCityDistrict(sigungu);
    return p.city;
  }

  function sanitizeSelection(){
    if (state.selectedSido && state.selectedCity && !state.selectedDistrict){
      const p = parseCityDistrict(state.selectedCity);
      if (p.city && p.district){
        state.selectedCity = p.city;
        state.selectedDistrict = `${p.city} ${p.district}`;
        state.selectedDistrictShort = p.district;
        state.selectedDistrictFeature = null;
      }
    }
    if (state.selectedSido && state.selectedDistrict && !state.selectedCity){
      const p = parseCityDistrict(state.selectedDistrict);
      if (p.city){
        state.selectedCity = p.city;
      }
    }
  }

  async function fetchFirstJSON(urls){
    let lastErr = null;
    for (const url of urls){
      try{
        const res = await fetch(url, { cache:"force-cache" });
        if (!res.ok) throw new Error(`HTTP ${res.status} @ ${url}`);
        return await res.json();
      }catch(e){ lastErr = e; }
    }
    throw lastErr || new Error("fetchFirstJSON failed");
  }

  function clearMapObjects(){
    for (const p of state.polygons) p.setMap(null);
    for (const l of state.labels) l.setMap(null);
    state.polygons = [];
    state.labels = [];
  }

  function geometryToLatLngPaths(geom){
    const out = [];
    if (!geom) return out;
    const mk = (ring) => ring.map(([lng,lat]) => new kakao.maps.LatLng(lat, lng));
    if (geom.type === "Polygon"){
      const ring = geom.coordinates?.[0] || [];
      out.push(mk(ring));
    } else if (geom.type === "MultiPolygon"){
      for (const poly of (geom.coordinates || [])){
        const ring = poly?.[0] || [];
        out.push(mk(ring));
      }
    }
    return out;
  }

  function featureBounds(feature){
    const b = new kakao.maps.LatLngBounds();
    const geom = feature?.geometry;
    if (!geom) return b;

    const coordsList = [];
    if (geom.type === "Polygon") coordsList.push(geom.coordinates);
    if (geom.type === "MultiPolygon") coordsList.push(...geom.coordinates);

    for (const poly of coordsList){
      if (!poly || !poly[0]) continue;
      for (const [lng,lat] of poly[0]){
        b.extend(new kakao.maps.LatLng(lat, lng));
      }
    }
    return b;
  }

  function boundsCenter(b){
    try{
      const sw = b.getSouthWest();
      const ne = b.getNorthEast();
      const lat = (sw.getLat() + ne.getLat()) / 2;
      const lng = (sw.getLng() + ne.getLng()) / 2;
      return { lat, lng };
    }catch(e){ return null; }
  }

  function featureCentroid(feature){
    const geom = feature?.geometry;
    if (!geom) return null;

    let ring = null;
    if (geom.type === "Polygon") ring = geom.coordinates?.[0];
    if (geom.type === "MultiPolygon") ring = geom.coordinates?.[0]?.[0];
    if (!ring || ring.length === 0) return null;

    let sx=0, sy=0, n=0;
    for (const [lng,lat] of ring){ sx += lng; sy += lat; n++; }
    return { lng: sx/n, lat: sy/n };
  }

  function getFeatureName(feature){
    const p = feature?.properties || {};
    return norm(p.name || p.NAME_1 || p.NAME_2 || p.NAME || p.CTP_KOR_NM || p.SIG_KOR_NM || p.adm_nm || "");
  }

  // ✅ (핵심) 시군구 feature가 어떤 시도 소속인지 "속성값"으로 먼저 판별
  function getSigunguSidoFromFeature(f){
    const p = f?.properties || {};
    const cand = [
      p.CTP_KOR_NM,
      p.province,
      p.NAME_1,
      p.SIDO,
      p.sido,
      norm(p.adm_nm||"").split(/\s+/g)[0],
      (norm(p.name||"").includes(" ") ? norm(p.name||"").split(/\s+/g)[0] : ""),
      (norm(p.SIG_KOR_NM||"").includes(" ") ? norm(p.SIG_KOR_NM||"").split(/\s+/g)[0] : ""),
    ].map(x => normalizeSidoName(norm(x))).filter(Boolean);

    return cand[0] || "";
  }

  function dongGetNames(feature){
    const p = feature?.properties || {};
    const adm = norm(p.adm_nm || "");
    const parts = adm.split(/\s+/g).filter(Boolean);
    const sido = parts[0] || norm(p.sido || p.CTP_KOR_NM || "");
    const sigungu = parts.slice(1, parts.length-1).join(" ") || norm(p.sigungu || p.SIG_KOR_NM || p.sgg_nm || "");
    const dong = parts[parts.length-1] || norm(p.emd_nm || p.DONG || "");
    return { sido, sigungu, dong };
  }

  function uniq(arr){ return Array.from(new Set(arr)); }

  function pointInRing(pt, ring){
    let inside = false;
    for (let i=0, j=ring.length-1; i<ring.length; j=i++){
      const xi = ring[i][0], yi = ring[i][1];
      const xj = ring[j][0], yj = ring[j][1];
      const intersect = ((yi > pt.lat) !== (yj > pt.lat)) &&
        (pt.lng < (xj - xi) * (pt.lat - yi) / ((yj - yi) || 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function pointInFeature(pt, feature){
    const g = feature?.geometry;
    if (!g) return false;
    if (g.type === "Polygon"){
      const ring = g.coordinates?.[0];
      if (!ring) return false;
      return pointInRing(pt, ring);
    }
    if (g.type === "MultiPolygon"){
      for (const poly of (g.coordinates || [])){
        const ring = poly?.[0];
        if (ring && pointInRing(pt, ring)) return true;
      }
      return false;
    }
    return false;
  }

  const GU_TO_SIDO = new Map([
    ["영등포구","서울특별시"],["강서구","서울특별시"],["분당구","경기도"],["수지구","경기도"],["기흥구","경기도"],
    ["일산서구","경기도"],["일산동구","경기도"],["덕양구","경기도"],
  ]);
  const DISTRICT_TO_FULL_SIGUNGU = new Map([
    ["분당구","성남시 분당구"],["수지구","용인시 수지구"],["기흥구","용인시 기흥구"],
    ["일산서구","고양시 일산서구"],["일산동구","고양시 일산동구"],["덕양구","고양시 덕양구"],
  ]);
  const CITY_TO_SIDO = new Map([
    ["용인시","경기도"],["화성시","경기도"],["성남시","경기도"],["고양시","경기도"],
  ]);

  function normalizeVendorName(v){
    const x = norm(v);
    if (x === "제일로지스") return "제일로직스";
    return x;
  }

  function parseDataText(text){
    const lines = (text || "").split(/\r?\n/g).map(s => s.trim()).filter(Boolean);
    const out = [];

    for (const line of lines){
      const parts = line.split(/\s+/g).filter(Boolean);
      if (parts.length < 3) continue;

      let vendor = normalizeVendorName(parts[parts.length-1]);
      const addr = parts.slice(0, -1);

      let sido="", sigungu="", dong="";
      const first = addr[0] || "";
      const isSidoToken = /(특별시|광역시|특별자치시|특별자치도|도)$/u.test(first);

      if (isSidoToken){
        sido = normalizeSidoName(first);
        if (addr.length >= 3){
          const t1 = addr[1], t2 = addr[2];
          if (/(시|군)$/u.test(t1) && /(구)$/u.test(t2)){
            sigungu = `${t1} ${t2}`;
            dong = addr[3] || "";
          } else {
            sigungu = t1;
            dong = t2;
          }
        }
      } else {
        if (/(구)$/u.test(first)){
          sido = GU_TO_SIDO.get(first) || "서울특별시";
          sigungu = DISTRICT_TO_FULL_SIGUNGU.get(first) || first;
          dong = addr[1] || "";
        } else if (/(시|군)$/u.test(first)){
          sido = CITY_TO_SIDO.get(first) || "경기도";
          if (addr.length >= 3 && /(구)$/u.test(addr[1])){
            sigungu = `${first} ${addr[1]}`;
            dong = addr[2] || "";
          } else {
            sigungu = first;
            dong = addr[1] || "";
          }
        } else {
          sido = "서울특별시";
          sigungu = first;
          dong = addr[1] || "";
        }
      }

      sido = norm(sido); sigungu = norm(sigungu); dong = norm(dong);
      if (!sido || !sigungu || !dong || !vendor) continue;

      out.push({sido, sigungu, dong, vendor});
    }

    const seen = new Set();
    const uniqOut = [];
    for (const r of out){
      const k = `${r.vendor}|${r.sido}|${r.sigungu}|${r.dong}`;
      if (seen.has(k)) continue;
      seen.add(k);
      uniqOut.push(r);
    }
    return uniqOut;
  }

  function filteredRecords(){
    const vf = norm(state.vendorFilter);
    return state.records.filter(r => !vf || r.vendor === vf);
  }

  function recordsInScope(){
    sanitizeSelection();

    const recs = filteredRecords();
    const s = norm(state.selectedSido);
    const c = norm(state.selectedCity);
    const d = norm(state.selectedDistrict);

    return recs.filter(r => {
      if (s && normLoose(r.sido) !== normLoose(s)) return false;

      if (c){
        const rg = cityGroupFromRecordSigungu(r.sigungu);
        if (normLoose(rg) !== normLoose(c)) return false;
      }

      if (d){
        if (!sameSigungu(r.sigungu, d)) return false;
      }
      return true;
    });
  }

  function vendorDistList(){
    const recs = recordsInScope();
    const m = new Map();
    for (const r of recs) m.set(r.vendor, (m.get(r.vendor)||0)+1);
    return Array.from(m.entries()).sort((a,b)=>a[0].localeCompare(b[0],'ko'));
  }

  function dongByVendorList(){
    const recs = recordsInScope();
    const m = new Map();
    for (const r of recs){
      const key = r.dong;
      if (!m.has(key)) m.set(key, new Map());
      const vm = m.get(key);
      vm.set(r.vendor, (vm.get(r.vendor)||0)+1);
    }
    const dongs = Array.from(m.keys()).sort((a,b)=>a.localeCompare(b,'ko'));
    return dongs.map(d => {
      const vendors = Array.from(m.get(d).entries()).sort((a,b)=>a[0].localeCompare(b[0],'ko'));
      return { dong:d, vendors };
    });
  }

  function buildScopeLabel(){
    sanitizeSelection();

    const s = norm(state.selectedSido);
    const c = norm(state.selectedCity);
    const d = norm(state.selectedDistrict);

    if (!s) return { short:"전체", long:"전체" };
    if (s && !c) return { short:s, long:s };
    if (s && c && !d) return { short:s, long:`${s} / ${c}` };
    return { short:s, long:`${s} / ${c} / ${state.selectedDistrictShort || d}` };
  }

  function refreshRightPanel(){
    const scope = buildScopeLabel();
    els.scopePill.textContent = scope.short;
    els.scopeText.textContent = scope.long;

    els.vendorText.textContent = state.vendorFilter ? state.vendorFilter : "전체";
    els.uniqText.textContent = recordsInScope().length;

    const vd = vendorDistList();
    els.vendorDist.innerHTML = "";
    els.vendorDistEmpty.style.display = vd.length ? "none" : "block";
    for (const [name,cnt] of vd){
      const li = document.createElement('li');
      li.textContent = `${name}: ${cnt}`;
      els.vendorDist.appendChild(li);
    }

    const dbv = dongByVendorList();
    els.dongByVendors.innerHTML = "";
    els.dongByVendorsEmpty.style.display = dbv.length ? "none" : "block";
    for (const item of dbv){
      const li = document.createElement('li');
      li.textContent = `${item.dong} (${item.vendors.length}업체): ${item.vendors.map(([v,c])=>`${v}(${c})`).join(", ")}`;
      els.dongByVendors.appendChild(li);
    }
  }

  async function loadSido(){
    if (state.cache.sido) return state.cache.sido;
    const json = await fetchFirstJSON(BOUNDARY.SIDO_URLS);
    state.cache.sido = json;
    return json;
  }
  async function loadSigungu(){
    if (state.cache.sigungu) return state.cache.sigungu;
    const json = await fetchFirstJSON(BOUNDARY.SIGUNGU_URLS);
    state.cache.sigungu = json;
    return json;
  }
  async function loadDongForSido(sidoName){
    const key = normalizeSidoName(sidoName);
    if (state.cache.dongBySido.has(key)) return state.cache.dongBySido.get(key);
    const json = await fetchFirstJSON(BOUNDARY.DONG_URL_TEMPLATE(key));
    state.cache.dongBySido.set(key, json);
    return json;
  }
  async function tryLoadDongForSido(sidoName){
    try{ return await loadDongForSido(sidoName); }
    catch(e){ console.warn("[DONG] load failed:", e?.message || e); return null; }
  }

  function stripSidoPrefix(name, sido){
    const n = norm(name);
    const s = norm(sido);
    if (!n || !s) return n;
    if (n.startsWith(s)) return norm(n.slice(s.length));
    return n;
  }

  function findSidoFeatureByName(sidoGeo, sidoName){
    const target = normLoose(normalizeSidoName(sidoName));
    const feats = sidoGeo?.features || [];
    for (const f of feats){
      const nm = normLoose(normalizeSidoName(getFeatureName(f)));
      if (nm === target) return f;
    }
    return null;
  }

  // (구버전) geometry 기반 포함 판별 — fallback용
  function filterSigunguBySidoGeometry(sigunguGeo, sidoFeature){
    const feats = sigunguGeo?.features || [];
    if (!sidoFeature) return feats;

    const out = [];
    for (const f of feats){
      const c = featureCentroid(f);
      let pt = null;
      if (c) pt = { lng: c.lng, lat: c.lat };
      else{
        const bc = boundsCenter(featureBounds(f));
        if (bc) pt = { lng: bc.lng, lat: bc.lat };
      }
      if (!pt) continue;
      if (pointInFeature(pt, sidoFeature)) out.push(f);
    }
    return out.length ? out : feats;
  }

  // ✅ (핵심) 속성 기반 우선 필터 + geometry fallback
  function filterSigunguForSido(sigunguGeo, sidoGeo, focusSido){
    const fs = normalizeSidoName(focusSido || "");
    const feats = sigunguGeo?.features || [];
    if (!fs) return feats;

    // 1) 속성(CTP_KOR_NM 등)으로 먼저 걸러서 "누락 0"에 가깝게
    const byProp = feats.filter(f => {
      const s = getSigunguSidoFromFeature(f);
      return s && normLoose(s) === normLoose(fs);
    });
    if (byProp.length) return byProp;

    // 2) 속성이 없으면 geometry fallback
    const sidoFeature = findSidoFeatureByName(sidoGeo, fs);
    return filterSigunguBySidoGeometry(sigunguGeo, sidoFeature);
  }

  function makeLabelOverlay(lat, lng, name, count, onClick){
    const div = document.createElement('div');
    div.className = 'region-label';

    const nameEl = document.createElement('span');
    nameEl.className = 'name';
    nameEl.textContent = name;
    div.appendChild(nameEl);

    if (count > 0){
      const c = document.createElement('span');
      c.className = 'count';
      c.textContent = String(count);
      div.appendChild(c);
    }

    div.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      onClick?.();
    });

    const overlay = new kakao.maps.CustomOverlay({
      position: new kakao.maps.LatLng(lat, lng),
      content: div,
      yAnchor: 0.5,
      xAnchor: 0.5,
      zIndex: 5
    });
    overlay.setMap(state.map);
    state.labels.push(overlay);
  }

  function drawFeaturePolygons(features, style, onClickFeature, nameGetter){
    for (const f of features){
      const name = nameGetter ? nameGetter(f) : getFeatureName(f);
      const paths = geometryToLatLngPaths(f.geometry);
      for (const path of paths){
        const poly = new kakao.maps.Polygon({
          path,
          strokeWeight: style.strokeWeight,
          strokeColor: style.strokeColor,
          strokeOpacity: style.strokeOpacity,
          strokeStyle: 'solid',
          fillColor: style.fillColor,
          fillOpacity: style.fillOpacity
        });
        poly.setMap(state.map);
        state.polygons.push(poly);

        kakao.maps.event.addListener(poly, 'mouseover', () => {
          poly.setOptions({ fillOpacity: Math.min(style.fillOpacity + 0.10, 0.30) });
        });
        kakao.maps.event.addListener(poly, 'mouseout', () => {
          poly.setOptions({ fillOpacity: style.fillOpacity });
        });
        kakao.maps.event.addListener(poly, 'click', () => onClickFeature?.(f, name));
      }
    }
  }

  function vendorCountForSido(sidoName){
    const vf = norm(state.vendorFilter);
    const recs = state.records.filter(r => (!vf || r.vendor===vf) && normLoose(r.sido)===normLoose(sidoName));
    return new Set(recs.map(r => r.vendor)).size;
  }
  function vendorCountForCity(sidoName, cityName){
    const vf = norm(state.vendorFilter);
    const recs = state.records.filter(r => {
      if (vf && r.vendor!==vf) return false;
      if (sidoName && normLoose(r.sido)!==normLoose(sidoName)) return false;
      const cg = cityGroupFromRecordSigungu(r.sigungu);
      if (cityName && normLoose(cg)!==normLoose(cityName)) return false;
      return true;
    });
    return new Set(recs.map(r => r.vendor)).size;
  }
  function vendorCountForDistrict(sidoName, districtFull){
    const vf = norm(state.vendorFilter);
    const recs = state.records.filter(r => {
      if (vf && r.vendor!==vf) return false;
      if (sidoName && normLoose(r.sido)!==normLoose(sidoName)) return false;
      if (districtFull && !sameSigungu(r.sigungu, districtFull)) return false;
      return true;
    });
    return new Set(recs.map(r => r.vendor)).size;
  }
  function vendorCountForCanonDong(sidoName, scopeSigunguOrCity, canonDong){
    const vf = norm(state.vendorFilter);
    const recs = state.records.filter(r => {
      if (vf && r.vendor !== vf) return false;
      if (sidoName && normLoose(r.sido) !== normLoose(sidoName)) return false;

      if (scopeSigunguOrCity){
        if (state.selectedDistrict){
          if (!sameSigungu(r.sigungu, scopeSigunguOrCity)) return false;
        }else{
          const cg = cityGroupFromRecordSigungu(r.sigungu);
          if (normLoose(cg) !== normLoose(scopeSigunguOrCity)) return false;
        }
      }

      if (canonDong && dongCanon(r.dong) !== canonDong) return false;
      return true;
    });
    return new Set(recs.map(r => r.vendor)).size;
  }

  function buildCityMetaForSido(sigunguFeatures, focusSido){
    const fs = normalizeSidoName(focusSido || "");
    const byCity = new Map();

    for (const f of sigunguFeatures){
      const raw = norm(getFeatureName(f));
      const disp = stripSidoPrefix(raw, fs) || raw;

      const parts = parseCityDistrict(disp);
      const city = parts.city || disp;

      if (!byCity.has(city)){
        byCity.set(city, { city, hasDistricts: false, bounds: new kakao.maps.LatLngBounds(), features: [] });
      }

      const meta = byCity.get(city);
      meta.features.push({ f, disp, parts });
      if (parts.district) meta.hasDistricts = true;

      const b = featureBounds(f);
      try{
        meta.bounds.extend(b.getSouthWest());
        meta.bounds.extend(b.getNorthEast());
      }catch(e){}
    }

    for (const meta of byCity.values()){
      meta.center = boundsCenter(meta.bounds);
    }

    return byCity;
  }

  async function ensureCityMeta(sidoName){
    const s = normalizeSidoName(sidoName || "");
    if (!s) return null;
    if (state.cache.cityMetaBySido.has(s)) return state.cache.cityMetaBySido.get(s);

    const [sidoGeo, sigunguGeo] = await Promise.all([loadSido(), loadSigungu()]);

    // ✅ 여기서부터가 수정 핵심: "속성 기반 우선"으로 시군구를 정확히 포함
    const featsInSido = filterSigunguForSido(sigunguGeo, sidoGeo, s);

    const meta = buildCityMetaForSido(featsInSido, s);
    state.cache.cityMetaBySido.set(s, meta);
    return meta;
  }

  function currentLayerName(cityMetaMap){
    sanitizeSelection();

    const s = norm(state.selectedSido);
    const c = norm(state.selectedCity);
    const d = norm(state.selectedDistrict);

    if (!s) return "sido";
    if (s && !c) return "city";

    const meta = cityMetaMap?.get(c);
    const hasDistricts = !!meta?.hasDistricts;

    if (c && hasDistricts && !d) return "district";
    return "dong";
  }

  async function renderMap(){
    const mySeq = ++state.renderSeq;
    state.renderInFlight = true;
    showLoading(true);

    try{
      sanitizeSelection();

      const [sidoGeo, sigunguGeo] = await Promise.all([loadSido(), loadSigungu()]);
      if (mySeq !== state.renderSeq) return;

      clearMapObjects();

      const s = normalizeSidoName(state.selectedSido);
      const c = norm(state.selectedCity);
      const d = norm(state.selectedDistrict);

      const styleSIDO = { strokeWeight: 3, strokeColor:'#2563eb', strokeOpacity:0.62, fillColor:'#2563eb', fillOpacity:0.04 };
      const styleCITY = { strokeWeight: 2, strokeColor:'#2563eb', strokeOpacity:0.40, fillColor:'#2563eb', fillOpacity:0.045 };
      const styleDIST = { strokeWeight: 3, strokeColor:'#2563eb', strokeOpacity:0.65, fillColor:'#2563eb', fillOpacity:0.06 };
      const styleDONG = { strokeWeight: 2, strokeColor:'#2563eb', strokeOpacity:0.78, fillColor:'#2563eb', fillOpacity:0.07 };
      const styleDIST_HL = { strokeWeight: 5, strokeColor:'#1d4ed8', strokeOpacity:0.75, fillColor:'#1d4ed8', fillOpacity:0.00 };

      let cityMetaMap = null;
      if (s) cityMetaMap = await ensureCityMeta(s);
      if (mySeq !== state.renderSeq) return;

      const layer = currentLayerName(cityMetaMap);
      els.dongToggleWrap.style.display = (layer === "dong") ? "flex" : "none";

      if (layer === "sido"){
        const feats = (sidoGeo.features || []).map(f => { f.__fixedName = normalizeSidoName(getFeatureName(f)); return f; });

        drawFeaturePolygons(feats, styleSIDO, (f, nm0) => {
          const nm = normalizeSidoName(f.__fixedName || nm0);
          selectSido(nm, f);
        });

        for (const f of feats){
          const nm = normalizeSidoName(f.__fixedName || getFeatureName(f));
          const cc = featureCentroid(f) || boundsCenter(featureBounds(f));
          if (!cc) continue;
          const vcnt = vendorCountForSido(nm);
          makeLabelOverlay(cc.lat, cc.lng, nm, vcnt, () => selectSido(nm, f));
        }
        return;
      }

      if (layer === "city"){
        const byCity = cityMetaMap || new Map();

        for (const meta of byCity.values()){
          drawFeaturePolygons(
            meta.features.map(x=>x.f),
            styleCITY,
            () => selectCity(meta.city, meta),
            (f) => {
              const raw = norm(getFeatureName(f));
              return stripSidoPrefix(raw, s) || raw;
            }
          );

          const cc = meta.center;
          if (!cc) continue;
          const vcnt = vendorCountForCity(s, meta.city);
          makeLabelOverlay(cc.lat, cc.lng, meta.city, vcnt, () => selectCity(meta.city, meta));
        }
        return;
      }

      if (layer === "district"){
        const meta = cityMetaMap?.get(c);
        if (!meta){
          state.selectedCity = "";
          refreshCrumbs(); refreshRightPanel();
          scheduleRender();
          return;
        }

        const feats = meta.features
          .filter(x => !!x.parts.district)
          .map(x => {
            x.f.__districtShort = x.parts.district;
            x.f.__districtFull = `${x.parts.city} ${x.parts.district}`;
            return x.f;
          });

        drawFeaturePolygons(feats, styleDIST, (f) => {
          selectDistrict(f.__districtFull || "", f.__districtShort || "", f);
        }, (f) => f.__districtShort || getFeatureName(f));

        for (const f of feats){
          const short = f.__districtShort || "";
          const full = f.__districtFull || "";
          const cc = featureCentroid(f) || boundsCenter(featureBounds(f));
          if (!cc) continue;
          const vcnt = vendorCountForDistrict(s, full);
          makeLabelOverlay(cc.lat, cc.lng, short, vcnt, () => selectDistrict(full, short, f));
        }
        return;
      }

      // ===== dong =====
      const scopeSigOrCity = d ? d : c;

      const dongGeo = await tryLoadDongForSido(s);
      if (!dongGeo){
        state.selectedDistrict = "";
        state.selectedDistrictShort = "";
        state.selectedDistrictFeature = null;
        refreshCrumbs(); refreshRightPanel();
        scheduleRender();
        return;
      }
      if (mySeq !== state.renderSeq) return;

      const districtFeature = state.selectedDistrictFeature;

      const featsAll = dongGeo.features || [];
      const feats = featsAll.filter(f => {
        const n = dongGetNames(f);
        const sidoOk = normLoose(normalizeSidoName(n.sido)) === normLoose(s);
        if (!sidoOk) return false;

        if (d && districtFeature){
          const c0 = featureCentroid(f);
          const bc = !c0 ? boundsCenter(featureBounds(f)) : null;
          const pt = c0 ? { lng:c0.lng, lat:c0.lat } : (bc ? { lng:bc.lng, lat:bc.lat } : null);
          if (!pt) return false;
          return pointInFeature(pt, districtFeature);
        }

        if (d){
          return sameSigungu(norm(n.sigungu), d);
        }

        const cg = parseCityDistrict(norm(n.sigungu)).city;
        return normLoose(cg) === normLoose(c);
      });

      if (d && districtFeature){
        drawFeaturePolygons([districtFeature], styleDIST_HL, () => {}, () => "");
      }

      const dataCanonSet = new Set(recordsInScope().map(r => dongCanon(r.dong)).filter(Boolean));

      const featsToDraw = state.showAllDongs
        ? feats
        : feats.filter(f => {
            const n = dongGetNames(f);
            const canon = dongCanon(n.dong);
            return canon && dataCanonSet.has(canon);
          });

      drawFeaturePolygons(featsToDraw, styleDONG, () => {}, (f) => {
        const n = dongGetNames(f);
        return n.dong;
      });

      const labeled = new Set();
      for (const f of featsToDraw){
        const n = dongGetNames(f);
        const dongName = norm(n.dong);
        const sg = norm(n.sigungu);
        if (!dongName) continue;

        const key = `${sg}|${dongName}`;
        if (labeled.has(key)) continue;

        const cc0 = featureCentroid(f);
        const cc = cc0 ? { lat:cc0.lat, lng:cc0.lng } : boundsCenter(featureBounds(f));
        if (!cc) continue;

        const canon = dongCanon(dongName);
        const vcnt = canon ? vendorCountForCanonDong(s, scopeSigOrCity, canon) : 0;

        if (!state.showAllDongs){
          if (!canon || !dataCanonSet.has(canon) || vcnt <= 0) continue;
        }

        labeled.add(key);
        makeLabelOverlay(cc.lat, cc.lng, dongName, vcnt, () => {});
      }

    } finally {
      if (mySeq === state.renderSeq) showLoading(false);
      state.renderInFlight = false;
      if (state.pendingRender){
        state.pendingRender = false;
        scheduleRender();
      }
    }
  }

  function selectSido(sidoName, feature){
    state.selectedSido = normalizeSidoName(sidoName);
    state.selectedCity = "";
    state.selectedDistrict = "";
    state.selectedDistrictShort = "";
    state.selectedDistrictFeature = null;
    refreshCrumbs();
    refreshRightPanel();

    const b = featureBounds(feature);
    if (!b.isEmpty()) state.map.setBounds(b);
    scheduleRender();
  }

  function selectCity(cityName, meta){
    const p = parseCityDistrict(cityName);
    state.selectedCity = norm(p.city || cityName);
    state.selectedDistrict = "";
    state.selectedDistrictShort = "";
    state.selectedDistrictFeature = null;
    refreshCrumbs();
    refreshRightPanel();

    if (meta?.bounds && !meta.bounds.isEmpty()){
      state.map.setBounds(meta.bounds);
    }
    scheduleRender();
  }

  function selectDistrict(districtFull, districtShort, feature){
    const p = parseCityDistrict(districtFull);
    if (p.city) state.selectedCity = p.city;

    state.selectedDistrict = norm(districtFull);
    state.selectedDistrictShort = norm(districtShort || p.district || "");
    state.selectedDistrictFeature = feature || null;

    refreshCrumbs();
    refreshRightPanel();

    const b = featureBounds(feature);
    if (!b.isEmpty()) state.map.setBounds(b);
    scheduleRender();
  }

  function clearSelectionToAll(){
    state.selectedSido = "";
    state.selectedCity = "";
    state.selectedDistrict = "";
    state.selectedDistrictShort = "";
    state.selectedDistrictFeature = null;
    refreshCrumbs();
    refreshRightPanel();

    state.map.setLevel(13);
    state.map.setCenter(new kakao.maps.LatLng(36.5, 127.9));
    scheduleRender();
  }

  function goUpOneStep(){
    if (state.selectedDistrict){
      state.selectedDistrict = "";
      state.selectedDistrictShort = "";
      state.selectedDistrictFeature = null;
    }else if (state.selectedCity){
      state.selectedCity = "";
      state.selectedDistrictFeature = null;
    }else if (state.selectedSido){
      state.selectedSido = "";
      state.selectedDistrictFeature = null;
    }
    refreshCrumbs();
    refreshRightPanel();
    scheduleRender();
  }

  function refreshCrumbs(){
    sanitizeSelection();

    els.crumbs.innerHTML = "";

    const make = (label, active, onClick) => {
      const d = document.createElement('div');
      d.className = 'chip' + (active ? ' active' : '');
      d.textContent = label;
      d.addEventListener('click', onClick);
      return d;
    };

    els.crumbs.appendChild(make("전체", !state.selectedSido, () => clearSelectionToAll()));

    if (state.selectedSido){
      els.crumbs.appendChild(make(state.selectedSido, true, () => {
        state.selectedCity = "";
        state.selectedDistrict = "";
        state.selectedDistrictShort = "";
        state.selectedDistrictFeature = null;
        refreshCrumbs();
        refreshRightPanel();
        scheduleRender();
      }));
    }

    if (state.selectedCity){
      els.crumbs.appendChild(make(state.selectedCity, true, () => {
        state.selectedDistrict = "";
        state.selectedDistrictShort = "";
        state.selectedDistrictFeature = null;
        refreshCrumbs();
        refreshRightPanel();
        scheduleRender();
      }));
    }

    if (state.selectedDistrict){
      els.crumbs.appendChild(make(state.selectedDistrictShort || state.selectedDistrict, true, () => {}));
    }

    if (state.selectedSido || state.selectedCity || state.selectedDistrict){
      els.crumbs.appendChild(make("← 한 단계 위", false, () => goUpOneStep()));
    }
  }

  let renderTimer = null;
  function scheduleRender(){
    if (state.renderInFlight){
      state.pendingRender = true;
      return;
    }
    if (renderTimer) clearTimeout(renderTimer);
    renderTimer = setTimeout(() => { renderMap().catch(console.error); }, 60);
  }

  function refreshVendorSelect(){
    const vendors = uniq(state.records.map(r => r.vendor)).sort((a,b)=>a.localeCompare(b,'ko'));
    const cur = state.vendorFilter;
    els.vendorSel.innerHTML = `<option value="">업체: 전체</option>` + vendors.map(v => `<option value="${v}">${v}</option>`).join("");
    els.vendorSel.value = cur || "";
  }

  function setRecords(records){
    state.records = records || [];
    els.dataCountPill.textContent = `데이터: ${state.records.length}건`;
    refreshVendorSelect();
    refreshRightPanel();
    scheduleRender();
  }

  async function runSearch(){
    const q = norm(els.q.value);
    if (!q){ scheduleRender(); return; }

    const vendors = new Set(state.records.map(r => r.vendor));
    if (vendors.has(q)){
      state.vendorFilter = q;
      els.vendorSel.value = q;
      refreshRightPanel();
      scheduleRender();
      return;
    }

    const sidoTry = normalizeSidoName(q);
    const sidoExists = new Set(state.records.map(r => r.sido)).has(sidoTry);
    if (sidoExists){
      state.selectedSido = sidoTry;
      state.selectedCity = "";
      state.selectedDistrict = "";
      state.selectedDistrictShort = "";
      state.selectedDistrictFeature = null;
      refreshCrumbs();
      refreshRightPanel();
      scheduleRender();
      return;
    }

    if (state.selectedSido){
      const byCity = await ensureCityMeta(state.selectedSido);
      if (byCity && byCity.has(q)){
        selectCity(q, byCity.get(q));
        return;
      }
    }

    const sigSet = new Set(state.records.map(r => sigunguKey(r.sigungu)));
    if (sigSet.has(sigunguKey(q))){
      const r = state.records.find(x => sameSigungu(x.sigungu, q));
      state.selectedSido = r?.sido || "";
      state.selectedCity = cityGroupFromRecordSigungu(r?.sigungu || "");
      state.selectedDistrict = r?.sigungu || q;
      state.selectedDistrictShort = parseCityDistrict(state.selectedDistrict).district || state.selectedDistrict;
      state.selectedDistrictFeature = null;
      refreshCrumbs();
      refreshRightPanel();
      scheduleRender();
      return;
    }

    const dongSet = new Set(state.records.map(r => dongCanon(r.dong)));
    if (dongSet.has(dongCanon(q))){
      const r = state.records.find(x => dongCanon(x.dong) === dongCanon(q));
      if (r){
        state.selectedSido = r.sido;
        state.selectedCity = cityGroupFromRecordSigungu(r.sigungu);
        state.selectedDistrict = r.sigungu;
        state.selectedDistrictShort = parseCityDistrict(r.sigungu).district || r.sigungu;
        state.selectedDistrictFeature = null;
        refreshCrumbs();
        refreshRightPanel();
        scheduleRender();
      }
      return;
    }

    const found = state.records.find(r => r.sido.includes(q) || r.sigungu.includes(q) || r.dong.includes(q));
    if (found){
      state.selectedSido = found.sido;
      state.selectedCity = cityGroupFromRecordSigungu(found.sigungu);
      state.selectedDistrict = found.sigungu;
      state.selectedDistrictShort = parseCityDistrict(found.sigungu).district || found.sigungu;
      state.selectedDistrictFeature = null;
      refreshCrumbs();
      refreshRightPanel();
      scheduleRender();
    }
  }

  function copySummary(){
    const scope = buildScopeLabel().long;
    const vf = state.vendorFilter ? state.vendorFilter : "전체";
    const uniqCount = recordsInScope().length;
    const vd = vendorDistList().map(([v,c]) => `- ${v}: ${c}`).join("\n");
    const dbv = dongByVendorList().map(x => `- ${x.dong} (${x.vendors.length}업체): ${x.vendors.map(([v,c])=>`${v}(${c})`).join(", ")}`).join("\n");
    const text = `[CoupangLand]\n선택범위: ${scope}\n업체필터: ${vf}\n유니크(업체+지역): ${uniqCount}\n\n[업체 분포]\n${vd || "- 없음"}\n\n[동별 업체]\n${dbv || "- 없음"}`;

    navigator.clipboard.writeText(text).then(() => alert("복사 완료"))
      .catch(() => prompt("복사 실패: 아래 텍스트를 수동 복사하세요.", text));
  }

  function exportUniqueList(){
    const rows = recordsInScope()
      .map(r => `${r.sido} ${r.sigungu} ${r.dong} ${normalizeVendorName(r.vendor)}`)
      .sort((a,b)=>a.localeCompare(b,'ko'));
    const text = rows.join("\n");
    navigator.clipboard.writeText(text).then(() => alert("유니크 목록 복사 완료"))
      .catch(() => prompt("복사 실패: 아래 텍스트를 수동 복사하세요.", text));
  }

  function loadFromStorage(){
    const t = localStorage.getItem("coupangland_data_text");
    const txt = t && t.trim() ? t : SAMPLE_TEXT;
    els.dataBox.value = txt;
    setRecords(parseDataText(txt));
  }

  function applyDataBox(){
    const txt = els.dataBox.value || "";
    localStorage.setItem("coupangland_data_text", txt);
    setRecords(parseDataText(txt));
  }

  function resetAll(){
    localStorage.removeItem("coupangland_data_text");
    state.vendorFilter = "";
    els.vendorSel.value = "";
    clearSelectionToAll();
    els.dataBox.value = SAMPLE_TEXT;
    setRecords(parseDataText(SAMPLE_TEXT));
  }

  els.btnSearch.addEventListener('click', () => runSearch().catch(console.error));
  els.q.addEventListener('keydown', (e) => { if (e.key === "Enter") runSearch().catch(console.error); });

  els.vendorSel.addEventListener('change', () => {
    state.vendorFilter = els.vendorSel.value || "";
    refreshRightPanel();
    scheduleRender();
  });

  els.btnAll.addEventListener('click', clearSelectionToAll);
  els.btnCopy.addEventListener('click', copySummary);
  els.btnReset.addEventListener('click', () => { if (confirm("데이터를 초기화할까요?")) resetAll(); });

  els.btnApply.addEventListener('click', applyDataBox);
  els.btnSample.addEventListener('click', () => { els.dataBox.value = SAMPLE_TEXT; applyDataBox(); });
  els.btnExport.addEventListener('click', exportUniqueList);

  els.toggleDataDongs.addEventListener('click', () => {
    state.showAllDongs = false;
    els.toggleDataDongs.classList.add('active');
    els.toggleAllDongs.classList.remove('active');
    scheduleRender();
  });
  els.toggleAllDongs.addEventListener('click', () => {
    state.showAllDongs = true;
    els.toggleAllDongs.classList.add('active');
    els.toggleDataDongs.classList.remove('active');
    scheduleRender();
  });

  function initMap(){
    const center = new kakao.maps.LatLng(36.5, 127.9);
    state.map = new kakao.maps.Map(els.map, { center, level: 13 });
  }

  initMap();
  refreshCrumbs();
  loadFromStorage();
  scheduleRender();
})();
</script>
</body>
</html>
