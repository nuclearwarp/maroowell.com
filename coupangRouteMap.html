<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>마루웰 라우트 편집기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:#020617;
      color:#e5e7eb;
    }
    body { display:flex; }

    .side {
      width: 380px;
      min-width: 320px;
      max-width: 440px;
      background:#020617;
      border-right:1px solid #1f2937;
      padding:14px 16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .title { font-size:1rem; font-weight:700; }
    .subtitle { font-size:0.75rem; color:#9ca3af; }

    label { font-size:0.78rem; margin-bottom:2px; display:block; }
    input[type="text"] {
      width:100%; padding:7px 10px; border-radius:8px;
      border:1px solid #374151; background:#020617; color:#e5e7eb;
      font-size:0.8rem;
    }

    .btn-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:4px; }
    button {
      border-radius:999px; border:1px solid #374151;
      background:#020617; color:#e5e7eb;
      padding:6px 12px; font-size:0.78rem;
      cursor:pointer; white-space:nowrap;
    }
    button.primary { background:#111827; border-color:#111827; }
    button.danger  { border-color:#b91c1c; color:#fecaca; }
    button:hover { background:#111827; }

    .hint { font-size:0.7rem; color:#6b7280; line-height:1.4; }
    .status-bar {
      font-size:0.7rem; padding:4px 8px; border-radius:999px;
      background:#022c22; color:#6ee7b7;
      display:inline-block; margin-top:4px;
    }
    .status-error { background:#450a0a; color:#fecaca; }

    .log-box {
      margin-top:6px;
      padding:6px 8px;
      border-radius:8px;
      border:1px solid #1f2937;
      background:#020617;
      font-size:0.7rem;
      height:160px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .log-line-time { color:#6b7280; }
    .log-line-info { color:#e5e7eb; }
    .log-line-warn { color:#fbbf24; }
    .log-line-err  { color:#f87171; }

    .map-wrap { flex:1; position:relative; }
    #map { width:100%; height:100%; }

    .overlay-badge {
      position:absolute; top:10px; left:10px;
      background:rgba(15,23,42,0.9); border:1px solid #1f2937;
      border-radius:999px; padding:4px 10px;
      font-size:0.72rem; pointer-events:none;
    }

    @media (max-width:900px) {
      body { flex-direction:column; }
      .side {
        width:100%; max-width:none;
        border-right:none; border-bottom:1px solid #1f2937;
      }
      .map-wrap { height:calc(100% - 320px); }
    }
  </style>

  <!-- Kakao Maps + drawing 라이브러리 -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&libraries=drawing"></script>
</head>
<body>
  <aside class="side">
    <div>
      <div class="title">마루웰 라우트 편집기</div>
      <div class="subtitle">캠프 + 라우트 코드 기반 · Supabase / Cloudflare route API 사용</div>
    </div>

    <div>
      <label for="campInput">캠프 이름 (예: 일산2)</label>
      <input id="campInput" type="text" placeholder="예: 일산2" />
    </div>

    <div>
      <label for="routeInput">라우트 코드 (예: 126, 126B, 126B01)</label>
      <input id="routeInput" type="text" placeholder="예: 126 또는 126B 또는 126B01" />
    </div>

    <div class="btn-row">
      <button id="loadBtn"  class="primary">불러오기(GET)</button>
      <button id="drawBtn">새로 그리기</button>
      <button id="saveBtn">저장(POST)</button>
      <button id="resetBtn" class="danger">지도 초기화</button>
    </div>

    <div class="hint">
      · 조회/저장은 <b>캠프 + 라우트 둘 다 필수</b>입니다.<br/>
      · GET은 기본적으로 <code>mode=prefix</code>로 조회하여 <b>하위 노선까지 전부 표시</b>합니다.<br/>
      · 지도에서 <b>폴리곤을 클릭하면</b> 해당 코드가 <b>편집 대상</b>으로 전환됩니다.<br/>
      · 저장은 <b>편집 대상(녹색 폴리곤)</b>만 <code>polygon_wgs84 / center_wgs84</code>로 저장됩니다.
    </div>

    <div id="apiStatus" class="status-bar">API: ready</div>
    <div id="logBox" class="log-box"></div>
  </aside>

  <div class="map-wrap">
    <div id="map"></div>
    <div class="overlay-badge" id="overlayInfo">지도 초기화 중...</div>
  </div>

  <script>
    // ================== 공통 설정 ==================
    const ROUTE_API_BASE = "https://route.maroowell.com"; // Cloudflare Worker

    const logBox      = document.getElementById("logBox");
    const apiStatus   = document.getElementById("apiStatus");
    const overlayInfo = document.getElementById("overlayInfo");
    const campInput   = document.getElementById("campInput");
    const routeInput  = document.getElementById("routeInput");
    const loadBtn     = document.getElementById("loadBtn");
    const drawBtn     = document.getElementById("drawBtn");
    const saveBtn     = document.getElementById("saveBtn");
    const resetBtn    = document.getElementById("resetBtn");

    function log(message, level = "info") {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2,"0");
      const mm = String(now.getMinutes()).padStart(2,"0");
      const ss = String(now.getSeconds()).padStart(2,"0");

      const line = document.createElement("div");

      const spanTime = document.createElement("span");
      spanTime.textContent = `[${hh}:${mm}:${ss}] `;
      spanTime.className = "log-line-time";
      line.appendChild(spanTime);

      const spanMsg = document.createElement("span");
      spanMsg.textContent = message;
      spanMsg.className = "log-line-" + level;
      line.appendChild(spanMsg);

      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;
    }

    function setApiStatus(msg, isError = false) {
      apiStatus.textContent = "API: " + msg;
      apiStatus.className = "status-bar" + (isError ? " status-error" : "");
    }

    function setOverlayText(msg) {
      overlayInfo.textContent = msg;
    }

    // ================== 색상(보기용 폴리곤) ==================
    const COLORS = [
      "#ff4b4b","#22c55e","#fbbf24","#3b82f6",
      "#22d3ee","#c084fc","#f472b6","#60a5fa",
      "#34d399","#f97316"
    ];

    function pickColor(key) {
      const s = String(key || "");
      let h = 0;
      for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
      return COLORS[h % COLORS.length];
    }

    // ================== Kakao 지도 & DrawingManager ==================
    let map;
    let drawingManager;

    // 편집 대상(녹색) 폴리곤
    let currentPolygon = null;

    // 보기용(다른 색) 폴리곤들
    let staticPolygons = [];

    // 마지막으로 로드한 전체 목록(클릭으로 편집대상 바꾸기용)
    let lastLoaded = null;

    function round6(n) { return Math.round(n * 1e6) / 1e6; }

    function rowCode(row) {
      return String(row?.full_code || row?.code || "").trim().toUpperCase();
    }

    // ================== DrawingManager.getData() 기반 좌표 추출 ==================
    function getLastPolygonPointsWgs84FromManager() {
      if (!drawingManager || typeof drawingManager.getData !== "function") return [];

      const data = drawingManager.getData([kakao.maps.drawing.OverlayType.POLYGON]);
      const polys = data?.polygon || data?.POLYGON || [];
      if (!Array.isArray(polys) || polys.length === 0) return [];

      const last = polys[polys.length - 1];
      const pts = Array.isArray(last?.points) ? last.points : [];

      const out = [];
      for (const p of pts) {
        const lng = Number(p?.x); // x = lng
        const lat = Number(p?.y); // y = lat
        if (!isFinite(lat) || !isFinite(lng)) continue;
        if (Math.abs(lat) > 90 || Math.abs(lng) > 180) continue;
        out.push({ lat: round6(lat), lng: round6(lng) });
      }
      return out;
    }

    // fallback: Polygon.getPath()에서 LatLng 추출
    function collectLatLngsFromPath(path) {
      const out = [];

      const walk = (p) => {
        if (!p) return;

        if (p instanceof kakao.maps.LatLng ||
            (typeof p.getLat === "function" && typeof p.getLng === "function")) {
          out.push(p);
          return;
        }

        if (typeof p.getLength === "function" && typeof p.getAt === "function") {
          for (let i = 0; i < p.getLength(); i++) walk(p.getAt(i));
          return;
        }

        if (Array.isArray(p) || typeof p.forEach === "function") {
          p.forEach(walk);
          return;
        }

        if (p && typeof p === "object" && ("Ma" in p) && ("La" in p)) {
          const lat = Number(p.Ma);
          const lng = Number(p.La);
          if (isFinite(lat) && isFinite(lng)) out.push(new kakao.maps.LatLng(lat, lng));
        }
      };

      walk(path);
      return out;
    }

    function getCurrentPolygonPointsWgs84() {
      const pts = getLastPolygonPointsWgs84FromManager();
      if (pts.length) return pts;

      if (currentPolygon && typeof currentPolygon.getPath === "function") {
        const latlngs = collectLatLngsFromPath(currentPolygon.getPath());
        return latlngs.map(ll => ({ lat: round6(ll.getLat()), lng: round6(ll.getLng()) }));
      }
      return [];
    }

    // ================== 오버레이 제거 ==================
    function removeAllPolygonsFromManager() {
      if (!drawingManager || typeof drawingManager.getOverlays !== "function") return;

      try {
        const overlays = drawingManager.getOverlays([kakao.maps.drawing.OverlayType.POLYGON]);
        const polys = overlays?.polygon || overlays?.POLYGON || [];
        if (!Array.isArray(polys) || !polys.length) return;

        polys.forEach((poly) => {
          try {
            drawingManager.remove(poly);
          } catch (e1) {
            try {
              drawingManager.remove(kakao.maps.drawing.OverlayType.POLYGON, poly);
            } catch (e2) {}
          }
        });
      } catch (e) {}
    }

    function clearStaticPolygons() {
      staticPolygons.forEach(p => {
        try { p.setMap(null); } catch (e) {}
      });
      staticPolygons = [];
    }

    function clearCurrentOverlays() {
      removeAllPolygonsFromManager();
      clearStaticPolygons();
      currentPolygon = null;
      setOverlayText("지도 초기화 완료. 새로 그리기 또는 불러오기 가능.");
    }

    // ================== 저장된 좌표 포맷 통합 파서 ==================
    function normalizeStoredPoint(p) {
      if (!p) return null;

      // {lat, lng}
      if (typeof p.lat === "number" && typeof p.lng === "number") {
        return { lat: p.lat, lng: p.lng };
      }

      // {latitude, longitude}
      if (typeof p.latitude === "number" && typeof p.longitude === "number") {
        return { lat: p.latitude, lng: p.longitude };
      }

      // [a,b] (lat,lng) or (lng,lat)
      if (Array.isArray(p) && p.length >= 2) {
        const a0 = Number(p[0]);
        const a1 = Number(p[1]);
        if (isFinite(a0) && isFinite(a1)) {
          // (lat,lng)
          if (Math.abs(a0) <= 90 && Math.abs(a1) <= 180) return { lat: a0, lng: a1 };
          // (lng,lat)
          if (Math.abs(a1) <= 90 && Math.abs(a0) <= 180) return { lat: a1, lng: a0 };
        }
        return null;
      }

      // {x,y} (x=lng, y=lat)
      if (typeof p.x === "number" && typeof p.y === "number") {
        return { lat: p.y, lng: p.x };
      }
      if (typeof p.X === "number" && typeof p.Y === "number") {
        return { lat: p.Y, lng: p.X };
      }

      return null;
    }

    function ringFromPoints(points) {
      const ring = [];
      for (const pt of points) {
        const n = normalizeStoredPoint(pt);
        if (!n) continue;
        if (!isFinite(n.lat) || !isFinite(n.lng)) continue;
        if (Math.abs(n.lat) > 90 || Math.abs(n.lng) > 180) continue;
        ring.push(new kakao.maps.LatLng(n.lat, n.lng));
      }
      return ring;
    }

    // polygon_wgs84 가
    //  - [point, point, ...] 또는
    //  - [ [point...], [point...] ] (ring 여러 개)
    // 를 모두 처리해서 rings 반환
    function parsePolygonWgs84ToRings(poly) {
      if (!Array.isArray(poly) || !poly.length) return [];

      const isPointLike = (v) => {
        if (!v) return false;
        if (Array.isArray(v)) return v.length >= 2 && typeof v[0] === "number" && typeof v[1] === "number";
        if (typeof v === "object") {
          return ("lat" in v && "lng" in v) || ("latitude" in v && "longitude" in v) || ("x" in v && "y" in v) || ("X" in v && "Y" in v);
        }
        return false;
      };

      // poly 자체가 ring(점들의 배열)인 경우
      if (isPointLike(poly[0])) {
        const ring = ringFromPoints(poly);
        return ring.length >= 3 ? [ring] : [];
      }

      // nested rings
      const rings = [];
      for (const maybeRing of poly) {
        if (!Array.isArray(maybeRing) || !maybeRing.length) continue;
        if (!isPointLike(maybeRing[0])) continue;
        const ring = ringFromPoints(maybeRing);
        if (ring.length >= 3) rings.push(ring);
      }
      return rings;
    }

    // ================== 렌더: 하위노선 전체 표시 + 편집대상 선택 ==================
    function renderLoadedItems(items, editableKey) {
      // items: [{key,row,rings}]
      removeAllPolygonsFromManager();
      clearStaticPolygons();
      currentPolygon = null;

      const bounds = new kakao.maps.LatLngBounds();
      let hasBounds = false;

      // 편집 대상 먼저 drawingManager에 넣기(녹색)
      const editableItem = items.find(it => it.key === editableKey);

      if (editableItem && editableItem.rings?.length) {
        const firstRing = editableItem.rings[0];
        try { drawingManager.cancel(); } catch (e) {}
        drawingManager.put(kakao.maps.drawing.OverlayType.POLYGON, firstRing);

        try {
          const ovs = drawingManager.getOverlays([kakao.maps.drawing.OverlayType.POLYGON]);
          const arr = ovs?.polygon || ovs?.POLYGON || [];
          currentPolygon = arr[arr.length - 1] || null;
        } catch (e) {
          currentPolygon = null;
        }

        firstRing.forEach(ll => { bounds.extend(ll); hasBounds = true; });
      }

      // 나머지는 보기용으로 표시 (색상 다르게)
      for (const it of items) {
        const key = it.key;
        const color = pickColor(key);

        // 편집 대상은 중복 표시 안 함(원하면 여기서 표시해도 되는데, 혼란 방지)
        if (key === editableKey) continue;

        for (const ring of it.rings) {
          ring.forEach(ll => { bounds.extend(ll); hasBounds = true; });

          const poly = new kakao.maps.Polygon({
            map,
            path: ring,
            strokeWeight: 3,
            strokeColor: color,
            strokeOpacity: 1,
            strokeStyle: "solid",
            fillColor: color,
            fillOpacity: 0.22
          });

          // ✅ 클릭하면 그 코드가 편집 대상으로 전환
          kakao.maps.event.addListener(poly, "click", () => {
            routeInput.value = key;
            log(`[LOG] 편집 대상 전환: ${key}`, "info");
            setOverlayText(`편집 대상: ${key} (총 ${items.length}개 표시중)`);
            renderLoadedItems(items, key);
          });

          staticPolygons.push(poly);
        }
      }

      if (hasBounds) map.setBounds(bounds);

      const msg = editableKey
        ? `편집 대상: ${editableKey} · 표시: ${items.length}개`
        : `표시: ${items.length}개 (편집 대상 없음)`;

      setOverlayText(msg);
    }

    // ================== 지도 초기화 ==================
    function initMap() {
      const center = new kakao.maps.LatLng(37.5665, 126.9780);
      map = new kakao.maps.Map(document.getElementById("map"), {
        center,
        level: 7
      });

      const COORD_WGS84 = (kakao?.maps?.drawing?.Coordinate?.WGS84) ?? "wgs84";

      const options = {
        map,
        drawingMode: [kakao.maps.drawing.OverlayType.POLYGON],
        guideTooltip: ["draw", "drag", "edit"],
        coordinate: COORD_WGS84,
        polygonOptions: {
          draggable: true,
          removable: true,
          editable: true,
          strokeWeight: 2,
          strokeColor: "#22c55e",
          strokeOpacity: 0.9,
          strokeStyle: "solid",
          fillColor: "#22c55e",
          fillOpacity: 0.3,
        },
      };

      drawingManager = new kakao.maps.drawing.DrawingManager(options);

      // drawend: 편집 대상 폴리곤이 갱신될 때 로그
      kakao.maps.event.addListener(drawingManager, "drawend", function (data) {
        currentPolygon = data?.target || null;
        const pts = getCurrentPolygonPointsWgs84();
        log(`[LOG] drawend: 편집 폴리곤 생성/수정, 점 ${pts.length}개`, pts.length >= 3 ? "info" : "warn");
        if (pts.length) log(`[DEBUG] sample: ${JSON.stringify(pts.slice(0, 3))}`, "info");
        setOverlayText(`편집 폴리곤 점 ${pts.length}개`);
      });

      setOverlayText("지도 초기화 완료.");
      log("[LOG] 지도 초기화 완료.", "info");
    }

    // ================== API 호출 ==================
    async function fetchRoute(camp, code) {
      const url = new URL(ROUTE_API_BASE + "/route");
      url.searchParams.set("camp", camp);
      url.searchParams.set("code", code);
      url.searchParams.set("mode", "prefix"); // ✅ 항상 prefix

      log(`[LOG] GET /route 요청: ${url.toString()}`, "info");
      setApiStatus("GET /route 호출 중...");

      const res = await fetch(url.toString());
      const json = await res.json().catch(() => ({}));

      if (!res.ok) {
        setApiStatus(`에러 ${res.status}`, true);
        log(`[ERR] GET /route 실패: ${JSON.stringify(json)}`, "err");
        throw new Error("GET 실패");
      }
      setApiStatus("GET 성공");
      log(`[LOG] GET /route 응답: ${JSON.stringify(json)}`, "info");
      return json;
    }

    async function saveRoute(camp, code, polygonWgs84, centerWgs84) {
      const url = ROUTE_API_BASE + "/route";
      const body = { camp, code, polygon_wgs84: polygonWgs84, center_wgs84: centerWgs84 };

      log(`[LOG] POST /route 요청: ${JSON.stringify(body)}`, "info");
      setApiStatus("POST /route 호출 중...");

      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: JSON.stringify(body),
      });
      const json = await res.json().catch(() => ({}));

      if (!res.ok) {
        setApiStatus(`POST 에러 ${res.status}`, true);
        log(`[ERR] POST /route 실패: ${JSON.stringify(json)}`, "err");
        throw new Error("POST 실패");
      }

      setApiStatus("POST 성공");
      log(`[LOG] POST /route 응답: ${JSON.stringify(json)}`, "info");
      return json;
    }

    function computeCenter(points) {
      if (!points.length) return null;
      let sumLat = 0, sumLng = 0;
      for (const p of points) { sumLat += p.lat; sumLng += p.lng; }
      return { lat: sumLat / points.length, lng: sumLng / points.length };
    }

    // ================== 로드 결과 dedupe (같은 code 중 best 선택) ==================
    function isBetterRow(candidate, current, camp) {
      const campScore = (r) => {
        if (r?.camp === camp) return 2;
        if (r?.camp == null) return 1;
        return 0;
      };
      const hasPoly = (r) => Array.isArray(r?.polygon_wgs84) && r.polygon_wgs84.length > 0;

      const c1 = campScore(candidate), c2 = campScore(current);
      if (c1 !== c2) return c1 > c2;

      const p1 = hasPoly(candidate), p2 = hasPoly(current);
      if (p1 !== p2) return p1 && !p2;

      const t1 = candidate?.updated_at ? Date.parse(candidate.updated_at) : 0;
      const t2 = current?.updated_at ? Date.parse(current.updated_at) : 0;
      return t1 > t2;
    }

    // ================== 이벤트 바인딩 ==================
    loadBtn.addEventListener("click", async () => {
      const camp = campInput.value.trim();
      const code = routeInput.value.trim();

      if (!camp || !code) {
        alert("캠프 이름과 라우트 코드를 모두 입력해주세요.");
        return;
      }

      try {
        clearCurrentOverlays();

        const data = await fetchRoute(camp, code);
        const list =
          Array.isArray(data) ? data :
          Array.isArray(data?.rows) ? data.rows :
          Array.isArray(data?.routes) ? data.routes :
          [];

        if (!list.length) {
          log(`[WARN] GET 결과 없음 (found=${data?.found ?? "?"})`, "warn");
          alert("일치하는 라우트가 없습니다.");
          return;
        }

        // 같은 code가 여러 번 올 수 있어서, code별로 best row만 선택
        const byCode = new Map();
        for (const row of list) {
          const key = rowCode(row);
          if (!key) continue;

          const cur = byCode.get(key);
          if (!cur) byCode.set(key, row);
          else if (isBetterRow(row, cur, camp)) byCode.set(key, row);
        }

        const uniqueRows = [...byCode.values()];
        const items = [];

        for (const row of uniqueRows) {
          const key = rowCode(row);
          const rings = parsePolygonWgs84ToRings(row?.polygon_wgs84);
          if (!rings.length) continue;
          items.push({ key, row, rings });
        }

        items.sort((a,b) => a.key.localeCompare(b.key));

        if (!items.length) {
          log("[ERR] 사용 가능한 polygon_wgs84가 없습니다.", "err");
          alert("사용 가능한 폴리곤 데이터가 없습니다.");
          return;
        }

        const target = code.trim().toUpperCase();

        // 기본 편집 대상 = 입력한 코드와 정확히 일치하는 것 (없으면 편집 대상 없이 표시만)
        let editableKey = items.find(it => it.key === target)?.key || null;

        // 단, 폴리곤이 딱 1개면 그걸 편집 대상으로 올려서 저장/편집이 자연스럽게 되게 함
        if (!editableKey && items.length === 1) {
          editableKey = items[0].key;
          routeInput.value = editableKey; // 저장 mismatch 방지
          log(`[WARN] 정확 일치 코드 없음 → 단일 폴리곤(${editableKey})을 편집 대상으로 설정`, "warn");
        }

        lastLoaded = { camp, query: code, items };

        // ✅ 여기서 “하위노선 전부 표시”
        renderLoadedItems(items, editableKey);

        log(`[LOG] 불러오기 완료. 표시 ${items.length}개 (편집 대상: ${editableKey ?? "없음"})`, "info");

      } catch (e) {
        console.error(e);
        alert("라우트 조회 중 오류가 발생했습니다.");
      }
    });

    drawBtn.addEventListener("click", () => {
      clearCurrentOverlays();
      lastLoaded = null;

      try { drawingManager.cancel(); } catch (e) {}
      drawingManager.select(kakao.maps.drawing.OverlayType.POLYGON);

      log("[LOG] 새로 그리기: 다각형 모드 진입. 지도를 클릭해서 영역을 그리세요.", "info");
      setOverlayText("새로 그리기 모드: 지도에서 영역을 그리세요.");
    });

    saveBtn.addEventListener("click", async () => {
      const camp = campInput.value.trim();
      const code = routeInput.value.trim();

      if (!camp || !code) {
        alert("캠프 이름과 라우트 코드를 모두 입력해주세요.");
        return;
      }

      const pts = getCurrentPolygonPointsWgs84();
      if (pts.length < 3) {
        alert("저장할 편집 폴리곤이 없습니다. (폴리곤을 선택하거나 새로 그리기 후 저장하세요)");
        log(`[LOG] 저장 실패: 편집 폴리곤 점 개수 ${pts.length}`, "err");
        return;
      }

      const center = computeCenter(pts);
      log(`[LOG] 저장 준비: code=${code}, 점 ${pts.length}개, 중심 (${center.lat.toFixed(6)}, ${center.lng.toFixed(6)})`, "info");

      try {
        await saveRoute(camp, code, pts, center);
        alert("저장 완료되었습니다.");

        // 저장 후 다시 불러와서 최신 반영(하위노선 전체 표시 유지)
        try { loadBtn.click(); } catch (e) {}
      } catch (e) {
        console.error(e);
        alert("저장 중 오류가 발생했습니다.");
      }
    });

    resetBtn.addEventListener("click", () => {
      clearCurrentOverlays();
      lastLoaded = null;
      try { drawingManager.cancel(); } catch (e) {}
      log("[LOG] 지도 초기화 완료.", "info");
      setOverlayText("지도 초기화 완료. 새로 그리기 또는 불러오기 가능.");
    });

    // ================== 초기 실행 ==================
    kakao.maps.load(initMap);
  </script>
</body>
</html>
