<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>마루웰 라우트 편집기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; background:#020617; color:#e5e7eb; }
    body { display:flex; }
    .side {
      width: 420px; min-width: 320px; max-width: 520px;
      background:#020617; border-right:1px solid #1f2937;
      padding:14px 16px; display:flex; flex-direction:column; gap:10px;
    }
    .title { font-size:1rem; font-weight:700; }
    .subtitle { font-size:0.75rem; color:#9ca3af; }
    label { font-size:0.78rem; margin-bottom:2px; display:block; }
    input[type="text"] {
      width:100%; padding:7px 10px; border-radius:8px;
      border:1px solid #374151; background:#020617; color:#e5e7eb;
      font-size:0.8rem;
    }
    .btn-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:4px; }
    button {
      border-radius:999px; border:1px solid #374151;
      background:#020617; color:#e5e7eb;
      padding:6px 12px; font-size:0.78rem;
      cursor:pointer; white-space:nowrap;
    }
    button.primary { background:#111827; border-color:#111827; }
    button.danger  { border-color:#b91c1c; color:#fecaca; }
    button:hover { background:#111827; }

    .hint { font-size:0.7rem; color:#6b7280; line-height:1.4; }
    .status-bar {
      font-size:0.7rem; padding:4px 8px; border-radius:999px;
      background:#022c22; color:#6ee7b7;
      display:inline-block; margin-top:4px;
    }
    .status-error { background:#450a0a; color:#fecaca; }

    .log-box {
      margin-top:6px;
      padding:6px 8px;
      border-radius:8px;
      border:1px solid #1f2937;
      background:#020617;
      font-size:0.7rem;
      height:170px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .log-line-time { color:#6b7280; }
    .log-line-info { color:#e5e7eb; }
    .log-line-warn { color:#fbbf24; }
    .log-line-err  { color:#f87171; }

    .map-wrap { flex:1; position:relative; }
    #map { width:100%; height:100%; }

    .overlay-badge {
      position:absolute; top:10px; left:10px;
      background:rgba(15,23,42,0.9); border:1px solid #1f2937;
      border-radius:999px; padding:4px 10px;
      font-size:0.72rem; pointer-events:none;
    }

    .section-title { margin-top:8px; font-size:0.78rem; color:#cbd5e1; font-weight:700; }
    .mini { font-size:0.7rem; color:#94a3b8; line-height:1.35; }

    .hr { height:1px; background:#111827; margin:6px 0; opacity:0.9; }

    @media (max-width:900px) {
      body { flex-direction:column; }
      .side { width:100%; max-width:none; border-right:none; border-bottom:1px solid #1f2937; }
      .map-wrap { height:calc(100% - 320px); }
    }
  </style>

  <!-- Kakao Maps + drawing 라이브러리 -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&libraries=drawing"></script>

  <!-- (선택) 정렬 확장용: turf + osmtogeojson -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/osmtogeojson@3.0.0/osmtogeojson.js"></script>
</head>
<body>
  <aside class="side">
    <div>
      <div class="title">마루웰 라우트 편집기</div>
      <div class="subtitle">캠프 + 라우트 코드 기반 · Supabase / Cloudflare route API</div>
    </div>

    <div>
      <label for="campInput">캠프 이름 (예: 일산2, 대구3)</label>
      <input id="campInput" type="text" placeholder="예: 대구3" />
    </div>

    <div>
      <label for="routeInput">라우트 코드 (예: 126, 126B, 126B01) — 비우면 camp 전체 표시</label>
      <input id="routeInput" type="text" placeholder="예: 126 (비우면 camp 전체)" />
    </div>

    <div class="btn-row">
      <button id="loadBtn"  class="primary">불러오기(GET)</button>
      <button id="drawReplaceBtn">새로 그리기</button>
      <button id="drawAddBtn">구역 추가</button>
      <button id="saveBtn" class="primary">저장(POST)</button>
      <button id="alignBtn">지도 정렬</button>
      <button id="labelBtn">라우트 라벨 OFF</button>
      <button id="hideOthersBtn">라우트 숨기기 OFF</button>
      <button id="resetBtn" class="danger">지도 초기화</button>
    </div>

    <div class="hint">
      · GET: <b>camp만 입력</b>하면 해당 camp 전체 노선 표시. code 입력 시 <code>mode=prefix</code>로 하위 노선까지 표시.<br/>
      · 지도에서 폴리곤 클릭 → <b>편집 대상</b> 전환(초록 테두리).<br/>
      · 저장: 편집 대상(또는 입력 code)의 모든 구역(멀티)을 DB에 저장.<br/>
      · 삭제: 구역을 삭제(우클릭 삭제) 후 저장하면 DB에 <code>polygon=null</code> 반영.<br/>
      · <b>drawingManager.put 사용하지 않음</b>(현재 Kakao SDK에서 put 에러 빈번). 클릭해도 폴리곤이 사라지지 않습니다.
    </div>

    <div id="apiStatus" class="status-bar">API: ready</div>
    <div id="logBox" class="log-box"></div>

    <div class="hr"></div>

    <div class="section-title">DB 수정</div>
    <div class="mini">지도에서 노선을 클릭해 편집 대상으로 만든 뒤 사용하세요.</div>

    <div style="margin-top:8px">
      <label for="campEditInput">캠프명 변경 (예: 대구3)</label>
      <input id="campEditInput" type="text" placeholder="예: 대구3" />
    </div>
    <div class="btn-row">
      <button id="patchCampBtn">선택 camp 수정</button>
      <button id="migrateCampBtn">camp 전체 이관</button>
    </div>

    <div style="margin-top:6px">
      <label for="codeEditInput">코드 변경 (예: 213D → 213E)</label>
      <input id="codeEditInput" type="text" placeholder="예: 213D" />
    </div>
    <div class="btn-row">
      <button id="renameCodeBtn">선택 코드 수정</button>
      <button id="deleteRowBtn" class="danger">선택 DB 삭제</button>
    </div>

    <div class="mini">
      · “선택 코드 수정”은 선택 노선 1건만 변경합니다(하위 prefix 일괄 변경은 Worker에 action 추가 가능).<br/>
      · “선택 DB 삭제”는 레코드 자체 삭제입니다(되돌리기 어려움).
    </div>
  </aside>

  <div class="map-wrap">
    <div id="map"></div>
    <div class="overlay-badge" id="overlayInfo">지도 초기화 중...</div>
  </div>

  <script>
    // ================== 설정 ==================
    const ROUTE_API_BASE = "https://route.maroowell.com";

    // 색상 팔레트(고대비)
    const COLOR_POOL = [
      "#e6194B","#3cb44b","#ffe119","#4363d8","#f58231","#911eb4","#46f0f0","#f032e6",
      "#bcf60c","#fabebe","#008080","#e6beff","#9a6324","#fffac8","#800000","#aaffc3",
      "#808000","#ffd8b1","#000075","#808080","#60a5fa","#f97316","#22c55e","#ef4444",
      "#a855f7","#06b6d4","#f59e0b","#84cc16","#14b8a6","#fb7185"
    ];

    // ================== DOM ==================
    const logBox      = document.getElementById("logBox");
    const apiStatus   = document.getElementById("apiStatus");
    const overlayInfo = document.getElementById("overlayInfo");

    const campInput   = document.getElementById("campInput");
    const routeInput  = document.getElementById("routeInput");

    const loadBtn     = document.getElementById("loadBtn");
    const drawReplaceBtn = document.getElementById("drawReplaceBtn");
    const drawAddBtn  = document.getElementById("drawAddBtn");
    const saveBtn     = document.getElementById("saveBtn");
    const alignBtn    = document.getElementById("alignBtn");
    const labelBtn    = document.getElementById("labelBtn");
    const hideOthersBtn = document.getElementById("hideOthersBtn");
    const resetBtn    = document.getElementById("resetBtn");

    const campEditInput = document.getElementById("campEditInput");
    const codeEditInput = document.getElementById("codeEditInput");
    const patchCampBtn  = document.getElementById("patchCampBtn");
    const migrateCampBtn= document.getElementById("migrateCampBtn");
    const renameCodeBtn = document.getElementById("renameCodeBtn");
    const deleteRowBtn  = document.getElementById("deleteRowBtn");

    // ================== 로그 ==================
    function log(message, level = "info") {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2,"0");
      const mm = String(now.getMinutes()).padStart(2,"0");
      const ss = String(now.getSeconds()).padStart(2,"0");

      const line = document.createElement("div");

      const spanTime = document.createElement("span");
      spanTime.textContent = `[${hh}:${mm}:${ss}] `;
      spanTime.className = "log-line-time";
      line.appendChild(spanTime);

      const spanMsg = document.createElement("span");
      spanMsg.textContent = message;
      spanMsg.className = "log-line-" + level;
      line.appendChild(spanMsg);

      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;
      console[level === "err" ? "error" : level === "warn" ? "warn" : "log"](message);
    }

    function setApiStatus(msg, isError = false) {
      apiStatus.textContent = "API: " + msg;
      apiStatus.className = "status-bar" + (isError ? " status-error" : "");
    }

    function setOverlayText(msg) { overlayInfo.textContent = msg; }

    window.addEventListener("error", (e) => {
      log(`[ERR] window.error: ${e.message || "Script error."}`, "err");
    });

    // ================== 상태 ==================
    const state = {
      map: null,
      drawingManager: null,

      // key = `${camp}::${full_code}`
      routes: new Map(), // key -> { row, polygons:[Polygon], labels:[CustomOverlay], color }
      edit: { key: null, regionIndex: null }, // 편집 대상
      drawMode: null, // "replace" | "add"
      labelsOn: false,
      hideOthers: false,
    };

    function makeKey(camp, code) {
      return `${camp}::${code}`;
    }

    // ================== 지도 초기화 ==================
    function initMap() {
      const center = new kakao.maps.LatLng(37.5665, 126.9780);
      state.map = new kakao.maps.Map(document.getElementById("map"), {
        center,
        level: 7
      });

      const options = {
        map: state.map,
        drawingMode: [kakao.maps.drawing.OverlayType.POLYGON],
        guideTooltip: ["draw", "drag", "edit"],
        polygonOptions: {
          draggable: true,
          removable: true,
          editable: true,
          strokeWeight: 3,
          strokeOpacity: 0.9,
          strokeStyle: "solid",
          fillOpacity: 0.25,
        },
      };

      state.drawingManager = new kakao.maps.drawing.DrawingManager(options);

      // drawend
      kakao.maps.event.addListener(state.drawingManager, "drawend", function (data) {
        const overlay = data.target;

        if (!overlay || !(overlay instanceof kakao.maps.Polygon)) {
          log("[WARN] drawend: polygon이 아님", "warn");
          return;
        }

        const pts = extractPathFromPolygon(overlay);
        if (pts.length < 3) {
          overlay.setMap(null);
          log("[ERR] drawend: 점이 부족합니다(3개 이상).", "err");
          return;
        }

        const camp = campInput.value.trim();
        const code = routeInput.value.trim();

        if (!camp) {
          overlay.setMap(null);
          alert("camp를 먼저 입력하세요.");
          return;
        }

        // 타겟 결정: 편집 대상이 있으면 그 key, 아니면 입력 code
        let key = state.edit.key;
        if (!key) {
          if (!code) {
            overlay.setMap(null);
            alert("편집 대상을 선택하거나, code를 입력한 뒤 그리세요.");
            return;
          }
          key = makeKey(camp, code);
        }

        ensureRouteState(key, { camp, full_code: key.split("::")[1] });

        const route = state.routes.get(key);

        // replace/add 처리
        if (state.drawMode === "add") {
          route.polygons.push(overlay);
          attachPolygonHandlers(key, route.polygons.length - 1, overlay);
          state.edit = { key, regionIndex: route.polygons.length - 1 };
          log(`[LOG] 구역 추가: ${key} region=${route.polygons.length - 1}, 점 ${pts.length}개`, "info");
        } else {
          // replace 기본
          const idx = state.edit.key === key && state.edit.regionIndex != null ? state.edit.regionIndex : 0;

          if (route.polygons[idx]) {
            route.polygons[idx].setMap(null);
            route.polygons[idx] = overlay;
          } else {
            route.polygons[0] = overlay;
          }

          attachPolygonHandlers(key, idx, overlay);
          state.edit = { key, regionIndex: idx };
          log(`[LOG] 새로 그리기(교체): ${key} region=${idx}, 점 ${pts.length}개`, "info");
        }

        // draw 모드 종료
        state.drawingManager.cancel();
        state.drawMode = null;
        setOverlayText(`편집 대상: ${state.edit.key?.split("::")[1] || "없음"}`);

        refreshColorsAndStyles();
        refreshLabels();
      });

      setOverlayText("지도 초기화 완료.");
      log("[LOG] 지도 초기화 완료.", "info");
    }

    kakao.maps.load(initMap);

    // ================== 좌표/폴리곤 유틸 ==================
    function normalizeStoredPoint(p) {
      if (!p) return null;

      if (typeof p.lat === "number" && typeof p.lng === "number") return { lat: p.lat, lng: p.lng };
      if (typeof p.latitude === "number" && typeof p.longitude === "number") return { lat: p.latitude, lng: p.longitude };

      if (Array.isArray(p) && p.length >= 2) {
        const a0 = Number(p[0]);
        const a1 = Number(p[1]);
        if (!isFinite(a0) || !isFinite(a1)) return null;

        // 보통 [lng,lat]
        const cand1 = { lat: a1, lng: a0 };
        const cand2 = { lat: a0, lng: a1 };
        const inKorea = (pt) => pt.lat >= 30 && pt.lat <= 45 && pt.lng >= 120 && pt.lng <= 135;
        if (inKorea(cand1)) return cand1;
        if (inKorea(cand2)) return cand2;
        return cand1;
      }

      return null;
    }

    // polygon_wgs84가 단일/멀티 모두 들어올 수 있음
    function parsePolygonWgs84(polyAny) {
      // 반환: regions = [ [LatLng...], [LatLng...] ]
      if (!polyAny || !Array.isArray(polyAny) || !polyAny.length) return [];

      const first = polyAny[0];
      const looksSingle =
        (Array.isArray(first) && typeof first[0] === "number") ||
        (typeof first === "object" && first && ("lat" in first || "lng" in first || "latitude" in first));

      const regions = looksSingle ? [polyAny] : polyAny;

      const out = [];
      for (const region of regions) {
        if (!Array.isArray(region)) continue;
        const pts = [];
        for (const p of region) {
          const np = normalizeStoredPoint(p);
          if (!np) continue;
          pts.push(new kakao.maps.LatLng(np.lat, np.lng));
        }
        if (pts.length >= 3) out.push(pts);
      }
      return out;
    }

    // kakao Polygon 객체에서 path 추출
    function extractPathFromPolygon(polygon) {
      const result = [];
      if (!polygon || typeof polygon.getPath !== "function") return result;

      let rawPath = polygon.getPath();
      if (rawPath && typeof rawPath.getArray === "function") {
        try { rawPath = rawPath.getArray(); } catch {}
      }

      const pushLatLng = (ll) => {
        if (!ll) return;
        let lat, lng;

        if (typeof ll.getLat === "function" && typeof ll.getLng === "function") {
          lat = ll.getLat(); lng = ll.getLng();
        } else if ("Ma" in ll && "La" in ll) {
          lat = ll.Ma; lng = ll.La;
        } else if ("lat" in ll && "lng" in ll) {
          lat = ll.lat; lng = ll.lng;
        } else if (Array.isArray(ll) && ll.length >= 2) {
          const a0 = Number(ll[0]); const a1 = Number(ll[1]);
          // [lat,lng] or [lng,lat]
          if (Math.abs(a0) <= 90 && Math.abs(a1) <= 180) { lat = a0; lng = a1; }
          else { lat = a1; lng = a0; }
        } else return;

        if (!isFinite(lat) || !isFinite(lng)) return;
        result.push({ lat, lng });
      };

      const walk = (x) => {
        if (!x) return;
        if (typeof x.getLength === "function" && typeof x.getAt === "function") {
          for (let i=0; i<x.getLength(); i++) walk(x.getAt(i));
          return;
        }
        if (Array.isArray(x) || typeof x.forEach === "function") {
          (x.forEach ? x : Array.from(x)).forEach(walk);
          return;
        }
        pushLatLng(x);
      };

      walk(rawPath);
      return result;
    }

    function computeCenter(points) {
      if (!points.length) return null;
      let sumLat = 0, sumLng = 0;
      for (const p of points) { sumLat += p.lat; sumLng += p.lng; }
      return { lat: sumLat / points.length, lng: sumLng / points.length };
    }

    // ================== Polylabel (라벨을 폴리곤 내부로) ==================
    function pointToLngLat(p) { return [p.lng, p.lat]; }

    function pointInRing(pt, ring) {
      // ray casting, pt: [x,y], ring: [[x,y]...]
      let inside = false;
      for (let i=0, j=ring.length-1; i<ring.length; j=i++) {
        const xi=ring[i][0], yi=ring[i][1];
        const xj=ring[j][0], yj=ring[j][1];
        const intersect = ((yi>pt[1]) !== (yj>pt[1])) &&
          (pt[0] < (xj - xi) * (pt[1] - yi) / ((yj - yi) || 1e-12) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function getSegDistSq(px, py, ax, ay, bx, by) {
      let x = ax, y = ay;
      let dx = bx - ax, dy = by - ay;
      if (dx !== 0 || dy !== 0) {
        const t = ((px - ax) * dx + (py - ay) * dy) / (dx * dx + dy * dy);
        if (t > 1) { x = bx; y = by; }
        else if (t > 0) { x += dx * t; y += dy * t; }
      }
      dx = px - x; dy = py - y;
      return dx * dx + dy * dy;
    }

    function signedDistToPolygon(pt, ring) {
      const x = pt[0], y = pt[1];
      let inside = pointInRing(pt, ring);
      let minDistSq = Infinity;

      for (let i=0, len=ring.length, j=len-1; i<len; j=i++) {
        const ax = ring[i][0], ay = ring[i][1];
        const bx = ring[j][0], by = ring[j][1];
        minDistSq = Math.min(minDistSq, getSegDistSq(x, y, ax, ay, bx, by));
      }
      const dist = Math.sqrt(minDistSq);
      return inside ? dist : -dist;
    }

    function polylabel(ring, precision = 1e-5) {
      // ring: [[lng,lat]...] (닫힘 없어도 됨)
      // bbox
      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for (const p of ring) {
        minX = Math.min(minX, p[0]); minY = Math.min(minY, p[1]);
        maxX = Math.max(maxX, p[0]); maxY = Math.max(maxY, p[1]);
      }
      const width = maxX - minX;
      const height = maxY - minY;
      const cellSize = Math.min(width, height);
      if (cellSize === 0) return [(minX+maxX)/2, (minY+maxY)/2];

      const h = cellSize / 2;

      // priority queue(간이: 배열 정렬)
      let cellQueue = [];

      function makeCell(x, y, h) {
        const d = signedDistToPolygon([x,y], ring);
        return { x, y, h, d, max: d + h * Math.SQRT2 };
      }

      for (let x=minX; x<maxX; x+=cellSize) {
        for (let y=minY; y<maxY; y+=cellSize) {
          cellQueue.push(makeCell(x+h, y+h, h));
        }
      }

      // best guess: bbox center
      let best = makeCell((minX+maxX)/2, (minY+maxY)/2, 0);
      for (const c of cellQueue) {
        if (c.d > best.d) best = c;
      }

      while (cellQueue.length) {
        cellQueue.sort((a,b)=>b.max-a.max);
        const cell = cellQueue.shift();
        if (!cell) break;

        if (cell.d > best.d) best = cell;
        if (cell.max - best.d <= precision) continue;

        const h2 = cell.h/2;
        cellQueue.push(makeCell(cell.x-h2, cell.y-h2, h2));
        cellQueue.push(makeCell(cell.x+h2, cell.y-h2, h2));
        cellQueue.push(makeCell(cell.x-h2, cell.y+h2, h2));
        cellQueue.push(makeCell(cell.x+h2, cell.y+h2, h2));
      }

      return [best.x, best.y];
    }

    function computeLabelPosition(polygon) {
      const pts = extractPathFromPolygon(polygon);
      if (pts.length < 3) return polygon.getBounds?.()?.getCenter?.() || state.map.getCenter();

      const ring = pts.map(p => [p.lng, p.lat]);
      const [x, y] = polylabel(ring, 1e-5);

      // 아주 약간 랜덤 오프셋(겹침 완화)
      const dx = 0.00002, dy = 0.00001;
      return new kakao.maps.LatLng(y + dy, x + dx);
    }

    // ================== API ==================
    async function fetchRoute(camp, codeOrNull) {
      const url = new URL(ROUTE_API_BASE + "/route");
      url.searchParams.set("mode", "prefix");

      if (camp) url.searchParams.set("camp", camp);
      if (codeOrNull) url.searchParams.set("code", codeOrNull);

      log(`[LOG] GET /route 요청: ${url.toString()}`, "info");
      setApiStatus("GET /route 호출 중...");

      const res = await fetch(url.toString(), { cache: "no-store" });
      const json = await res.json().catch(() => ({}));

      if (!res.ok) {
        setApiStatus(`에러 ${res.status}`, true);
        log(`[ERR] GET /route 실패: ${JSON.stringify(json)}`, "err");
        throw new Error("GET 실패");
      }
      setApiStatus("GET 성공");
      return json;
    }

    async function postRoute(body) {
      const url = ROUTE_API_BASE + "/route";
      log(`[LOG] POST /route 요청: ${JSON.stringify(body)}`, "info");
      setApiStatus("POST /route 호출 중...");

      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: JSON.stringify(body),
      });

      const json = await res.json().catch(() => ({}));
      if (!res.ok) {
        setApiStatus(`POST 에러 ${res.status}`, true);
        log(`[ERR] POST /route 실패: ${JSON.stringify(json)}`, "err");
        throw new Error("POST 실패");
      }

      setApiStatus("POST 성공");
      log(`[LOG] POST /route 응답: ${JSON.stringify(json)}`, "info");
      return json;
    }

    // ================== 오버레이 관리 ==================
    function clearAll() {
      for (const r of state.routes.values()) {
        r.polygons.forEach(p => p.setMap(null));
        r.labels.forEach(l => l.setMap(null));
      }
      state.routes.clear();
      state.edit = { key: null, regionIndex: null };
      setOverlayText("지도 초기화 완료. 불러오기 또는 새로 그리기 가능.");
      log("[LOG] 지도 초기화 완료.", "info");
    }

    function ensureRouteState(key, { camp, full_code }) {
      if (state.routes.has(key)) return;
      state.routes.set(key, {
        row: { id: null, camp, full_code, code: full_code },
        polygons: [],
        labels: [],
        color: null
      });
    }

    function attachPolygonHandlers(key, regionIndex, polygon) {
      // 선택
      kakao.maps.event.addListener(polygon, "click", () => {
        state.edit = { key, regionIndex };
        const code = key.split("::")[1];
        routeInput.value = code;
        setOverlayText(`편집 대상: ${code} (region ${regionIndex})`);
        log(`[LOG] 편집 대상 전환: ${code} region=${regionIndex}`, "info");
        refreshColorsAndStyles();
        refreshLabels();
      });

      // 우클릭 삭제(안정적으로 제공)
      kakao.maps.event.addListener(polygon, "rightclick", () => {
        const route = state.routes.get(key);
        if (!route) return;
        if (!confirm("이 구역을 삭제하시겠습니까? (저장 시 DB에도 반영)")) return;

        polygon.setMap(null);
        route.polygons.splice(regionIndex, 1);

        // regionIndex 재바인딩 필요: 이후 클릭 인덱스 깨짐 방지 위해 전체 재부착
        rebindAllPolygonHandlers(key);

        if (route.polygons.length === 0) {
          state.edit = { key, regionIndex: null };
          log("[WARN] 모든 구역이 삭제되었습니다. 저장하면 polygon=null 반영됩니다.", "warn");
        } else {
          state.edit = { key, regionIndex: Math.min(regionIndex, route.polygons.length - 1) };
        }

        refreshColorsAndStyles();
        refreshLabels();
      });
    }

    function rebindAllPolygonHandlers(key) {
      const route = state.routes.get(key);
      if (!route) return;
      route.polygons.forEach((poly, idx) => {
        // 기존 리스너 제거 API가 제한적이라 새로 생성이 아닌 이상 완전 제거는 어려움.
        // 여기서는 최소로: click/우클릭 핸들러 중복 방지를 위해, poly에 플래그를 둡니다.
        if (poly.__mw_bound) return;
        poly.__mw_bound = true;
        attachPolygonHandlers(key, idx, poly);
      });
    }

    // ================== 색상/스타일 ==================
    function bboxOfPolygon(poly) {
      const pts = extractPathFromPolygon(poly);
      let minLat=Infinity, minLng=Infinity, maxLat=-Infinity, maxLng=-Infinity;
      for (const p of pts) {
        minLat = Math.min(minLat, p.lat); minLng = Math.min(minLng, p.lng);
        maxLat = Math.max(maxLat, p.lat); maxLng = Math.max(maxLng, p.lng);
      }
      return { minLat, minLng, maxLat, maxLng };
    }

    function bboxesNear(a, b, pad=0.00025) {
      return !(
        a.maxLat + pad < b.minLat ||
        a.minLat - pad > b.maxLat ||
        a.maxLng + pad < b.minLng ||
        a.minLng - pad > b.maxLng
      );
    }

    function assignRouteColors() {
      // 간이 인접 그래프: bbox가 근접하면 인접으로 간주
      const keys = [...state.routes.keys()];
      const bboxes = new Map();

      for (const key of keys) {
        const r = state.routes.get(key);
        const all = r.polygons.map(bboxOfPolygon).filter(x=>isFinite(x.minLat));
        if (!all.length) continue;
        const merged = all.reduce((acc, bb) => ({
          minLat: Math.min(acc.minLat, bb.minLat),
          minLng: Math.min(acc.minLng, bb.minLng),
          maxLat: Math.max(acc.maxLat, bb.maxLat),
          maxLng: Math.max(acc.maxLng, bb.maxLng),
        }), { minLat: Infinity, minLng: Infinity, maxLat: -Infinity, maxLng: -Infinity });
        bboxes.set(key, merged);
      }

      const neighbors = new Map(keys.map(k => [k, new Set()]));
      for (let i=0; i<keys.length; i++) {
        for (let j=i+1; j<keys.length; j++) {
          const a = keys[i], b = keys[j];
          if (!bboxes.has(a) || !bboxes.has(b)) continue;
          if (bboxesNear(bboxes.get(a), bboxes.get(b))) {
            neighbors.get(a).add(b);
            neighbors.get(b).add(a);
          }
        }
      }

      // greedy coloring
      const used = new Map(); // key -> colorIndex
      for (const key of keys) {
        const usedByNbr = new Set();
        for (const nb of neighbors.get(key) || []) {
          if (used.has(nb)) usedByNbr.add(used.get(nb));
        }
        let pick = 0;
        while (usedByNbr.has(pick)) pick++;
        used.set(key, pick % COLOR_POOL.length);
      }

      for (const key of keys) {
        const idx = used.get(key) ?? 0;
        const r = state.routes.get(key);
        r.color = COLOR_POOL[idx];
      }
    }

    function refreshColorsAndStyles() {
      assignRouteColors();

      for (const [key, r] of state.routes) {
        const isEditKey = (state.edit.key === key);

        r.polygons.forEach((poly, idx) => {
          const selected = isEditKey && state.edit.regionIndex === idx;

          const color = r.color || "#22c55e";
          const hidden = state.hideOthers && state.edit.key && !isEditKey;

          poly.setMap(hidden ? null : state.map);

          poly.setOptions({
            strokeColor: selected ? "#22c55e" : color,
            strokeWeight: selected ? 6 : 3,
            strokeOpacity: selected ? 1 : (hidden ? 0 : 0.9),
            fillColor: color,
            fillOpacity: selected ? 0.22 : 0.18,
            draggable: isEditKey, // 편집 대상만 드래그 허용(혼선 방지)
          });
        });
      }
    }

    // ================== 라벨 ==================
    function clearLabels() {
      for (const r of state.routes.values()) {
        r.labels.forEach(l => l.setMap(null));
        r.labels = [];
      }
    }

    function refreshLabels() {
      clearLabels();
      if (!state.labelsOn) return;

      for (const [key, r] of state.routes) {
        const code = key.split("::")[1];
        r.polygons.forEach((poly, idx) => {
          const pos = computeLabelPosition(poly);

          const div = document.createElement("div");
          div.style.padding = "3px 8px";
          div.style.borderRadius = "999px";
          div.style.background = "rgba(15,23,42,0.75)";
          div.style.border = `1px solid ${r.color || "#94a3b8"}`;
          div.style.color = "#e5e7eb";
          div.style.fontSize = "12px";
          div.style.fontWeight = "700";
          div.style.transform = "translate(-50%, -50%)";
          div.style.whiteSpace = "nowrap";
          div.textContent = code;

          const label = new kakao.maps.CustomOverlay({
            position: pos,
            content: div,
            yAnchor: 0.5,
            xAnchor: 0.5,
          });

          // 숨김 모드 대응
          const hidden = state.hideOthers && state.edit.key && state.edit.key !== key;
          label.setMap(hidden ? null : state.map);

          r.labels.push(label);
        });
      }
    }

    // ================== 불러오기 ==================
    async function loadRoutes() {
      const camp = campInput.value.trim();
      const code = routeInput.value.trim();

      if (!camp) {
        alert("camp를 입력해주세요.");
        return;
      }

      try {
        clearAll();

        const data = await fetchRoute(camp, code || null);
        const rows = Array.isArray(data) ? data
          : Array.isArray(data?.rows) ? data.rows
          : Array.isArray(data?.routes) ? data.routes
          : [];

        if (!rows.length) {
          log("[WARN] GET 결과 없음", "warn");
          alert("일치하는 라우트가 없습니다.");
          return;
        }

        // camp null 같은 쓰레기 row 제거(기본)
        const filtered = rows.filter(r => (r?.camp || "") === camp);

        let drawn = 0;
        for (const row of filtered) {
          const full = row.full_code || row.code;
          if (!full) continue;

          const key = makeKey(camp, full);
          ensureRouteState(key, { camp, full_code: full });

          const route = state.routes.get(key);
          route.row = row;

          const regions = parsePolygonWgs84(row.polygon_wgs84);
          for (let i=0; i<regions.length; i++) {
            const poly = new kakao.maps.Polygon({
              map: state.map,
              path: regions[i],
              strokeWeight: 3,
              strokeOpacity: 0.9,
              strokeStyle: "solid",
              fillOpacity: 0.18,
              draggable: false,
            });

            route.polygons.push(poly);
            attachPolygonHandlers(key, route.polygons.length - 1, poly);
            drawn++;
          }
        }

        // 자동 편집 대상: code 입력했으면 그 코드(정확 일치) 우선
        if (code) {
          const exactKey = makeKey(camp, code);
          if (state.routes.has(exactKey)) {
            state.edit = { key: exactKey, regionIndex: 0 };
            setOverlayText(`편집 대상: ${code}`);
          } else {
            state.edit = { key: null, regionIndex: null };
            setOverlayText(`표시 ${drawn}개 (편집 대상: 없음)`);
          }
        } else {
          state.edit = { key: null, regionIndex: null };
          setOverlayText(`camp 전체 표시: ${drawn}개`);
        }

        refreshColorsAndStyles();
        refreshLabels();
        fitBoundsAll();

        log(`[LOG] 불러오기 완료. 표시 ${drawn}개 (편집 대상: ${state.edit.key ? state.edit.key.split("::")[1] : "없음"})`, "info");
      } catch (e) {
        console.error(e);
        alert("라우트 조회 중 오류가 발생했습니다.");
      }
    }

    function fitBoundsAll() {
      if (!state.map) return;
      const b = new kakao.maps.LatLngBounds();
      let has = false;

      for (const r of state.routes.values()) {
        for (const p of r.polygons) {
          const pts = extractPathFromPolygon(p);
          pts.forEach(pt => {
            b.extend(new kakao.maps.LatLng(pt.lat, pt.lng));
            has = true;
          });
        }
      }
      if (has) state.map.setBounds(b);
    }

    // ================== 저장 ==================
    async function saveCurrent() {
      const camp = campInput.value.trim();
      const inputCode = routeInput.value.trim();

      if (!camp) { alert("camp를 입력해주세요."); return; }

      // 편집 대상 우선, 없으면 입력 code
      const key = state.edit.key || (inputCode ? makeKey(camp, inputCode) : null);
      if (!key || !state.routes.has(key)) {
        alert("저장할 대상이 없습니다. (지도에서 폴리곤을 선택하거나 code를 입력 후 그리기/불러오기)");
        return;
      }

      const route = state.routes.get(key);
      const code = key.split("::")[1];

      // region별 path 추출
      const regions = [];
      for (const poly of route.polygons) {
        const pts = extractPathFromPolygon(poly);
        if (pts.length >= 3) regions.push(pts);
      }

      // center는 가장 큰 region의 polylabel로
      let center = null;
      if (route.polygons[0]) {
        const pos = computeLabelPosition(route.polygons[0]);
        center = { lat: pos.getLat(), lng: pos.getLng() };
      } else {
        center = null;
      }

      const payloadPoly = (regions.length === 0)
        ? null
        : (regions.length === 1 ? regions[0] : regions);

      try {
        await postRoute({
          action: "upsert",
          camp,
          code,
          polygon_wgs84: payloadPoly,
          center_wgs84: center,
        });

        alert("저장 완료되었습니다.");
        log(`[LOG] 저장 완료: ${code}, regions=${regions.length}`, "info");
      } catch (e) {
        console.error(e);
        alert("저장 중 오류가 발생했습니다.");
      }
    }

    // ================== 지도 정렬(복원/확장용) ==================
    // 주의: “주소/건물 객체 기반 완전 정렬”은 데이터(건물 footprint/도로 중심선)와 연산이 더 필요합니다.
    // 여기서는 “정렬 버튼이 동작”하도록 확장 가능한 형태로 복원합니다.
    async function alignRouteGeometryForKey(key) {
      const route = state.routes.get(key);
      if (!route || route.polygons.length === 0) return;

      // turf/osmtogeojson이 없으면 최소 동작만
      if (!window.turf || !window.osmtogeojson) {
        log("[WARN] turf/osmtogeojson 미로드: 정렬은 스킵됩니다.", "warn");
        return;
      }

      // bbox 계산
      let minLat=Infinity, minLng=Infinity, maxLat=-Infinity, maxLng=-Infinity;
      for (const poly of route.polygons) {
        const pts = extractPathFromPolygon(poly);
        for (const p of pts) {
          minLat = Math.min(minLat, p.lat); minLng = Math.min(minLng, p.lng);
          maxLat = Math.max(maxLat, p.lat); maxLng = Math.max(maxLng, p.lng);
        }
      }
      if (!isFinite(minLat)) return;

      // bbox padding
      const pad = 0.001; // 약 100m~
      const south = minLat - pad, west
