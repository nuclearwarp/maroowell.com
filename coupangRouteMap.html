<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="referrer" content="origin" />

  <!-- 썸네일 이미지 (필수) -->
  <meta property="og:image" content="https://maroowell.com/assets/og/maroowell-1200x630.png?v=1" />
  <meta property="og:image:secure_url" content="https://maroowell.com/assets/og/maroowell-1200x630.png?v=1" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:image:alt" content="Maroowell" />

  <title>Maroowell 우편번호 검색기</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico?v=2" />

  <style>
    :root {
      --headerH: 52px;
      --bg:#0f1115;
      --card:#161a22;
      --muted:#8b95a7;
      --text:#e6e9ef;
      --line:#232838;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:14px/1.4 system-ui,AppleSDGothicNeo,"Segoe UI",Roboto
    }
    header{
      display:flex;
      gap:8px;
      align-items:center;
      padding:12px 16px;
      height:var(--headerH);
      background:#161a22;
      border-bottom:1px solid #232838;
      position:sticky;
      top:0;
      z-index:5
    }
    header h1{font-size:18px;font-weight:800;letter-spacing:0.2px;margin:0}

    .muted{color:#8b95a7;font-size:12px}

    /* ✅ “숨겨진 저장 링크” (겉보기는 동일) */
    .secret-link{
      color:var(--muted);
      text-decoration:none;
      cursor:pointer;
      padding:2px 2px;
      border-radius:6px;
    }
    .secret-link:hover{
      text-decoration:underline;
      color:#b7c0d1;
    }

    #app{
      display:grid;
      grid-template-columns:360px 1fr;
      min-height:calc(100dvh - var(--headerH));
    }
    #panel{
      padding:14px;
      border-right:1px solid #232838;
      background:#10141b
    }
    #mapWrap{
      position:relative;
      min-height:calc(100dvh - var(--headerH));
      display:flex;
    }
    #map,#roadview{
      flex:1;
      width:100%;
      height:100%;
      min-width:0;
      min-height:0;
    }
    #roadview{display:none}
    #mapWrap.roadview-open #roadview{display:block}

    .map-controls{
      position:absolute;
      top:10px;
      right:10px;
      z-index:10;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .map-controls button{
      background:rgba(15,17,21,0.82);
      border-color:#2a3142;
      backdrop-filter: blur(6px);
    }
    .map-controls .hint{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid #2a3142;
      background:rgba(15,17,21,.72);
      color:#cbd5e1;
      font-size:12px;
    }

    label{display:block;margin:10px 0 6px;color:#9aa6b2}
    input,textarea,button{font:inherit}
    textarea{
      width:100%;
      background:#0c0f14;
      border:1px solid #2a3142;
      color:var(--text);
      padding:10px;
      border-radius:10px;
      min-height:90px
    }
    button{
      background:#1b2230;
      border:1px solid #2a3142;
      color:var(--text);
      padding:6px 10px;
      border-radius:10px;
      cursor:pointer
    }
    button:hover{border-color:#3a4561}
    button.danger{
      background:#2a1416;
      border-color:#7f1d1d;
      color:#fecaca
    }
    button.danger:hover{border-color:#ef4444}
    button.warn{
      background:#2a2514;
      border-color:#7a5a1a;
      color:#fde68a
    }
    button.warn:hover{border-color:#f59e0b}

    .zip-label{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:4px 10px;
      border-radius:999px;
      font-weight:800;
      font-size:12px;
      letter-spacing:0.2px;
      color:#0b1220;
      background:rgba(255,255,255,0.92);
      border:2px solid rgba(15,23,42,0.28);
      box-shadow:0 2px 10px rgba(0,0,0,0.22);
      user-select:none;
      pointer-events:none;
      transform:translateY(-2px);
      white-space:nowrap;
    }

    .row{display:flex;gap:8px;flex-wrap:wrap}
    .list{margin-top:10px;display:flex;flex-wrap:wrap;gap:6px}
    .chip{
      border:1px solid #2a3142;
      border-radius:999px;
      padding:6px 10px;
      background:#0c0f14;
      display:inline-flex;
      align-items:center;
      gap:6px
    }
    .chip button{
      border:none;
      background:transparent;
      color:#94a3b8;
      cursor:pointer
    }

    /* ✅ 저장 모달 */
    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.45);
      z-index:9999;
      backdrop-filter: blur(2px);
    }
    .modal-card{
      width:min(520px, calc(100% - 28px));
      background:linear-gradient(180deg, rgba(22,26,34,.96), rgba(12,15,20,.96));
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      box-shadow:0 24px 90px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modal-head{
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .modal-title{
      font-weight:900;
      letter-spacing:.2px;
    }
    .modal-close{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:6px 10px;
      cursor:pointer;
      color:#fff;
      font-weight:900;
      line-height:1;
    }
    .modal-body{
      padding:14px;
    }
    .modal-body .help{
      color:rgba(230,233,239,.70);
      font-size:12px;
      line-height:1.5;
      margin:6px 0 10px;
    }
    .modal-body input{
      width:100%;
      height:40px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.20);
      color:#fff;
      padding:0 12px;
      outline:none;
    }
    .modal-body input:focus{border-color:rgba(255,255,255,.25)}
    .modal-foot{
      padding:12px 14px 14px;
      border-top:1px solid rgba(255,255,255,.10);
      display:flex;
      gap:10px;
      justify-content:flex-end;
    }
    .modal-foot .btn{
      height:40px;
      padding:0 14px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.25);
      color:#fff;
      cursor:pointer;
      font-weight:900;
    }
    .modal-foot .btn:hover{background:rgba(0,0,0,.35)}
    .modal-foot .btn.ok{
      background:rgba(16,185,129,.18);
      border-color:rgba(16,185,129,.35);
    }
    .modal-foot .btn.ok:hover{
      background:rgba(16,185,129,.28);
      border-color:rgba(16,185,129,.55);
    }

    @media (max-width: 900px){
      #app{grid-template-columns:1fr;}
      #panel{order:2;}
      #mapWrap{min-height:60vh;}
      #mapWrap.roadview-open{flex-direction:column;}
    }
  </style>

  <!-- Daum 우편번호 -->
  <script src="https://t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js"></script>
  <!-- proj4 (5179 -> 4326 변환용) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>
  <!-- ✅ Turf.js (폴리곤 병합용) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
  <!-- Kakao 지도 SDK -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3"></script>
</head>

<body>
  <header>
    <a href="/coupangRouteMap.html" style="display:flex;align-items:center">
      <img src="/favicon.ico" alt="Maroowell Logo" style="width:24px;height:24px;transform:translateY(-2px);cursor:pointer" />
    </a>
    <h1>Maroowell 우편번호 검색기</h1>
    <span class="muted">
      다중 우편번호 권역 검색기 ·
      <!-- ✅ 여기 클릭하면 저장 팝업 -->
      <a id="secretSaveLink" class="secret-link" href="https://map.kakao.com" target="_blank" rel="noopener">Kakao Map</a>
    </span>
  </header>

  <div id="app">
    <aside id="panel">
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="muted">우편번호 여러 개 동시 조회</div>
          <div class="muted">쉼표/공백/줄바꿈 모두 가능</div>
        </div>
        <button id="openAddr">주소검색 추가</button>
      </div>

      <label style="margin-top:12px">우편번호 목록</label>
      <textarea id="zipInput"
        placeholder="예: 07420, 07421 07422&#10;또는 붙여넣기"></textarea>

      <div class="row" style="margin-top:8px">
        <button id="addBtn">추가</button>
        <button id="searchBtn">지도표시</button>
        <button id="mergeBtn" class="warn">폴리곤 병합</button>
        <button id="clearBtn" class="danger">초기화</button>
      </div>

      <div class="list" id="zipList"></div>

      <p class="muted" style="margin-top:10px">
        • 잘못된 우편번호나 데이터가 없는 경우 미탑재로 안내됩니다.
      </p>
    </aside>

    <div id="mapWrap">
      <div id="map"></div>
      <div id="roadview"></div>
      <div class="map-controls">
        <button id="toggleMapType" title="일반/위성 전환">위성</button>
        <button id="toggleRoadview" title="로드뷰 보기/종료">로드뷰</button>
        <span id="roadviewHint" class="hint" style="display:none">로드뷰: 파란 길(ROADVIEW) 클릭</span>
      </div>
    </div>
  </div>

  <!-- ✅ 저장 팝업 -->
  <div id="saveModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-label="폴리곤 저장">
      <div class="modal-head">
        <div class="modal-title">병합 폴리곤 저장</div>
        <button id="saveModalClose" class="modal-close" title="닫기">닫기</button>
      </div>
      <div class="modal-body">
        <div class="help">
          - 현재 화면의 <b>병합된 폴리곤(없으면 자동 병합)</b>을 <b>subsubroutes.polygon_wgs84</b>로 저장합니다.<br/>
          - 저장 포맷: <code>[[[lng,lat]...], ...]</code> (멀티 덩어리 지원)
        </div>

        <label>캠프</label>
        <input id="saveCamp" type="text" placeholder="예: 평양1" />

        <label style="margin-top:10px;">라우트 코드</label>
        <input id="saveCode" type="text" placeholder="예: 126C, 17153A (full_code로 저장)" />

        <div class="help" id="saveMeta" style="margin-top:10px;"></div>
      </div>
      <div class="modal-foot">
        <button id="saveCancel" class="btn">취소</button>
        <button id="saveDo" class="btn ok">저장</button>
      </div>
    </div>
  </div>

  <script>
    // ------- 전역 상태 ------- //
    const state = {
      map: null,
      polygons: new Map(),    // zipcode -> [Polygon, ...]
      labels: new Map(),      // zipcode -> [CustomOverlay, ...]
      selectedZips: new Set(),
      isSatellite: false,
      roadviewOn: false,
      roadviewOpen: false,
      roadview: null,
      roadviewClient: null,
      roadviewClickHandler: null,
      colors: [
        "#ff4b4b","#22c55e","#fbbf24","#3b82f6",
        "#22d3ee","#c084fc","#f472b6","#60a5fa",
        "#34d399","#f97316"
      ],

      // ✅ 병합 결과
      merged: {
        ringsWgs84: null,          // [ [ [lng,lat], ... ], ... ]
        polygonsOnMap: [],         // kakao.maps.Polygon[]
      }
    };

    // 우편번호 폴리곤 API
    const ZIP_API = "https://zip.maroowell.com/?zipcode=";

    // ✅ 저장 API (Cloudflare Worker /route)
    const ROUTE_ENDPOINT = "https://route.maroowell.com/route";

    const $ = (sel) => document.querySelector(sel);

    const parseZips = (raw) =>
      [...new Set((raw || "").match(/\d{5}/g) || [])];

    const pickColor = (zip) => {
      let h = 0;
      for (let i = 0; i < zip.length; i++) {
        h = (h * 31 + zip.charCodeAt(i)) >>> 0;
      }
      return state.colors[h % state.colors.length];
    };

    // ------- proj4 세팅 (5179 -> 4326) ------- //
    proj4.defs(
      "EPSG:5179",
      "+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 " +
        "+x_0=1000000 +y_0=2000000 +ellps=GRS80 " +
        "+towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
    );
    proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

    function convertPoint(x, y) {
      let lon, lat;
      try {
        const out = proj4("EPSG:5179", "EPSG:4326", [x, y]);
        lon = out[0];
        lat = out[1];
      } catch (e) {
        console.warn("proj4 변환 실패, 원본 좌표 사용 시도", x, y, e);
      }

      if (
        !isFinite(lat) ||
        !isFinite(lon) ||
        lat < 30 || lat > 45 ||
        lon < 120 || lon > 135
      ) {
        lon = x;
        lat = y;
      }
      return { lat, lon };
    }

    // ------- 지도 초기화 ------- //
    function createMap() {
      if (!(window.kakao && kakao.maps)) {
        alert("카카오 지도 SDK 로딩 실패");
        return;
      }
      state.map = new kakao.maps.Map($("#map"), {
        center: new kakao.maps.LatLng(37.5665, 126.978),
        level: 8
      });

      window.addEventListener("resize", () => {
        const c = state.map.getCenter();
        state.map.relayout();
        state.map.setCenter(c);
        if (state.roadviewOn && state.roadview && typeof state.roadview.relayout === "function") {
          state.roadview.relayout();
        }
      });
    }

    // ------- 지도 타입(일반/위성) ------- //
    function setMapTypeSatellite(on) {
      state.isSatellite = !!on;
      if (!state.map) return;
      state.map.setMapTypeId(
        state.isSatellite ? kakao.maps.MapTypeId.HYBRID : kakao.maps.MapTypeId.ROADMAP
      );
      const btn = $("#toggleMapType");
      if (btn) btn.textContent = state.isSatellite ? "일반" : "위성";
    }

    // ------- 로드뷰 ------- //
    function ensureRoadview() {
      if (state.roadview && state.roadviewClient) return;
      const container = $("#roadview");
      if (!container) return;
      state.roadview = new kakao.maps.Roadview(container);
      state.roadviewClient = new kakao.maps.RoadviewClient();
    }

    function setRoadviewOverlay(on) {
      if (!state.map) return;
      try {
        if (on) state.map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
        else state.map.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
      } catch (e) {
        console.warn("ROADVIEW 오버레이 토글 실패", e);
      }
    }

    function setRoadviewAt(latlng) {
      ensureRoadview();
      if (!state.roadviewClient || !state.roadview) return;

      const radii = [80, 200, 500, 1200];
      const tryFind = (i) => {
        const r = radii[i];
        state.roadviewClient.getNearestPanoId(latlng, r, (panoId) => {
          if (panoId === null || panoId === undefined) {
            if (i < radii.length - 1) return tryFind(i + 1);
            alert("이 위치 근처에는 로드뷰가 없습니다.");
            return;
          }
          state.roadviewOpen = true;
          const wrap = $("#mapWrap");
          if (wrap) wrap.classList.add("roadview-open");
          if (state.roadview && typeof state.roadview.relayout === "function") {
            setTimeout(() => state.roadview.relayout(), 0);
          }
          state.roadview.setPanoId(panoId, latlng);
        });
      };
      tryFind(0);
    }

    function setRoadviewOn(on) {
      state.roadviewOn = !!on;
      if (!state.roadviewOn) state.roadviewOpen = false;

      const wrap = $("#mapWrap");
      const hint = $("#roadviewHint");
      const btn = $("#toggleRoadview");

      if (wrap) {
        if (!state.roadviewOn) wrap.classList.remove("roadview-open");
      }
      if (hint) hint.style.display = state.roadviewOn ? "inline-flex" : "none";
      if (btn) btn.textContent = state.roadviewOn ? "로드뷰 종료" : "로드뷰";

      if (state.map) {
        const c = state.map.getCenter();
        state.map.relayout();
        state.map.setCenter(c);
      }

      if (state.roadviewOn) {
        setRoadviewOverlay(true);

        if (!state.roadviewClickHandler && state.map) {
          state.roadviewClickHandler = (mouseEvent) => {
            if (!state.roadviewOn) return;
            if (mouseEvent && mouseEvent.latLng) setRoadviewAt(mouseEvent.latLng);
          };
          kakao.maps.event.addListener(state.map, "click", state.roadviewClickHandler);
        }
      } else {
        setRoadviewOverlay(false);
        if (state.roadviewClickHandler && state.map) {
          kakao.maps.event.removeListener(state.map, "click", state.roadviewClickHandler);
        }
        state.roadviewClickHandler = null;
      }

      if (state.roadviewOn && state.roadviewOpen) {
        ensureRoadview();
        if (state.roadview && typeof state.roadview.relayout === "function") state.roadview.relayout();
      }
    }

    // ------- UI 이벤트 ------- //
    function bindUI() {
      $("#addBtn").onclick = () => {
        parseZips($("#zipInput").value).forEach((z) => state.selectedZips.add(z));
        $("#zipInput").value = "";
        renderZipChips();
      };

      $("#clearBtn").onclick = () => {
        state.selectedZips.clear();
        clearPolygons();
        clearMergedView();
        setRoadviewOn(false);
        renderZipChips();
      };

      $("#searchBtn").onclick = async () => {
        await drawSelected();
        fitBoundsAll();
      };

      const mergeBtn = $("#mergeBtn");
      if (mergeBtn) {
        mergeBtn.onclick = async () => {
          try {
            await mergeAndShow();
          } catch (e) {
            console.error(e);
            alert("폴리곤 병합 실패: " + (e?.message || String(e)));
          }
        };
      }

      const mapTypeBtn = $("#toggleMapType");
      if (mapTypeBtn) mapTypeBtn.onclick = () => setMapTypeSatellite(!state.isSatellite);

      const roadviewBtn = $("#toggleRoadview");
      if (roadviewBtn) roadviewBtn.onclick = () => setRoadviewOn(!state.roadviewOn);

      $("#openAddr").onclick = () => {
        new daum.Postcode({
          oncomplete: (d) => {
            if (d.zonecode) {
              state.selectedZips.add(d.zonecode);
              renderZipChips();
            }
          }
        }).open();
      };

      // ✅ 헤더의 Kakao Map 링크 = “숨겨진 저장”
      const secret = $("#secretSaveLink");
      if (secret) {
        secret.addEventListener("click", (e) => {
          // Ctrl/Meta/Shift 클릭은 원래 링크(카카오맵) 열기 허용
          if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return;
          e.preventDefault();
          openSaveModal();
        });
      }

      // ✅ 저장 모달
      $("#saveModalClose").onclick = closeSaveModal;
      $("#saveCancel").onclick = closeSaveModal;
      $("#saveModal").addEventListener("click", (e) => {
        if (e.target === $("#saveModal")) closeSaveModal();
      });

      $("#saveDo").onclick = async () => {
        const camp = ($("#saveCamp").value || "").trim();
        const code = ($("#saveCode").value || "").trim();
        if (!camp) return alert("캠프를 입력하세요.");
        if (!code) return alert("라우트 코드를 입력하세요.");

        try {
          const rings = await ensureMergedRingsForSave();
          if (!rings || !rings.length) return alert("저장할 폴리곤이 없습니다. 먼저 지도표시/병합을 확인하세요.");

          const payload = {
            camp,
            code,
            polygon_wgs84: rings
          };

          const res = await fetch(ROUTE_ENDPOINT, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          const text = await res.text();
          let j = null;
          try { j = text ? JSON.parse(text) : null; } catch {}

          if (!res.ok) {
            const msg = j?.error || j?.message || text || `HTTP ${res.status}`;
            throw new Error(msg);
          }

          closeSaveModal();
          alert("저장 완료");
        } catch (e) {
          console.error(e);
          alert("저장 실패: " + (e?.message || String(e)));
        }
      };

      const preset = parseZips(new URLSearchParams(location.search).get("zips"));
      preset.forEach((z) => state.selectedZips.add(z));
      renderZipChips();
      if (preset.length) {
        drawSelected().then(fitBoundsAll);
      }
    }

    function renderZipChips() {
      const list = $("#zipList");
      list.innerHTML = "";
      [...state.selectedZips].sort().forEach((z) => {
        const div = document.createElement("div");
        div.className = "chip";
        const color = pickColor(z);
        div.innerHTML =
          `<b>${z}</b>` +
          `<span style="display:inline-block;width:10px;height:10px;border-radius:2px;background:${color}"></span>` +
          `<button title="삭제">✕</button>`;
        div.querySelector("button").onclick = () => {
          state.selectedZips.delete(z);
          removePolygon(z);
          renderZipChips();
        };
        list.appendChild(div);
      });
    }

    // ------- 폴리곤 관리 ------- //
    function clearPolygons() {
      for (const arr of state.polygons.values()) arr.forEach((p) => p.setMap(null));
      state.polygons.clear();

      for (const arr of state.labels.values()) arr.forEach((l) => l.setMap(null));
      state.labels.clear();
    }

    function removePolygon(zip) {
      if (!state.polygons.has(zip)) return;
      state.polygons.get(zip).forEach((p) => p.setMap(null));
      state.polygons.delete(zip);

      if (state.labels.has(zip)) {
        state.labels.get(zip).forEach((l) => l.setMap(null));
        state.labels.delete(zip);
      }
    }

    // ------- 라벨 위치 계산 ------- //
    function centroidOfLatLngRing(latlngs) {
      if (!latlngs || latlngs.length < 3) return null;

      const pts = latlngs.map((ll) => [ll.getLng(), ll.getLat()]);
      const f = pts[0];
      const l = pts[pts.length - 1];
      if (f[0] !== l[0] || f[1] !== l[1]) pts.push(f);

      let area2 = 0, cx6 = 0, cy6 = 0;
      for (let i = 0; i < pts.length - 1; i++) {
        const x0 = pts[i][0], y0 = pts[i][1];
        const x1 = pts[i + 1][0], y1 = pts[i + 1][1];
        const f2 = x0 * y1 - x1 * y0;
        area2 += f2;
        cx6 += (x0 + x1) * f2;
        cy6 += (y0 + y1) * f2;
      }

      if (!isFinite(area2) || Math.abs(area2) < 1e-14) return null;
      const cx = cx6 / (3 * area2);
      const cy = cy6 / (3 * area2);
      if (!isFinite(cx) || !isFinite(cy)) return null;
      return new kakao.maps.LatLng(cy, cx);
    }

    function boundsCenterOfLatLngs(latlngs) {
      if (!latlngs || !latlngs.length) return null;
      const b = new kakao.maps.LatLngBounds();
      latlngs.forEach((ll) => b.extend(ll));
      return b.getCenter();
    }

    function createZipLabelOverlay(zip, color, pos) {
      const el = document.createElement("div");
      el.className = "zip-label";
      el.textContent = zip;
      el.style.borderColor = color;

      return new kakao.maps.CustomOverlay({
        position: pos,
        content: el,
        yAnchor: 0.5,
        zIndex: 9999
      });
    }

    function addZipLabelsForPolygons(zip, polys, color) {
      const overlays = [];
      for (const poly of polys) {
        const latlngs = collectLatLngsFromPath(poly.getPath());
        if (latlngs.length < 3) continue;

        const center = centroidOfLatLngRing(latlngs) || boundsCenterOfLatLngs(latlngs);
        if (!center) continue;

        const ov = createZipLabelOverlay(zip, color, center);
        ov.setMap(state.map);
        overlays.push(ov);
      }
      if (overlays.length) state.labels.set(zip, overlays);
    }

    // zip API -> Polygon 생성
    function polygonsFrom5179(polygon5179, color, zip) {
      if (!Array.isArray(polygon5179) || !polygon5179.length) return [];

      const polys = [];

      polygon5179.forEach((polygon) => {
        if (!Array.isArray(polygon)) return;

        polygon.forEach((ring) => {
          if (!Array.isArray(ring)) return;

          const path = [];
          ring.forEach((pt) => {
            if (!Array.isArray(pt) || pt.length < 2) return;
            const x = Number(pt[0]);
            const y = Number(pt[1]);
            if (!isFinite(x) || !isFinite(y)) return;

            const { lat, lon } = convertPoint(x, y);
            if (!isFinite(lat) || !isFinite(lon)) return;

            path.push(new kakao.maps.LatLng(lat, lon));
          });

          if (path.length < 3) return;

          const poly = new kakao.maps.Polygon({
            map: state.map,
            path,
            strokeWeight: 3,
            strokeColor: color,
            strokeOpacity: 1,
            strokeStyle: "solid",
            fillColor: color,
            fillOpacity: 0.25
          });
          polys.push(poly);
        });
      });

      return polys;
    }

    async function drawSelected() {
      const targets = [...state.selectedZips].filter((z) => !state.polygons.has(z));
      if (!targets.length) return;

      const notFound = [];

      for (const zip of targets) {
        try {
          const url = `${ZIP_API}${encodeURIComponent(zip)}`;
          const res = await fetch(url, { cache: "no-store" });
          const data = await res.json();

          if (!Array.isArray(data.polygon5179) || !data.polygon5179.length) {
            notFound.push(zip);
            continue;
          }

          const color = pickColor(zip);
          const polys = polygonsFrom5179(data.polygon5179, color, zip);
          if (!polys.length) {
            notFound.push(zip);
            continue;
          }

          state.polygons.set(zip, polys);
          addZipLabelsForPolygons(zip, polys, color);
        } catch (e) {
          console.error("[ZIP] 로드 실패", zip, e);
          notFound.push(zip);
        }
      }

      if (notFound.length) {
        alert(`폴리곤을 그리지 못한 우편번호: ${notFound.join(", ")}`);
      }
    }

    // ------- path 에서 LatLng 전부 뽑기 ------- //
    function collectLatLngsFromPath(path) {
      const out = [];

      const walk = (p) => {
        if (!p) return;

        if (p instanceof kakao.maps.LatLng || (typeof p.getLat === "function" && typeof p.getLng === "function")) {
          out.push(p);
          return;
        }

        if (typeof p.getLength === "function" && typeof p.getAt === "function") {
          for (let i = 0; i < p.getLength(); i++) walk(p.getAt(i));
          return;
        }

        if (Array.isArray(p) || typeof p.forEach === "function") {
          p.forEach(walk);
          return;
        }
      };

      walk(path);
      return out;
    }

    function fitBoundsAll() {
      if (!state.map) return;

      const b = new kakao.maps.LatLngBounds();
      let has = false;

      for (const arr of state.polygons.values()) {
        for (const poly of arr) {
          const latlngs = collectLatLngsFromPath(poly.getPath());
          latlngs.forEach((ll) => {
            b.extend(ll);
            has = true;
          });
        }
      }

      // 병합 표시도 bounds에 반영
      if (state.merged.polygonsOnMap?.length) {
        for (const poly of state.merged.polygonsOnMap) {
          const latlngs = collectLatLngsFromPath(poly.getPath());
          latlngs.forEach((ll) => {
            b.extend(ll);
            has = true;
          });
        }
      }

      if (has) state.map.setBounds(b);
    }

    // =========================
    // ✅ 폴리곤 병합 (Turf)
    // =========================
    function kakaoPolygonToRingLngLat(poly) {
      const raw = poly.getPath();
      const pts = [];
      if (!raw) return pts;

      if (typeof raw.getLength === "function" && typeof raw.getAt === "function") {
        for (let i=0;i<raw.getLength();i++) pts.push(raw.getAt(i));
      } else if (Array.isArray(raw)) {
        pts.push(...raw);
      }
      // [lng,lat]
      const ring = pts.map(ll => [ll.getLng(), ll.getLat()]);
      return ring;
    }

    function closeRingIfNeeded(ring) {
      if (!ring || ring.length < 3) return ring;
      const f = ring[0];
      const l = ring[ring.length - 1];
      if (f && l && f[0] === l[0] && f[1] === l[1]) return ring;
      return ring.concat([f]);
    }

    function uncloseRingIfClosed(ring) {
      if (!ring || ring.length < 4) return ring;
      const f = ring[0];
      const l = ring[ring.length - 1];
      if (f && l && f[0] === l[0] && f[1] === l[1]) return ring.slice(0, -1);
      return ring;
    }

    function clearMergedView() {
      if (state.merged.polygonsOnMap?.length) {
        state.merged.polygonsOnMap.forEach(p => p.setMap(null));
      }
      state.merged.polygonsOnMap = [];
      state.merged.ringsWgs84 = null;
    }

    function turfGeomToOuterRings(geom) {
      // 반환: [ ring, ring, ... ]  (각 ring은 [ [lng,lat], ... ] 닫힌 상태일 수 있음)
      if (!geom) return [];
      const t = geom.type;
      const coords = geom.coordinates;
      const out = [];

      if (t === "Polygon") {
        // coords: [ outer, holes... ]
        if (Array.isArray(coords) && coords[0] && coords[0].length >= 3) out.push(coords[0]);
      } else if (t === "MultiPolygon") {
        // coords: [ [ outer, holes... ], [ outer, holes... ], ... ]
        if (Array.isArray(coords)) {
          coords.forEach(poly => {
            if (Array.isArray(poly) && poly[0] && poly[0].length >= 3) out.push(poly[0]);
          });
        }
      }
      return out;
    }

    function ringsToKakaoPolygons(rings, opts = {}) {
      const {
        strokeColor = "#ffffff",
        fillColor = "#ffffff",
        strokeWeight = 5,
        fillOpacity = 0.08,
        strokeOpacity = 0.9
      } = opts;

      const polys = [];
      for (const ring of rings) {
        if (!Array.isArray(ring) || ring.length < 3) continue;
        const openRing = uncloseRingIfClosed(ring);
        if (!openRing || openRing.length < 3) continue;

        const path = openRing.map(([lng, lat]) => new kakao.maps.LatLng(lat, lng));
        const poly = new kakao.maps.Polygon({
          map: state.map,
          path,
          strokeWeight,
          strokeColor,
          strokeOpacity,
          strokeStyle: "solid",
          fillColor,
          fillOpacity,
          zIndex: 9998
        });
        polys.push(poly);
      }
      return polys;
    }

    async function mergeAndShow() {
      if (!window.turf) throw new Error("Turf.js 로딩 실패");

      // 현재 표시된 모든 우편번호 폴리곤을 Feature로 수집
      const features = [];
      for (const arr of state.polygons.values()) {
        for (const poly of arr) {
          const ring = kakaoPolygonToRingLngLat(poly);
          if (!ring || ring.length < 3) continue;

          const closed = closeRingIfNeeded(ring);
          try {
            const feat = turf.polygon([closed]);
            features.push(feat);
          } catch (e) {
            console.warn("turf polygon 생성 실패", e);
          }
        }
      }
      if (!features.length) {
        alert("병합할 폴리곤이 없습니다. 먼저 지도표시를 눌러주세요.");
        return;
      }

      // union reduce
      let merged = features[0];
      for (let i=1; i<features.length; i++) {
        const next = features[i];
        try {
          const u = turf.union(merged, next);
          if (u) merged = u;
        } catch (e) {
          console.warn("union 실패(스킵)", e);
        }
      }

      const ringsClosed = turfGeomToOuterRings(merged?.geometry);
      if (!ringsClosed.length) {
        alert("병합 결과가 비었습니다.");
        return;
      }

      // 저장용: 닫힌 좌표 제거 (DB에는 open ring으로 저장)
      const ringsForSave = ringsClosed.map(r => uncloseRingIfClosed(r)).filter(r => r && r.length >= 3);

      clearMergedView();
      state.merged.ringsWgs84 = ringsForSave;
      state.merged.polygonsOnMap = ringsToKakaoPolygons(ringsClosed, {
        strokeColor: "#ffffff",
        fillColor: "#ffffff",
        strokeWeight: 6,
        fillOpacity: 0.06,
        strokeOpacity: 0.95
      });

      fitBoundsAll();
      alert(`병합 완료: 덩어리 ${ringsForSave.length}개`);
    }

    // =========================
    // ✅ 저장 팝업/저장 로직
    // =========================
    function openSaveModal() {
      // 메타 표시
      const zcnt = state.selectedZips.size;
      const pcnt = [...state.polygons.values()].reduce((a,arr)=>a+(arr?.length||0),0);
      const mergedCnt = state.merged.ringsWgs84?.length || 0;

      $("#saveMeta").innerHTML =
        `선택 우편번호: <b>${zcnt}</b>개 · 원본 폴리곤: <b>${pcnt}</b>개 · 병합 덩어리: <b>${mergedCnt}</b>개`;

      $("#saveModal").style.display = "flex";
      $("#saveModal").setAttribute("aria-hidden","false");
      setTimeout(() => $("#saveCamp").focus(), 0);
    }

    function closeSaveModal() {
      $("#saveModal").style.display = "none";
      $("#saveModal").setAttribute("aria-hidden","true");
    }

    async function ensureMergedRingsForSave() {
      // 이미 병합 결과가 있으면 그대로 사용
      if (state.merged.ringsWgs84 && state.merged.ringsWgs84.length) return state.merged.ringsWgs84;

      // 병합을 안 눌렀으면 “저장 시 자동 병합”
      await mergeAndShow();
      return state.merged.ringsWgs84;
    }

    // ------- DOM 로드 시 초기화 ------- //
    document.addEventListener("DOMContentLoaded", () => {
      createMap();
      bindUI();
    });
  </script>
</body>
</html>
