<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ë§ˆë£¨ì›° ë¼ìš°íŠ¸ í¸ì§‘ê¸°</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:#020617;
      color:#e5e7eb;
    }
    body { display:flex; }

    .side {
      width: 400px;
      min-width: 320px;
      max-width: 520px;
      background:#020617;
      border-right:1px solid #1f2937;
      padding:14px 16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .title { font-size:1rem; font-weight:700; }
    .subtitle { font-size:0.75rem; color:#9ca3af; }

    label { font-size:0.78rem; margin-bottom:2px; display:block; }
    input[type="text"] {
      width:100%; padding:7px 10px; border-radius:8px;
      border:1px solid #374151; background:#020617; color:#e5e7eb;
      font-size:0.8rem;
    }

    .btn-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:4px; }
    button {
      border-radius:999px; border:1px solid #374151;
      background:#020617; color:#e5e7eb;
      padding:6px 12px; font-size:0.78rem;
      cursor:pointer; white-space:nowrap;
    }
    button.primary { background:#111827; border-color:#111827; }
    button.danger  { border-color:#b91c1c; color:#fecaca; }
    button:hover { background:#111827; }

    .hint { font-size:0.7rem; color:#6b7280; line-height:1.4; }
    .status-bar {
      font-size:0.7rem; padding:4px 8px; border-radius:999px;
      background:#022c22; color:#6ee7b7;
      display:inline-block; margin-top:4px;
    }
    .status-error { background:#450a0a; color:#fecaca; }

    .log-box {
      margin-top:6px;
      padding:6px 8px;
      border-radius:8px;
      border:1px solid #1f2937;
      background:#020617;
      font-size:0.7rem;
      height:190px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .log-line-time { color:#6b7280; }
    .log-line-info { color:#e5e7eb; }
    .log-line-warn { color:#fbbf24; }
    .log-line-err  { color:#f87171; }

    .map-wrap { flex:1; position:relative; }
    #map { width:100%; height:100%; }

    .overlay-badge {
      position:absolute; top:10px; left:10px;
      background:rgba(15,23,42,0.9); border:1px solid #1f2937;
      border-radius:999px; padding:4px 10px;
      font-size:0.72rem; pointer-events:none;
    }

    .route-label {
      display:inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 800;
      color: #0b1220;
      background: rgba(255,255,255,0.92);
      border: 2px solid rgba(15,23,42,0.28);
      box-shadow: 0 2px 10px rgba(0,0,0,0.22);
      user-select: none;
      pointer-events: none;
      transform: translateY(-2px);
    }

    .section {
      border: 1px solid #1f2937;
      border-radius: 10px;
      padding: 10px;
      background: rgba(2,6,23,0.6);
    }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .row input { flex: 1 1 auto; min-width: 140px; }

    @media (max-width:900px) {
      body { flex-direction:column; }
      .side {
        width:100%; max-width:none;
        border-right:none; border-bottom:1px solid #1f2937;
      }
      .map-wrap { height:calc(100% - 360px); }
    }
  </style>

  <!-- turf.js -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- Kakao Maps + drawing + services -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&libraries=drawing,services&autoload=false"></script>

  <!-- Daum Postcode -->
  <script src="https://t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js"></script>

  <script>console.log("ğŸ”´ VERSION: 2025.12.17-FIX (edit-no-put + /osm + colors) ğŸ”´");</script>
</head>

<body>
  <aside class="side">
    <div>
      <div class="title">ë§ˆë£¨ì›° ë¼ìš°íŠ¸ í¸ì§‘ê¸°</div>
      <div class="subtitle">ìº í”„ + ë¼ìš°íŠ¸ ì½”ë“œ ê¸°ë°˜ Â· Supabase / Cloudflare route API ì‚¬ìš©</div>
    </div>

    <div>
      <label for="campInput">ìº í”„ ì´ë¦„ (ì˜ˆ: ëŒ€êµ¬3)</label>
      <input id="campInput" type="text" placeholder="ì˜ˆ: ëŒ€êµ¬3" />
    </div>

    <div>
      <label for="routeInput">ë¼ìš°íŠ¸ ì½”ë“œ (ì˜ˆ: 213, 213C, 213C01) â€” ë¹„ìš°ë©´ camp ì „ì²´ í‘œì‹œ</label>
      <input id="routeInput" type="text" placeholder="ì˜ˆ: 213 ë˜ëŠ” 213C" />
    </div>

    <div class="btn-row">
      <button id="loadBtn" class="primary">ë¶ˆëŸ¬ì˜¤ê¸°(GET)</button>
      <button id="drawBtn">ìƒˆë¡œ ê·¸ë¦¬ê¸°</button>
      <button id="addBtn">êµ¬ì—­ ì¶”ê°€</button>
      <button id="searchAddressBtn">ğŸ“ ì£¼ì†Œê²€ìƒ‰</button>
      <button id="saveBtn" class="primary">ì €ì¥(POST)</button>
      <button id="alignBtn">ì§€ë„ ì •ë ¬</button>
      <button id="labelBtn">ë¼ìš°íŠ¸ ë¼ë²¨ ON</button>
      <button id="resetBtn" class="danger">ì§€ë„ ì´ˆê¸°í™”</button>
    </div>

    <div class="hint">
      â€¢ <b>GET:</b> campë§Œ ì…ë ¥í•˜ë©´ camp ì „ì²´ í‘œì‹œ, code ì…ë ¥ ì‹œ prefixë¡œ í•˜ìœ„ ë…¸ì„ ê¹Œì§€ í‘œì‹œ<br/>
      â€¢ <b>í¸ì§‘:</b> í´ë¦¬ê³¤ í´ë¦­ â†’ í¸ì§‘ ëŒ€ìƒ(ë…¹ìƒ‰) ì „í™˜ â†’ ì  ë“œë˜ê·¸ ìˆ˜ì •<br/>
      â€¢ <b>ìƒˆë¡œ ê·¸ë¦¬ê¸°/êµ¬ì—­ ì¶”ê°€:</b> DrawingManagerë¡œ ê·¸ë¦° í›„ ìë™ìœ¼ë¡œ í¸ì§‘í´ë¦¬ê³¤ìœ¼ë¡œ ë³€í™˜ë©ë‹ˆë‹¤.<br/>
      â€¢ <b>ë©€í‹° êµ¬ì—­:</b> ê°™ì€ codeì— ë–¨ì–´ì§„ êµ¬ì—­ ì—¬ëŸ¬ ê°œ ì§€ì› (êµ¬ì—­ ì¶”ê°€ ë²„íŠ¼)
    </div>

    <div class="section">
      <div style="font-size:0.78rem;color:#9aa6b2;margin-bottom:6px;">DB ìˆ˜ì •</div>

      <div class="row" style="margin-bottom:6px;">
        <input id="campEditInput" type="text" placeholder="ìº í”„ ë³€ê²½: ì˜ˆ) ëŒ€êµ¬3" />
        <button id="campUpdateSelectedBtn">ì„ íƒ camp ìˆ˜ì •</button>
        <button id="campRenameAllBtn">camp ì „ì²´ ì´ê´€(ë³‘í•©)</button>
      </div>

      <div class="row">
        <input id="routeEditInput" type="text" placeholder="ì½”ë“œ ë³€ê²½: ì˜ˆ) 213D â†’ 213C" />
        <button id="routeRenameBtn">ì„ íƒ ì½”ë“œ ìˆ˜ì •</button>
        <button id="routeDeleteRowBtn" class="danger">ì„ íƒ DB ì‚­ì œ</button>
      </div>

      <div class="hint" style="margin-top:6px;">
        â€¢ ì„ íƒ ìˆ˜ì •/ì‚­ì œëŠ” â€œì§€ë„ì—ì„œ í•´ë‹¹ ë…¸ì„ ì„ í´ë¦­í•´ í¸ì§‘ëŒ€ìƒ(ë…¹ìƒ‰)â€ ìƒíƒœì—ì„œ ë™ì‘í•©ë‹ˆë‹¤.<br/>
        â€¢ camp ì „ì²´ ì´ê´€(ë³‘í•©): from=campInput â†’ to=campEditInput (ì¶©ëŒì€ ìë™ ë³‘í•©/ì •ë¦¬).<br/>
      </div>
    </div>

    <div id="apiStatus" class="status-bar">API: ready</div>
    <div id="logBox" class="log-box"></div>
  </aside>

  <div class="map-wrap">
    <div id="map"></div>
    <div class="overlay-badge" id="overlayInfo">ì§€ë„ ì´ˆê¸°í™” ì¤‘...</div>
  </div>

  <script>
    // ================== ì„¤ì • ==================
    const ROUTE_API_BASE = "https://route.maroowell.com";

    const ALIGN = {
      OSM_MARGIN_DEG: 0.0020,
      MAX_ROADS: 900,
      MAX_BUILDINGS: 1200,
      ROAD_SNAP_METERS: 18,
      DENSIFY_STEP_METERS: 18,
      SIMPLIFY_TOLERANCE_DEG: 0.00001,
      BUILDING_RATIO: 0.50
    };

    // ================== DOM ==================
    const logBox      = document.getElementById("logBox");
    const apiStatus   = document.getElementById("apiStatus");
    const overlayInfo = document.getElementById("overlayInfo");

    const campInput   = document.getElementById("campInput");
    const routeInput  = document.getElementById("routeInput");

    const loadBtn     = document.getElementById("loadBtn");
    const drawBtn     = document.getElementById("drawBtn");
    const addBtn      = document.getElementById("addBtn");
    const searchAddressBtn = document.getElementById("searchAddressBtn");
    const saveBtn     = document.getElementById("saveBtn");
    const alignBtn    = document.getElementById("alignBtn");
    const labelBtn    = document.getElementById("labelBtn");
    const resetBtn    = document.getElementById("resetBtn");

    const campEditInput = document.getElementById("campEditInput");
    const routeEditInput = document.getElementById("routeEditInput");
    const campUpdateSelectedBtn = document.getElementById("campUpdateSelectedBtn");
    const campRenameAllBtn      = document.getElementById("campRenameAllBtn");
    const routeRenameBtn        = document.getElementById("routeRenameBtn");
    const routeDeleteRowBtn     = document.getElementById("routeDeleteRowBtn");

    // ================== ë¡œê¹… ==================
    function log(message, level = "info") {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2,"0");
      const mm = String(now.getMinutes()).padStart(2,"0");
      const ss = String(now.getSeconds()).padStart(2,"0");

      const line = document.createElement("div");

      const spanTime = document.createElement("span");
      spanTime.textContent = `[${hh}:${mm}:${ss}] `;
      spanTime.className = "log-line-time";
      line.appendChild(spanTime);

      const spanMsg = document.createElement("span");
      spanMsg.textContent = message;
      spanMsg.className = "log-line-" + level;
      line.appendChild(spanMsg);

      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;
    }

    function setApiStatus(msg, isError = false) {
      apiStatus.textContent = "API: " + msg;
      apiStatus.className = "status-bar" + (isError ? " status-error" : "");
    }

    function setOverlayText(msg) {
      overlayInfo.textContent = msg;
    }

    window.addEventListener("error", (e) => {
      log(`[ERR] window.error: ${e.message} @ ${e.filename}:${e.lineno}:${e.colno}`, "err");
    });
    window.addEventListener("unhandledrejection", (e) => {
      log(`[ERR] unhandledrejection: ${String(e.reason)}`, "err");
    });

    const round6 = (x) => Math.round(x * 1e6) / 1e6;

    // ================== ì§€ë„ ìƒíƒœ ==================
    let map;
    let drawingManager;

    // ì •ì  í‘œì‹œìš©
    let staticItems = []; // [{key,row,ringsLatLng,polygons,labels,dupIds:[]}]
    let labelsOn = true;

    // í¸ì§‘ìš©(ë…¹ìƒ‰)
    let editKey = null;
    let editRow = null;        // ê¸°ì¤€ row(id ë“±)
    let editDupIds = [];       // ê°™ì€ camp+code ì¤‘ë³µ idë“¤(ì •ë¦¬ìš©)
    let editPolygons = [];     // kakao.maps.Polygon[] (editable)

    // ìƒ‰ìƒ ë§µ
    let colorMap = new Map();

    // ================== polylabel (ë¼ë²¨ ìœ„ì¹˜) ==================
    class MaxHeap { constructor(){this.data=[]} push(i){this.data.push(i);this._up(this.data.length-1)} pop(){if(!this.data.length)return null;const t=this.data[0];const e=this.data.pop();if(this.data.length){this.data[0]=e;this._down(0)}return t} get size(){return this.data.length} _up(n){const e=this.data[n];while(n>0){const p=Math.floor((n-1)/2);const pn=this.data[p];if(e.max<=pn.max)break;this.data[p]=e;this.data[n]=pn;n=p}} _down(n){const l=this.data.length;const e=this.data[n];for(;;){let ln=2*n+1;let rn=2*n+2;let s=null;if(ln<l){const le=this.data[ln];if(le.max>e.max)s=ln}if(rn<l){const re=this.data[rn];if((s===null&&re.max>e.max)||(s!==null&&re.max>this.data[s].max))s=rn}if(s===null)break;this.data[n]=this.data[s];this.data[s]=e;n=s}} }
    function getSegDistSq(px,py,a,b){let x=a[0],y=a[1];let dx=b[0]-x,dy=b[1]-y;if(dx!==0||dy!==0){const t=((px-x)*dx+(py-y)*dy)/(dx*dx+dy*dy);if(t>1){x=b[0];y=b[1]}else if(t>0){x+=dx*t;y+=dy*t}}dx=px-x;dy=py-y;return dx*dx+dy*dy}
    function pointToPolygonDist(x,y,poly){let inside=false;let min=Infinity;for(let i=0,j=poly.length-1;i<poly.length;j=i++){const a=poly[i],b=poly[j];if((a[1]>y)!==(b[1]>y)&&x<(b[0]-a[0])*(y-a[1])/(b[1]-a[1]+0.0)+a[0])inside=!inside;min=Math.min(min,getSegDistSq(x,y,a,b))}const d=Math.sqrt(min);return inside?d:-d}
    function polygonCentroid(ring){let x=0,y=0,area=0;for(let i=0,j=ring.length-1;i<ring.length;j=i++){const a=ring[i],b=ring[j];const f=a[0]*b[1]-b[0]*a[1];x+=(a[0]+b[0])*f;y+=(a[1]+b[1])*f;area+=f}area*=0.5;if(area===0)return null;x/=(6*area);y/=(6*area);return [x,y]}
    class Cell{constructor(x,y,h,poly){this.x=x;this.y=y;this.h=h;this.d=pointToPolygonDist(x,y,poly);this.max=this.d+this.h*Math.SQRT2}}
    function polylabel(ring,precision=1e-5){
      if(!Array.isArray(ring)||ring.length<3)return null;
      let pts=ring.slice();
      const f=pts[0],l=pts[pts.length-1];
      if(f[0]!==l[0]||f[1]!==l[1])pts.push(f);
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for(const p of pts){minX=Math.min(minX,p[0]);minY=Math.min(minY,p[1]);maxX=Math.max(maxX,p[0]);maxY=Math.max(maxY,p[1])}
      const w=maxX-minX,h=maxY-minY;
      if(w===0&&h===0)return [minX,minY];
      const cellSize=Math.min(w,h);
      let hh=cellSize/2;
      const heap=new MaxHeap();
      for(let x=minX;x<maxX;x+=cellSize)for(let y=minY;y<maxY;y+=cellSize)heap.push(new Cell(x+hh,y+hh,hh,pts));
      let best=null;
      const c=polygonCentroid(pts);
      if(c)best=new Cell(c[0],c[1],0,pts);
      const bboxCell=new Cell(minX+w/2,minY+h/2,0,pts);
      if(!best||bboxCell.d>best.d)best=bboxCell;
      let iter=0;
      const maxIter=30000;
      while(heap.size&&iter++<maxIter){
        const cell=heap.pop();
        if(!cell)break;
        if(cell.d>best.d)best=cell;
        if(cell.max-best.d<=precision)continue;
        hh=cell.h/2;
        heap.push(new Cell(cell.x-hh,cell.y-hh,hh,pts));
        heap.push(new Cell(cell.x+hh,cell.y-hh,hh,pts));
        heap.push(new Cell(cell.x-hh,cell.y+hh,hh,pts));
        heap.push(new Cell(cell.x+hh,cell.y+hh,hh,pts))
      }
      return [best.x,best.y]
    }

    // ================== ìƒ‰ìƒ: ì¸ì ‘ ì»¬ëŸ¬ë§ ==================
    function hsl(h,s,l){ return `hsl(${h}, ${s}%, ${l}%)`; }

    function buildPalette(){
      // ì¶©ë¶„íˆ ë„“ì€ íŒ”ë ˆíŠ¸(ì¸ì ‘ì´ ë§ì•„ë„ ìµœëŒ€í•œ ë‹¤ë¥´ê²Œ)
      const hues = [];
      const step = 360 / 24; // 24ìƒ‰ ê¸°ë³¸
      for (let i=0;i<24;i++) hues.push(Math.round(i*step));
      // ë¼ì´íŠ¸ë‹ˆìŠ¤/ìƒˆì¸„ë ˆì´ì…˜ ë³€ì£¼(ê²¹ì¹˜ë©´ 2ì°¨ë¡œ ì‚¬ìš©)
      const out = [];
      for (const l of [52, 46, 58]) {
        for (const h of hues) out.push(hsl(h, 86, l));
      }
      return out; // 72ê°œ ì •ë„
    }

    const PALETTE = buildPalette();

    function ringsToTurfMulti(ringsLatLng){
      if (!window.turf) return null;
      try{
        const polys = [];
        for (const ring of ringsLatLng){
          const coords = ring.map(ll => [ll.getLng(), ll.getLat()]);
          if (coords.length < 3) continue;
          // close
          const f = coords[0], l = coords[coords.length-1];
          if (f[0] !== l[0] || f[1] !== l[1]) coords.push(f);
          polys.push(turf.polygon([coords]));
        }
        if (!polys.length) return null;
        if (polys.length === 1) return polys[0];
        return turf.featureCollection(polys);
      }catch{ return null; }
    }

    function computeAdjacency(items){
      // items: [{key,ringsLatLng}]
      // ì¸ì ‘ ê¸°ì¤€: bbox ê²¹ì¹˜ê³ , (buffer í›„) intersects
      const adj = new Map();
      for (const it of items) adj.set(it.key, new Set());

      const feats = items.map(it => ({
        key: it.key,
        feat: ringsToTurfMulti(it.ringsLatLng),
        bbox: null
      }));
      for (const f of feats){
        if (!f.feat) continue;
        try{ f.bbox = turf.bbox(f.feat); }catch{ f.bbox = null; }
      }

      function bboxOverlap(a,b){
        if(!a||!b) return false;
        // [minX,minY,maxX,maxY]
        return !(a[2] < b[0] || a[0] > b[2] || a[3] < b[1] || a[1] > b[3]);
      }

      for (let i=0;i<feats.length;i++){
        for (let j=i+1;j<feats.length;j++){
          const A = feats[i], B = feats[j];
          if (!A.feat || !B.feat) continue;
          if (!bboxOverlap(A.bbox, B.bbox)) continue;

          let touch = false;
          try{
            // ì•„ì£¼ ì•½ê°„ bufferë¡œ â€œê·¼ì ‘â€ë„ ì¸ì ‘ìœ¼ë¡œ ì·¨ê¸‰ (ë„ë¡œ ê²½ê³„ ë¶™ëŠ” ì¼€ì´ìŠ¤)
            const aBuf = turf.buffer(A.feat, 0.00010, {units:"degrees"});
            const bBuf = turf.buffer(B.feat, 0.00010, {units:"degrees"});
            touch = turf.booleanIntersects(aBuf, bBuf);
          }catch{
            touch = false;
          }
          if (touch){
            adj.get(A.key).add(B.key);
            adj.get(B.key).add(A.key);
          }
        }
      }
      return adj;
    }

    function assignColorsByAdjacency(items){
      // ê·¸ë¦¬ë”” ì»¬ëŸ¬ë§(í‘œì‹œ ìˆœê°„ì—ë§Œ)
      const adj = computeAdjacency(items);
      const order = [...items].sort((a,b) => (adj.get(b.key)?.size||0) - (adj.get(a.key)?.size||0));

      const cmap = new Map();
      for (const it of order){
        const used = new Set();
        for (const nb of (adj.get(it.key) || [])){
          const c = cmap.get(nb);
          if (c) used.add(c);
        }

        // ì‚¬ìš© ì•ˆëœ ìƒ‰ ì¤‘ì—ì„œ ì„ íƒ
        let pick = null;
        for (const c of PALETTE){
          if (!used.has(c)){ pick = c; break; }
        }
        // ë‹¤ ì°¼ìœ¼ë©´ ê·¸ëƒ¥ ëŒë ¤ì“°ê¸°
        if (!pick) pick = PALETTE[Math.floor(Math.random()*PALETTE.length)];

        cmap.set(it.key, pick);
      }
      return cmap;
    }

    // ================== ì§€ë„ ì´ˆê¸°í™” ==================
    function initMap() {
      map = new kakao.maps.Map(document.getElementById("map"), {
        center: new kakao.maps.LatLng(35.8714, 128.6014),
        level: 6
      });

      drawingManager = new kakao.maps.drawing.DrawingManager({
        map,
        drawingMode: [kakao.maps.drawing.OverlayType.POLYGON],
        guideTooltip: ["draw", "drag", "edit"],
        polygonOptions: {
          draggable: false,
          removable: true,
          editable: false,
          strokeWeight: 3,
          strokeColor: "#60a5fa",
          strokeOpacity: 0.95,
          strokeStyle: "solid",
          fillColor: "#60a5fa",
          fillOpacity: 0.18,
        },
      });

      kakao.maps.event.addListener(drawingManager, "drawend", () => {
        // drawingManagerì—ì„œ ê·¸ë¦° ê²ƒ â†’ ì¦‰ì‹œ í¸ì§‘í´ë¦¬ê³¤ìœ¼ë¡œ ë³€í™˜
        const rings = getRingsFromDrawingManager();
        if (!rings.length){
          log("[WARN] drawend: polygon ì¶”ì¶œ ì‹¤íŒ¨ (0ê°œ).", "warn");
          return;
        }
        addEditRings(rings);
        clearDrawingManagerPolygons();
        log(`[LOG] âœ… í´ë¦¬ê³¤ ìƒì„± ì™„ë£Œ: ${rings.length}ê°œ êµ¬ì—­`, "info");
      });

      setOverlayText("ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ.");
      log("[LOG] ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ.", "info");
    }

    function clearDrawingManagerPolygons(){
      try { drawingManager.cancel(); } catch {}
      try { drawingManager.remove(kakao.maps.drawing.OverlayType.POLYGON); } catch {}
    }

    // drawingManager.getData() í˜•ì‹ì´ ë²„ì „ë§ˆë‹¤ ë‹¬ë¼ì„œ ìµœëŒ€í•œ ì•ˆì „í•˜ê²Œ íŒŒì‹±
    function getRingsFromDrawingManager(){
      let data;
      try { data = drawingManager.getData(); }
      catch(e){
        log(`[ERR] drawingManager.getData ì‹¤íŒ¨: ${String(e?.message||e)}`, "err");
        return [];
      }
      const raw = data?.polygon;
      if (!raw) return [];

      const rings = [];

      // polyê°€ [ {x,y}, ... ] ë˜ëŠ” [ [ {x,y}... ] ] ë“±ìœ¼ë¡œ ì˜¬ ìˆ˜ ìˆìŒ
      const polys = Array.isArray(raw) ? raw : [raw];

      for (const poly of polys){
        if (!poly) continue;

        // ì¼€ì´ìŠ¤1: polyê°€ [[pt...]] í˜•íƒœ
        let outer = poly;
        if (Array.isArray(poly) && Array.isArray(poly[0]) && poly[0].length) outer = poly[0];

        // ì¼€ì´ìŠ¤2: outerê°€ ë°°ì—´ì´ì–´ì•¼ í•¨
        if (!Array.isArray(outer) || outer.length < 3) continue;

        const pts = [];
        for (const p of outer){
          // pê°€ {x,y}
          if (p && typeof p.x === "number" && typeof p.y === "number"){
            const lng = p.x, lat = p.y;
            if (lat>=30 && lat<=45 && lng>=120 && lng<=135) pts.push(new kakao.maps.LatLng(lat, lng));
            continue;
          }
          // pê°€ LatLng
          if (p && typeof p.getLat === "function" && typeof p.getLng === "function"){
            pts.push(p);
            continue;
          }
          // pê°€ [lng,lat] or [lat,lng]
          if (Array.isArray(p) && p.length>=2){
            const a0 = Number(p[0]), a1 = Number(p[1]);
            if (isFinite(a0) && isFinite(a1)){
              const isLat = (v)=> v>=30 && v<=45;
              const isLng = (v)=> v>=120 && v<=135;
              if (isLng(a0) && isLat(a1)) pts.push(new kakao.maps.LatLng(a1,a0));
              else if (isLat(a0) && isLng(a1)) pts.push(new kakao.maps.LatLng(a0,a1));
            }
          }
        }
        if (pts.length>=3) rings.push(pts);
      }
      return rings;
    }

    // ================== API ==================
    async function apiGet(path, params){
      const url = new URL(ROUTE_API_BASE + path);
      for (const [k,v] of Object.entries(params || {})) {
        if (v === undefined || v === null || String(v).trim() === "") continue;
        url.searchParams.set(k, v);
      }

      log(`[LOG] GET ${path} ìš”ì²­: ${url.toString()}`, "info");
      setApiStatus(`GET ${path} í˜¸ì¶œ ì¤‘...`);

      const res = await fetch(url.toString(), { cache:"no-store" });
      const json = await res.json().catch(() => ({}));

      if (!res.ok) {
        setApiStatus(`GET ì—ëŸ¬ ${res.status}`, true);
        log(`[ERR] GET ${path} ì‹¤íŒ¨: ${JSON.stringify(json)}`, "err");
        throw new Error(`GET ${path} ì‹¤íŒ¨`);
      }
      setApiStatus("GET ì„±ê³µ");
      return json;
    }

    async function apiPost(path, body){
      const url = ROUTE_API_BASE + path;
      log(`[LOG] POST ${path} ìš”ì²­`, "info");
      setApiStatus(`POST ${path} í˜¸ì¶œ ì¤‘...`);

      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type":"application/json; charset=utf-8" },
        body: JSON.stringify(body),
      });

      const json = await res.json().catch(() => ({}));

      if (!res.ok) {
        setApiStatus(`POST ì—ëŸ¬ ${res.status}`, true);
        log(`[ERR] POST ${path} ì‹¤íŒ¨: ${JSON.stringify(json)}`, "err");
        throw new Error(`POST ${path} ì‹¤íŒ¨`);
      }
      setApiStatus("POST ì„±ê³µ");
      return json;
    }

    async function apiDelete(path){
      const url = ROUTE_API_BASE + path;
      log(`[LOG] DELETE ${path} ìš”ì²­`, "info");
      setApiStatus(`DELETE ${path} í˜¸ì¶œ ì¤‘...`);

      const res = await fetch(url, { method:"DELETE" });
      const json = await res.json().catch(()=> ({}));

      if (!res.ok){
        setApiStatus(`DELETE ì—ëŸ¬ ${res.status}`, true);
        log(`[ERR] DELETE ${path} ì‹¤íŒ¨: ${JSON.stringify(json)}`, "err");
        throw new Error(`DELETE ${path} ì‹¤íŒ¨`);
      }
      setApiStatus("DELETE ì„±ê³µ");
      return json;
    }

    // ================== ì €ì¥ëœ polygon íŒŒì‹± ==================
    function normalizeStoredPoint(p){
      if (!p) return null;

      if (typeof p.lat === "number" && typeof p.lng === "number") {
        if (p.lat >= 30 && p.lat <= 45 && p.lng >= 120 && p.lng <= 135) return { lat: p.lat, lng: p.lng };
      }
      if (typeof p.lat === "number" && typeof p.lon === "number") {
        if (p.lat >= 30 && p.lat <= 45 && p.lon >= 120 && p.lon <= 135) return { lat: p.lat, lng: p.lon };
      }
      if (Array.isArray(p) && p.length >= 2) {
        const a0 = Number(p[0]), a1 = Number(p[1]);
        if (!isFinite(a0) || !isFinite(a1)) return null;
        const isLat = (v) => v >= 30 && v <= 45;
        const isLng = (v) => v >= 120 && v <= 135;
        if (isLng(a0) && isLat(a1)) return { lat: a1, lng: a0 };
        if (isLat(a0) && isLng(a1)) return { lat: a0, lng: a1 };
      }
      return null;
    }

    function normalizePolygonWgs84ToRingsLatLng(polygon_wgs84){
      if (!polygon_wgs84) return [];

      const isRing = Array.isArray(polygon_wgs84) && polygon_wgs84.length && normalizeStoredPoint(polygon_wgs84[0]);
      const ringsRaw = isRing ? [polygon_wgs84] : polygon_wgs84;

      const out = [];
      for (const ring of ringsRaw) {
        if (!Array.isArray(ring) || ring.length < 3) continue;
        const pts = [];
        for (const p of ring) {
          const n = normalizeStoredPoint(p);
          if (!n) continue;
          pts.push(new kakao.maps.LatLng(n.lat, n.lng));
        }
        if (pts.length >= 3) out.push(pts);
      }
      return out;
    }

    // ================== í¸ì§‘ í´ë¦¬ê³¤(ë…¹ìƒ‰) ==================
    function clearEditPolygons(){
      for (const p of editPolygons) p.setMap(null);
      editPolygons = [];
    }

    function createEditPolygonFromRing(ringLatLng){
      const poly = new kakao.maps.Polygon({
        map,
        path: ringLatLng,
        strokeWeight: 4,
        strokeColor: "#22c55e",
        strokeOpacity: 0.98,
        strokeStyle: "solid",
        fillColor: "#22c55e",
        fillOpacity: 0.20,
        draggable: true,
        editable: true
      });
      return poly;
    }

    function setEditTarget(item){
      // item: staticItems element
      if (!item) return;

      // ì´ì „ í¸ì§‘ ëŒ€ìƒ ë³µì›
      if (editKey && editKey !== item.key){
        restoreStaticForKey(editKey);
      }

      // í¸ì§‘ ìƒíƒœ ì„¸íŒ…
      editKey = item.key;
      editRow = item.row || null;
      editDupIds = item.dupIds || [];

      routeInput.value = item.key;
      routeEditInput.value = item.key;

      // ì •ì  ìˆ¨ê¸°ê³  í¸ì§‘ í´ë¦¬ê³¤ ìƒì„±
      hideStaticForKey(item.key);

      clearEditPolygons();
      for (const ring of item.ringsLatLng){
        if (ring.length>=3) editPolygons.push(createEditPolygonFromRing(ring));
      }

      if (!editPolygons.length){
        // ì‹¤íŒ¨í•˜ë©´ ë³µì›
        restoreStaticForKey(item.key);
        editKey = null; editRow = null; editDupIds = [];
        log(`[ERR] í¸ì§‘ ì „í™˜ ì‹¤íŒ¨: í¸ì§‘ í´ë¦¬ê³¤ ìƒì„± 0ê°œ`, "err");
        alert("í¸ì§‘ ì „í™˜ ì‹¤íŒ¨: ìœ íš¨í•œ í´ë¦¬ê³¤ì´ ì—†ìŠµë‹ˆë‹¤.");
        return;
      }

      log(`[LOG] âœ… í¸ì§‘ ëŒ€ìƒ: ${item.key} (ë…¹ìƒ‰ - ì  ë“œë˜ê·¸ ê°€ëŠ¥)`, "info");
      setOverlayText(`í¸ì§‘ ëŒ€ìƒ: ${item.key} (ë…¹ìƒ‰ - ì  ë“œë˜ê·¸ë¡œ ìˆ˜ì •)`);
    }

    function addEditRings(ringsLatLng){
      // ê°™ì€ codeì— êµ¬ì—­ ì¶”ê°€(ë–¨ì–´ì§„ êµ¬ì—­)
      if (!editKey){
        // ìƒˆë¡œ ê·¸ë¦° ê²½ìš°: routeInput ê¸°ì¤€ìœ¼ë¡œ í¸ì§‘ìƒíƒœ ë§Œë“ ë‹¤
        const key = routeInput.value.trim();
        if (!key){
          alert("ë¨¼ì € ë¼ìš°íŠ¸ ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: 126E)");
          return;
        }
        editKey = key;
        editRow = null;
        editDupIds = [];
        setOverlayText(`í¸ì§‘ ëŒ€ìƒ: ${editKey} (ìƒˆë¡œ ê·¸ë¦¬ê¸°)`);
        log(`[LOG] í¸ì§‘ ëŒ€ìƒ ì„¤ì •(ìƒˆë¡œ ê·¸ë¦¬ê¸°): ${editKey}`, "info");
      }

      for (const ring of ringsLatLng){
        if (ring.length>=3) editPolygons.push(createEditPolygonFromRing(ring));
      }
    }

    function getEditRingsWgs84(){
      const rings = [];
      for (const poly of editPolygons){
        const path = poly.getPath(); // LatLngList
        const pts = [];
        for (let i=0;i<path.getLength();i++){
          const ll = path.getAt(i);
          const lat = ll.getLat(), lng = ll.getLng();
          if (lat>=30 && lat<=45 && lng>=120 && lng<=135) pts.push({lat: round6(lat), lng: round6(lng)});
        }
        if (pts.length>=3) rings.push(pts);
      }
      return rings;
    }

    // ================== ë Œë”ë§(ì •ì  í´ë¦¬ê³¤/ë¼ë²¨) ==================
    function clearStaticOverlays(){
      for (const it of staticItems) {
        it.polygons?.forEach(p => p.setMap(null));
        it.labels?.forEach(l => l.setMap(null));
      }
      staticItems = [];
      colorMap = new Map();
    }

    function createRouteLabels(key, ringsLatLng){
      const labels = [];
      if (!labelsOn) return labels;

      const color = colorMap.get(key) || "hsl(200,80%,55%)";

      for (const ring of ringsLatLng) {
        if (!ring || ring.length < 3) continue;

        const coords = ring.map(ll => [ll.getLng(), ll.getLat()]);
        const p = polylabel(coords, 1e-5);

        let pos;
        if (p && isFinite(p[0]) && isFinite(p[1])) pos = new kakao.maps.LatLng(p[1], p[0]);
        else {
          const b = new kakao.maps.LatLngBounds();
          ring.forEach(ll => b.extend(ll));
          pos = b.getCenter();
        }

        const content = document.createElement("div");
        content.className = "route-label";
        content.textContent = key;
        content.style.borderColor = color;

        const overlay = new kakao.maps.CustomOverlay({
          position: pos,
          content,
          yAnchor: 0.5,
          zIndex: 9999
        });
        overlay.setMap(map);
        labels.push(overlay);
      }
      return labels;
    }

    function hideStaticForKey(key){
      const it = staticItems.find(x => x.key === key);
      if (!it) return;
      it.polygons?.forEach(p => p.setMap(null));
      it.labels?.forEach(l => l.setMap(null));
      it.labels = [];
    }

    function restoreStaticForKey(key){
      const it = staticItems.find(x => x.key === key);
      if (!it) return;
      it.polygons?.forEach(p => p.setMap(map));
      it.labels?.forEach(l => l.setMap(null));
      it.labels = labelsOn ? createRouteLabels(it.key, it.ringsLatLng) : [];
    }

    function renderStaticItems(items){
      clearStaticOverlays();

      // ì¸ì ‘ ì»¬ëŸ¬ë§ ìƒì„±
      colorMap = assignColorsByAdjacency(items);

      const bounds = new kakao.maps.LatLngBounds();
      let hasAny = false;

      for (const item of items) {
        const color = colorMap.get(item.key) || "hsl(200,80%,55%)";

        const polys = [];
        for (const ring of item.ringsLatLng) {
          const poly = new kakao.maps.Polygon({
            map,
            path: ring,
            strokeWeight: 2,
            strokeColor: color,
            strokeOpacity: 0.9,
            strokeStyle: "solid",
            fillColor: color,
            fillOpacity: 0.22,
          });

          kakao.maps.event.addListener(poly, "click", () => {
            // í¸ì§‘ í´ë¦¬ê³¤ì´ ìˆìœ¼ë©´ ì €ì¥ ìœ ë„ëŠ” ì¼ë‹¨ ìƒëµ(ìš”ì²­ ì—†ì—ˆìŒ)
            setEditTarget(item);
          });

          polys.push(poly);

          ring.forEach(ll => { bounds.extend(ll); hasAny = true; });
        }

        const labels = labelsOn ? createRouteLabels(item.key, item.ringsLatLng) : [];

        staticItems.push({
          key: item.key,
          row: item.row,
          ringsLatLng: item.ringsLatLng,
          polygons: polys,
          labels,
          dupIds: item.dupIds || []
        });
      }

      if (hasAny) map.setBounds(bounds);
    }

    function setLabelsVisible(on){
      labelsOn = on;
      labelBtn.textContent = labelsOn ? "ë¼ìš°íŠ¸ ë¼ë²¨ ON" : "ë¼ìš°íŠ¸ ë¼ë²¨ OFF";

      for (const it of staticItems) {
        it.labels?.forEach(l => l.setMap(null));
        it.labels = [];
        if (labelsOn) it.labels = createRouteLabels(it.key, it.ringsLatLng);
      }
    }

    // ================== ë¶ˆëŸ¬ì˜¤ê¸° ==================
    async function loadAndShow(){
      const camp = campInput.value.trim();
      const code = routeInput.value.trim();

      if (!camp) { alert("ìº í”„ ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤."); return; }

      // í¸ì§‘ ì´ˆê¸°í™”
      if (editKey) restoreStaticForKey(editKey);
      editKey = null; editRow = null; editDupIds = [];
      clearEditPolygons();
      clearDrawingManagerPolygons();

      try {
        const data = await apiGet("/route", {
          camp,
          code: code || "",
          mode: "prefix"
        });

        const rows = Array.isArray(data?.rows) ? data.rows : [];
        if (!rows.length) {
          clearStaticOverlays();
          log("[WARN] GET ê²°ê³¼ ì—†ìŒ", "warn");
          alert("ì¼ì¹˜í•˜ëŠ” ë¼ìš°íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        // ê°™ì€ codeê°€ ì—¬ëŸ¬ rowë¡œ ë“¤ì–´ì˜¨ ê²½ìš°(ê³¼ê±° ì¤‘ë³µ ë°ì´í„°) â†’ í•œ í™”ë©´ì—ì„œëŠ” â€œêµ¬ì—­ í•©ì¹˜ê¸°â€
        const byKey = new Map();

        // ìµœì‹  updated_at ìš°ì„ 
        const sorted = [...rows].sort((a,b) => String(b.updated_at||"").localeCompare(String(a.updated_at||"")));

        for (const row of sorted) {
          const key = String(row?.code || row?.full_code || "").trim();
          if (!key) continue;

          const ringsLatLng = normalizePolygonWgs84ToRingsLatLng(row?.polygon_wgs84);
          if (!ringsLatLng.length) {
            // polygonì´ nullì¸ rowëŠ” í™”ë©´ í‘œì‹œì—ëŠ” ì œì™¸(í•„ìš”í•˜ë©´ ì—¬ê¸°ì„œ ë³„ë„ í‘œì‹œ ë¡œì§ ì¶”ê°€ ê°€ëŠ¥)
            continue;
          }

          if (!byKey.has(key)){
            byKey.set(key, { key, row, ringsLatLng: [...ringsLatLng], dupIds: [] });
          } else {
            const cur = byKey.get(key);
            // êµ¬ì—­ í•©ì¹˜ê¸°
            cur.ringsLatLng.push(...ringsLatLng);
            // ì¤‘ë³µ id ê¸°ë¡
            if (row?.id) cur.dupIds.push(row.id);
          }
        }

        const items = [...byKey.values()].sort((a,b) => a.key.localeCompare(b.key));
        if (!items.length){
          clearStaticOverlays();
          log("[WARN] í‘œì‹œ ê°€ëŠ¥í•œ polygon_wgs84 rowê°€ ì—†ìŠµë‹ˆë‹¤.", "warn");
          alert("í‘œì‹œ ê°€ëŠ¥í•œ í´ë¦¬ê³¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        renderStaticItems(items);
        setOverlayText(`ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ. í‘œì‹œ ${items.length}ê°œ`);
        log(`[LOG] âœ… ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ. í‘œì‹œ ${items.length}ê°œ`, "info");
      } catch (e) {
        console.error(e);
        alert("ë¼ìš°íŠ¸ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
    }

    // ================== ì €ì¥ ==================
    function computeCenterFromRings(rings){
      const pts = [];
      for (const r of rings) for (const p of r) pts.push(p);
      if (!pts.length) return null;

      let sumLat = 0, sumLng = 0;
      for (const p of pts) { sumLat += p.lat; sumLng += p.lng; }
      return { lat: sumLat/pts.length, lng: sumLng/pts.length };
    }

    function buildPolygonPayloadFromRings(rings){
      if (!rings || !rings.length) return null;
      return (rings.length === 1) ? rings[0] : rings;
    }

    async function saveCurrent(){
      const camp = campInput.value.trim();
      const code = routeInput.value.trim();

      if (!camp || !code) {
        alert("ìº í”„ ì´ë¦„ê³¼ ë¼ìš°íŠ¸ ì½”ë“œë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.");
        return;
      }

      // í¸ì§‘ í´ë¦¬ê³¤ ê¸°ì¤€ ì €ì¥
      const rings = getEditRingsWgs84();

      // ì‚­ì œ ì €ì¥(í´ë¦¬ê³¤ null)
      if (!rings.length) {
        try {
          await apiPost("/route", { camp, code, polygon_wgs84: null, center_wgs84: null });
          // ì¤‘ë³µ ì •ë¦¬(ìˆìœ¼ë©´)
          await apiPost("/admin", { action:"cleanupDuplicates", camp, code }).catch(()=>{});
          alert("ì‚­ì œ(í´ë¦¬ê³¤ null) ì €ì¥ ì™„ë£Œ");
          await loadAndShow();
        } catch (e) {
          console.error(e);
          alert("ì‚­ì œ ì €ì¥ ì‹¤íŒ¨ (ë¡œê·¸ í™•ì¸)");
        }
        return;
      }

      const center = computeCenterFromRings(rings);
      const polygonPayload = buildPolygonPayloadFromRings(rings);

      try {
        await apiPost("/route", { camp, code, polygon_wgs84: polygonPayload, center_wgs84: center });
        // ê³¼ê±° ì¤‘ë³µ rowê°€ ë‚¨ì•„ìˆì„ ìˆ˜ ìˆì–´ì„œ ì •ë¦¬
        await apiPost("/admin", { action:"cleanupDuplicates", camp, code }).catch(()=>{});
        alert("ì €ì¥ ì™„ë£Œ");
        await loadAndShow();
      } catch (e) {
        console.error(e);
        alert("ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
    }

    // ================== ì§€ë„ ì •ë ¬(OSM) ==================
    function computeBboxFromRings(rings){
      let minLat=90,maxLat=-90,minLng=180,maxLng=-180;
      for (const ring of rings) for (const p of ring) {
        minLat=Math.min(minLat,p.lat); maxLat=Math.max(maxLat,p.lat);
        minLng=Math.min(minLng,p.lng); maxLng=Math.max(maxLng,p.lng);
      }
      return [minLng,minLat,maxLng,maxLat];
    }

    function ensureClosedCoords(coords){
      if (!coords || coords.length < 3) return coords || [];
      const first = coords[0];
      const last  = coords[coords.length-1];
      if (first[0] !== last[0] || first[1] !== last[1]) coords = coords.concat([first]);
      return coords;
    }

    function removeConsecutiveNearDuplicates(coords, tolDeg=1e-7){
      if (!coords || coords.length < 2) return coords || [];
      const out = [coords[0]];
      for (let i=1;i<coords.length;i++){
        const prev = out[out.length-1];
        const cur  = coords[i];
        const d = Math.abs(prev[0]-cur[0]) + Math.abs(prev[1]-cur[1]);
        if (d < tolDeg) continue;
        out.push(cur);
      }
      return out;
    }

    function densifyClosedRing(coordsClosed, stepMeters){
      if (!window.turf || !coordsClosed || coordsClosed.length < 4) return coordsClosed || [];
      let coords = coordsClosed.slice();

      const stepKm = stepMeters / 1000;
      const out = [];
      for (let i=0;i<coords.length-1;i++){
        const a = coords[i];
        const b = coords[i+1];
        out.push(a);

        let segLen = 0;
        try { segLen = turf.length(turf.lineString([a,b]), {units:"kilometers"}); } catch {}
        const n = Math.floor(segLen / stepKm);
        if (n > 1) {
          for (let j=1;j<n;j++){
            const dist = j * stepKm;
            try {
              const p = turf.along(turf.lineString([a,b]), dist, {units:"kilometers"}).geometry.coordinates;
              out.push(p);
            } catch {}
          }
        }
      }
      out.push(coords[coords.length-1]);
      return out;
    }

    function snapCoordsToRoad(coords, roadMulti){
      if (!window.turf || !roadMulti || !coords || !coords.length) return coords || [];
      const out = [];
      for (const c of coords) {
        let snapped = c;
        try {
          const np = turf.nearestPointOnLine(roadMulti, turf.point(c), {units:"kilometers"});
          const distM = (np?.properties?.dist ?? Infinity) * 1000;
          if (distM <= ALIGN.ROAD_SNAP_METERS) snapped = np.geometry.coordinates;
        } catch {}
        out.push(snapped);
      }
      return out;
    }

    function extractOuterRingsFromFeature(feat){
      const g = feat?.type === "Feature" ? feat.geometry : feat;
      const rings = [];
      if (!g) return rings;
      if (g.type === "Polygon") {
        if (g.coordinates?.[0]?.length >= 4) rings.push(g.coordinates[0]);
      } else if (g.type === "MultiPolygon") {
        for (const poly of g.coordinates || []) if (poly?.[0]?.length >= 4) rings.push(poly[0]);
      }
      return rings;
    }

    function coordsRingToWgsPoints(ringCoords){
      let coords = ringCoords;
      if (coords.length >= 2) {
        const f = coords[0], l = coords[coords.length-1];
        if (f[0] === l[0] && f[1] === l[1]) coords = coords.slice(0,-1);
      }
      const pts = coords.map(c => ({ lat: round6(c[1]), lng: round6(c[0]) }))
        .filter(p => isFinite(p.lat) && isFinite(p.lng) && Math.abs(p.lat)<=90 && Math.abs(p.lng)<=180);
      return (pts.length >= 3) ? pts : null;
    }

    function buildRoadMulti(osm){
      const roadsRaw = (osm.roads || []).slice(0, ALIGN.MAX_ROADS);
      if (!window.turf || !roadsRaw.length) return null;
      try {
        const lines = roadsRaw.map(r => r?.coords).filter(c => Array.isArray(c) && c.length >= 2);
        if (!lines.length) return null;
        return turf.multiLineString(lines);
      } catch { return null; }
    }

    function buildBuildingFeatures(osm){
      const buildingsRaw = (osm.buildings || []).slice(0, ALIGN.MAX_BUILDINGS);
      const out = [];
      if (!window.turf || !buildingsRaw.length) return out;

      for (const b of buildingsRaw) {
        const c = b?.coords;
        if (!Array.isArray(c) || c.length < 4) continue;
        const first = c[0];
        const last = c[c.length - 1];
        const ring = (first[0]===last[0] && first[1]===last[1]) ? c : c.concat([first]);
        if (ring.length >= 4) {
          try { out.push(turf.polygon([ring])); } catch {}
        }
      }
      return out;
    }

    function includeBuildings(routeFeat, buildings){
      if (!window.turf || !routeFeat || !buildings?.length) return routeFeat;
      let merged = routeFeat;
      let included = 0;

      for (const b of buildings) {
        let inter = null;
        try {
          if (!turf.booleanIntersects(routeFeat, b)) continue;
          inter = turf.intersect(routeFeat, b);
        } catch { inter = null; }
        if (!inter) continue;

        let bArea = 0, iArea = 0;
        try { bArea = turf.area(b); } catch {}
        try { iArea = turf.area(inter); } catch {}
        if (!bArea) continue;

        const ratio = iArea / bArea;
        if (ratio >= ALIGN.BUILDING_RATIO) {
          try {
            const u = turf.union(merged, b);
            if (u) merged = u;
            included++;
          } catch {}
        }
      }

      if (included) log(`[LOG] ì •ë ¬: ê±´ë¬¼ í¬í•¨ ${included}ê°œ(>=${Math.round(ALIGN.BUILDING_RATIO*100)}%)`, "info");
      return merged;
    }

    function alignOneRingWithOsm(ringWgs, roadMulti, buildingFeatures){
      if (!window.turf) return [ringWgs];

      let coords = ringWgs.map(p => [p.lng, p.lat]);
      coords = removeConsecutiveNearDuplicates(coords);
      coords = ensureClosedCoords(coords);

      coords = densifyClosedRing(coords, ALIGN.DENSIFY_STEP_METERS);
      coords = snapCoordsToRoad(coords, roadMulti);

      coords = removeConsecutiveNearDuplicates(coords);
      coords = ensureClosedCoords(coords);

      let poly;
      try { poly = turf.polygon([coords]); } catch { return [ringWgs]; }

      try { poly = turf.cleanCoords(poly); } catch {}
      try { poly = turf.simplify(poly, {tolerance: ALIGN.SIMPLIFY_TOLERANCE_DEG, highQuality:true}); } catch {}

      let parts = [poly];
      try {
        const unk = turf.unkinkPolygon(poly);
        if (unk?.features?.length) parts = unk.features;
      } catch {}

      const outRings = [];
      for (const part of parts) {
        let merged = includeBuildings(part, buildingFeatures);

        try { merged = turf.cleanCoords(merged); } catch {}
        try { merged = turf.simplify(merged, {tolerance: ALIGN.SIMPLIFY_TOLERANCE_DEG, highQuality:true}); } catch {}

        const ringsCoords = extractOuterRingsFromFeature(merged);
        for (const rc of ringsCoords) {
          const pts = coordsRingToWgsPoints(rc);
          if (pts) outRings.push(pts);
        }
      }
      return outRings.length ? outRings : [ringWgs];
    }

    async function alignTargetsAndSave(targets, camp){
      let allRings = [];
      for (const t of targets) allRings = allRings.concat(t.ringsWgs84);

      if (!allRings.length) { alert("ì •ë ¬í•  í´ë¦¬ê³¤ì´ ì—†ìŠµë‹ˆë‹¤."); return; }

      let bbox = computeBboxFromRings(allRings);
      bbox = [
        bbox[0] - ALIGN.OSM_MARGIN_DEG,
        bbox[1] - ALIGN.OSM_MARGIN_DEG,
        bbox[2] + ALIGN.OSM_MARGIN_DEG,
        bbox[3] + ALIGN.OSM_MARGIN_DEG
      ];

      const osm = await apiGet("/osm", { bbox: bbox.join(",") });
      const roadMulti = buildRoadMulti(osm);
      const buildingFeatures = buildBuildingFeatures(osm);

      for (const t of targets) {
        log(`[LOG] ì •ë ¬ ì‹œì‘: ${t.key}`, "info");

        const aligned = [];
        for (const ring of t.ringsWgs84) {
          const out = alignOneRingWithOsm(ring, roadMulti, buildingFeatures);
          aligned.push(...out);
        }

        if (!aligned.length) {
          log(`[WARN] ì •ë ¬ ê²°ê³¼ ì—†ìŒ: ${t.key} (ìŠ¤í‚µ)`, "warn");
          continue;
        }

        const center = computeCenterFromRings(aligned);
        const polygonPayload = buildPolygonPayloadFromRings(aligned);

        await apiPost("/route", { camp, code: t.key, polygon_wgs84: polygonPayload, center_wgs84: center });
        await apiPost("/admin", { action:"cleanupDuplicates", camp, code: t.key }).catch(()=>{});

        log(`[LOG] âœ… ì •ë ¬ ì €ì¥ ì™„ë£Œ: ${t.key} (êµ¬ì—­ ${aligned.length}ê°œ)`, "info");
      }
    }

    async function alignButtonHandler(){
      const camp = campInput.value.trim();
      const codePrefix = routeInput.value.trim(); // ë¹„ìš°ë©´ camp ì „ì²´

      if (!camp) { alert("ìº í”„ ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤."); return; }

      // 1) í¸ì§‘ ì¤‘ì´ë©´: í¸ì§‘ ëŒ€ìƒë§Œ ì •ë ¬
      if (editKey && editPolygons.length){
        const rings = getEditRingsWgs84();
        if (!rings.length){
          alert("ì •ë ¬í•  í¸ì§‘ í´ë¦¬ê³¤ì´ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }
        await alignTargetsAndSave([{ key: editKey, ringsWgs84: rings }], camp);
        await loadAndShow();
        return;
      }

      // 2) í†µë…¸ì„ (prefix/camp ì „ì²´): í‘œì‹œëœ staticItems ëŒ€ìƒìœ¼ë¡œ ì •ë ¬
      const targets = [];
      for (const it of staticItems) {
        if (codePrefix && !it.key.startsWith(codePrefix)) continue;
        const ringsWgs84 = it.ringsLatLng.map(r => r.map(ll => ({ lat: ll.getLat(), lng: ll.getLng() })));
        if (!ringsWgs84.length) continue;
        targets.push({ key: it.key, ringsWgs84 });
      }

      if (!targets.length) {
        alert("ì •ë ¬í•  ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤. (í‘œì‹œëœ ë…¸ì„ ì´ ì—†ê±°ë‚˜ prefixê°€ ì˜ëª»ë¨)");
        return;
      }

      await alignTargetsAndSave(targets, camp);
      await loadAndShow();
    }

    // ================== ì£¼ì†Œ ê²€ìƒ‰ ==================
    searchAddressBtn.addEventListener("click", () => {
      new daum.Postcode({
        oncomplete: (d) => {
          const address = d.roadAddress || d.jibunAddress || d.address;
          log(`[LOG] ğŸ“ ì£¼ì†Œ ê²€ìƒ‰: ${address}`, "info");

          const geocoder = new kakao.maps.services.Geocoder();
          geocoder.addressSearch(address, (result, status) => {
            if (status === kakao.maps.services.Status.OK) {
              const coords = new kakao.maps.LatLng(result[0].y, result[0].x);

              map.setCenter(coords);
              map.setLevel(3);

              const marker = new kakao.maps.Marker({ map, position: coords });
              setTimeout(() => marker.setMap(null), 2500);

              log(`[LOG] âœ… ìœ„ì¹˜ ì´ë™ ì™„ë£Œ`, "info");
              setOverlayText(`ğŸ“ ${address.substring(0, 40)}...`);

              alert(`ğŸ“ ì£¼ì†Œ ìœ„ì¹˜ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.\ní•„ìš”í•˜ë©´ 'ìƒˆë¡œ ê·¸ë¦¬ê¸°'ë¡œ êµ¬ì—­ì„ ê·¸ë¦¬ì„¸ìš”.`);
            } else {
              alert("âŒ ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            }
          });
        }
      }).open();
    });

    // ================== DB ìˆ˜ì • ê¸°ëŠ¥(/admin) ==================
    async function updateSelectedCamp(){
      const newCamp = campEditInput.value.trim();
      if (!newCamp) { alert("ë³€ê²½í•  ìº í”„ëª…ì„ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: ëŒ€êµ¬3)"); return; }
      if (!editRow?.id) { alert("ë¨¼ì € ì§€ë„ì—ì„œ í•´ë‹¹ ë…¸ì„ ì„ í´ë¦­í•´ í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ì „í™˜í•˜ì„¸ìš”."); return; }

      await apiPost("/admin", { action:"updateCampSelected", id: editRow.id, new_camp: newCamp });
      alert("ì„ íƒ ë…¸ì„  camp ìˆ˜ì • ì™„ë£Œ");
      campInput.value = newCamp;
      await loadAndShow();
    }

    async function renameCampAllMerge(){
      const from = campInput.value.trim();
      const to = campEditInput.value.trim();

      if (!from || !to) { alert("í˜„ì¬ camp(campInput) + ë³€ê²½ camp(campEditInput) ë‘˜ ë‹¤ í•„ìš”í•©ë‹ˆë‹¤."); return; }
      if (from === to) { alert("from/toê°€ ë™ì¼í•©ë‹ˆë‹¤."); return; }

      const res = await apiPost("/admin", { action:"moveCampAllMerge", from_camp: from, to_camp: to });
      alert(`camp ì „ì²´ ì´ê´€(ë³‘í•©) ì™„ë£Œ: moved=${res.moved ?? "?"}, merged=${res.merged ?? "?"}, deleted=${res.deleted ?? "?"}, failed=${res.failed ?? 0}`);

      campInput.value = to;
      await loadAndShow();
    }

    async function renameSelectedRouteCode(){
      const newCode = routeEditInput.value.trim();
      if (!newCode) { alert("ë³€ê²½í•  ë¼ìš°íŠ¸ ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”."); return; }
      if (!editRow?.id) { alert("ë¨¼ì € ì§€ë„ì—ì„œ í•´ë‹¹ ë…¸ì„ ì„ í´ë¦­í•´ í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ì „í™˜í•˜ì„¸ìš”."); return; }

      await apiPost("/admin", { action:"renameCodeSelected", id: editRow.id, new_code: newCode });
      alert("ì„ íƒ ë…¸ì„  ì½”ë“œ ìˆ˜ì • ì™„ë£Œ");
      routeInput.value = newCode;
      await loadAndShow();
    }

    async function deleteSelectedRouteRow(){
      if (!editRow?.id) { alert("ë¨¼ì € ì§€ë„ì—ì„œ í•´ë‹¹ ë…¸ì„ ì„ í´ë¦­í•´ í¸ì§‘ ëŒ€ìƒìœ¼ë¡œ ì „í™˜í•˜ì„¸ìš”."); return; }
      if (!confirm("ì •ë§ DBì—ì„œ ì´ ë…¸ì„ ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ë˜ëŒë¦´ ìˆ˜ ì—†ìŒ)")) return;

      await apiDelete(`/route?id=${encodeURIComponent(editRow.id)}`);
      alert("âœ… ì„ íƒ ë…¸ì„  DB ì‚­ì œ ì™„ë£Œ");

      editKey = null;
      editRow = null;
      editDupIds = [];
      clearEditPolygons();

      await loadAndShow();
    }

    // ================== ë²„íŠ¼ ë°”ì¸ë”© ==================
    loadBtn.addEventListener("click", loadAndShow);

    drawBtn.addEventListener("click", () => {
      // í¸ì§‘ ì¤‘ì´ë©´ ìœ ì§€(êµ¬ì—­ì„ ìƒˆë¡œ ì¶”ê°€í•˜ëŠ” ëŠë‚Œ) ëŒ€ì‹ , editKeyê°€ ì—†ìœ¼ë©´ routeInput í•„ìˆ˜
      const code = routeInput.value.trim();
      if (!code){
        alert("ìƒˆë¡œ ê·¸ë¦¬ê¸° ì „ì— ë¼ìš°íŠ¸ ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: 126E)");
        return;
      }
      if (!editKey) editKey = code;

      clearDrawingManagerPolygons();
      try { drawingManager.select(kakao.maps.drawing.OverlayType.POLYGON); } catch {}

      log("[LOG] ìƒˆë¡œ ê·¸ë¦¬ê¸°: ë‹¤ê°í˜• ëª¨ë“œ ì§„ì….", "info");
      setOverlayText("ìƒˆë¡œ ê·¸ë¦¬ê¸° ëª¨ë“œ: ì§€ë„ì—ì„œ ì˜ì—­ì„ ê·¸ë¦¬ì„¸ìš”.");
    });

    addBtn.addEventListener("click", () => {
      const code = routeInput.value.trim();
      if (!code && !editKey){
        alert("êµ¬ì—­ ì¶”ê°€ ì „ì— ë¼ìš°íŠ¸ ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: 126C)");
        return;
      }
      if (!editKey) editKey = code;

      try { drawingManager.select(kakao.maps.drawing.OverlayType.POLYGON); } catch {}
      log("[LOG] êµ¬ì—­ ì¶”ê°€: ìƒˆ êµ¬ì—­ì„ ì¶”ê°€ë¡œ ê·¸ë¦¬ì„¸ìš”.", "info");
      setOverlayText("êµ¬ì—­ ì¶”ê°€ ëª¨ë“œ: ìƒˆ êµ¬ì—­ì„ ê·¸ë¦¬ì„¸ìš”.");
    });

    saveBtn.addEventListener("click", () => saveCurrent().catch(e => { console.error(e); alert("ì €ì¥ ì˜¤ë¥˜"); }));
    alignBtn.addEventListener("click", () => alignButtonHandler().catch(e => { console.error(e); alert("ì •ë ¬ ì¤‘ ì˜¤ë¥˜ (ì½˜ì†”/ë¡œê·¸ í™•ì¸)"); }));

    labelBtn.addEventListener("click", () => {
      setLabelsVisible(!labelsOn);
      log(labelsOn ? "[LOG] ë¼ìš°íŠ¸ ë¼ë²¨ ON" : "[LOG] ë¼ìš°íŠ¸ ë¼ë²¨ OFF", "info");
    });

    resetBtn.addEventListener("click", () => {
      // í¸ì§‘/ì •ì /ê·¸ë¦¬ê¸° ëª¨ë‘ ì´ˆê¸°í™”
      if (editKey) restoreStaticForKey(editKey);
      editKey = null; editRow = null; editDupIds = [];
      clearEditPolygons();
      clearDrawingManagerPolygons();
      clearStaticOverlays();

      setOverlayText("ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ.");
      log("[LOG] ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ.", "info");
    });

    campUpdateSelectedBtn.addEventListener("click", () => updateSelectedCamp().catch(e => { console.error(e); alert("camp ìˆ˜ì • ì‹¤íŒ¨"); }));
    campRenameAllBtn.addEventListener("click", () => renameCampAllMerge().catch(e => { console.error(e); alert("camp ì´ê´€(ë³‘í•©) ì‹¤íŒ¨"); }));

    routeRenameBtn.addEventListener("click", () => renameSelectedRouteCode().catch(e => { console.error(e); alert("ì½”ë“œ ìˆ˜ì • ì‹¤íŒ¨"); }));
    routeDeleteRowBtn.addEventListener("click", () => deleteSelectedRouteRow().catch(e => { console.error(e); alert("DB ì‚­ì œ ì‹¤íŒ¨"); }));

    // ================== ì´ˆê¸° ì‹¤í–‰ ==================
    kakao.maps.load(initMap);
  </script>
</body>
</html>
