<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>마루웰 라우트 편집기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:#020617;
      color:#e5e7eb;
    }
    body { display:flex; }

    .side {
      width: 380px;
      min-width: 320px;
      max-width: 460px;
      background:#020617;
      border-right:1px solid #1f2937;
      padding:14px 16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .title { font-size:1rem; font-weight:700; }
    .subtitle { font-size:0.75rem; color:#9ca3af; }

    label { font-size:0.78rem; margin-bottom:2px; display:block; }
    input[type="text"] {
      width:100%; padding:7px 10px; border-radius:8px;
      border:1px solid #374151; background:#020617; color:#e5e7eb;
      font-size:0.8rem;
    }

    .btn-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:4px; }
    button {
      border-radius:999px; border:1px solid #374151;
      background:#020617; color:#e5e7eb;
      padding:6px 12px; font-size:0.78rem;
      cursor:pointer; white-space:nowrap;
    }
    button.primary { background:#111827; border-color:#111827; }
    button.danger  { border-color:#b91c1c; color:#fecaca; }
    button:hover { background:#111827; }

    .hint { font-size:0.7rem; color:#6b7280; line-height:1.4; }
    .status-bar {
      font-size:0.7rem; padding:4px 8px; border-radius:999px;
      background:#022c22; color:#6ee7b7;
      display:inline-block; margin-top:4px;
    }
    .status-error { background:#450a0a; color:#fecaca; }

    .log-box {
      margin-top:6px;
      padding:6px 8px;
      border-radius:8px;
      border:1px solid #1f2937;
      background:#020617;
      font-size:0.7rem;
      height:140px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .log-line-time { color:#6b7280; }
    .log-line-info { color:#e5e7eb; }
    .log-line-warn { color:#fbbf24; }
    .log-line-err  { color:#f87171; }

    .map-wrap { flex:1; position:relative; }
    #map { width:100%; height:100%; }

    .overlay-badge {
      position:absolute; top:10px; left:10px;
      background:rgba(15,23,42,0.9); border:1px solid #1f2937;
      border-radius:999px; padding:4px 10px;
      font-size:0.72rem; pointer-events:none;
    }

    .route-label {
      display:inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      color: #0b1220;
      background: rgba(255,255,255,0.85);
      border: 1px solid rgba(15,23,42,0.25);
      box-shadow: 0 2px 10px rgba(0,0,0,0.22);
      user-select: none;
      pointer-events: none;
    }

    @media (max-width:900px) {
      body { flex-direction:column; }
      .side {
        width:100%; max-width:none;
        border-right:none; border-bottom:1px solid #1f2937;
      }
      .map-wrap { height:calc(100% - 300px); }
    }
  </style>

  <!-- turf.js (색상 인접 계산 + 정렬용) -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- Kakao Maps + drawing 라이브러리 -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&libraries=drawing&autoload=false"></script>
</head>
<body>
  <aside class="side">
    <div>
      <div class="title">마루웰 라우트 편집기</div>
      <div class="subtitle">캠프 + 라우트 코드 기반 · Supabase / Cloudflare route API 사용</div>
    </div>

    <div>
      <label for="campInput">캠프 이름 (예: 일산2)</label>
      <input id="campInput" type="text" placeholder="예: 일산2" />
    </div>

    <div>
      <label for="routeInput">라우트 코드 (예: 126, 126B, 126B01) — 비우면 camp 전체 표시</label>
      <input id="routeInput" type="text" placeholder="예: 126 또는 126B01" />
    </div>

    <div class="btn-row">
      <button id="loadBtn" class="primary">불러오기(GET)</button>
      <button id="drawBtn">새로 그리기</button>
      <button id="addBtn">구역 추가</button>
      <button id="saveBtn" class="primary">저장(POST)</button>
      <button id="alignBtn">지도 정렬</button>
      <button id="labelBtn">라우트 표시</button>
      <button id="resetBtn" class="danger">지도 초기화</button>
    </div>

    <div class="hint">
      • GET은 기본적으로 <code>mode=prefix</code>로 조회하여 하위 노선까지 전부 표시합니다.<br/>
      • <b>camp만 입력</b>하고 GET하면 해당 camp의 전체 노선을 표시합니다.<br/>
      • 지도에서 폴리곤 클릭 → 해당 코드가 <b>편집 대상(녹색)</b>으로 전환됩니다.<br/>
      • 구역 추가: 같은 코드에 폴리곤을 여러 개 추가(떨어진 구역 지원).<br/>
      • 저장: 편집 대상 폴리곤(들)을 DB에 저장합니다. (구역 2개 이상이면 다중 배열로 저장)<br/>
      • 지도 정렬: OSM 도로 중심선 스냅 + 건물 50% 포함(가능 범위) 후 자동 저장합니다.<br/>
      • 라우트 라벨: ON/OFF 가능. <b>라벨 위치는 중심점 대신 “북쪽 우선 내부점”</b>으로 잡습니다.
    </div>

    <div id="apiStatus" class="status-bar">API: ready</div>
    <div id="logBox" class="log-box"></div>
  </aside>

  <div class="map-wrap">
    <div id="map"></div>
    <div class="overlay-badge" id="overlayInfo">지도 초기화 중...</div>
  </div>

  <script>
    // ================== 공통 설정 ==================
    const ROUTE_API_BASE = "https://route.maroowell.com"; // Cloudflare Worker

    // 정렬(스냅) 옵션
    const ALIGN = {
      OSM_MARGIN_DEG: 0.0020,          // bbox margin (~200m 정도)
      MAX_ROADS: 900,
      MAX_BUILDINGS: 1200,
      ROAD_SNAP_METERS: 18,            // 도로 중심선 스냅 허용거리
      DENSIFY_STEP_METERS: 18,         // 폴리곤 엣지 점 밀도(스냅 품질)
      SIMPLIFY_TOLERANCE_DEG: 0.00001, // 대략 1m 내외
      BUILDING_RATIO: 0.50,            // 건물 면적 50% 이상 걸치면 포함
      MAX_DENSIFIED_POINTS: 2200
    };

    const logBox      = document.getElementById("logBox");
    const apiStatus   = document.getElementById("apiStatus");
    const overlayInfo = document.getElementById("overlayInfo");
    const campInput   = document.getElementById("campInput");
    const routeInput  = document.getElementById("routeInput");
    const loadBtn     = document.getElementById("loadBtn");
    const drawBtn     = document.getElementById("drawBtn");
    const addBtn      = document.getElementById("addBtn");
    const saveBtn     = document.getElementById("saveBtn");
    const alignBtn    = document.getElementById("alignBtn");
    const labelBtn    = document.getElementById("labelBtn");
    const resetBtn    = document.getElementById("resetBtn");

    function log(message, level = "info") {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2,"0");
      const mm = String(now.getMinutes()).padStart(2,"0");
      const ss = String(now.getSeconds()).padStart(2,"0");

      const line = document.createElement("div");

      const spanTime = document.createElement("span");
      spanTime.textContent = `[${hh}:${mm}:${ss}] `;
      spanTime.className = "log-line-time";
      line.appendChild(spanTime);

      const spanMsg = document.createElement("span");
      spanMsg.textContent = message;
      spanMsg.className = "log-line-" + level;
      line.appendChild(spanMsg);

      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;
    }

    function setApiStatus(msg, isError = false) {
      apiStatus.textContent = "API: " + msg;
      apiStatus.className = "status-bar" + (isError ? " status-error" : "");
    }

    function setOverlayText(msg) {
      overlayInfo.textContent = msg;
    }

    function round6(x){ return Math.round(x * 1e6) / 1e6; }

    // ================== Kakao 지도 & DrawingManager ==================
    let map;
    let drawingManager;

    // 정적(조회) 폴리곤 오버레이들
    let staticItems = []; // [{key, polygons:[Polygon...], labels:[CustomOverlay...], row}]
    let labelsOn = false;

    // 편집 대상
    let editTargetKey = null;     // code (예: 126B01)
    let editTargetRow = null;     // API row
    let editDeleted = false;      // X로 전부 삭제된 상태(저장 시 null 저장)

    // 색상 맵(인접 구역 최대한 다르게)
    let routeColorMap = new Map(); // key -> color string (hsl)

    function initMap() {
      const center = new kakao.maps.LatLng(37.5665, 126.9780);
      map = new kakao.maps.Map(document.getElementById("map"), { center, level: 7 });

      const options = {
        map,
        drawingMode: [kakao.maps.drawing.OverlayType.POLYGON],
        guideTooltip: ["draw", "drag", "edit"],
        // WGS84로 데이터 받기
        coordinate: kakao.maps.drawing.Coordinate.WGS84,
        polygonOptions: {
          draggable: true,
          removable: true,
          editable: true,
          strokeWeight: 3,
          strokeColor: "#22c55e",
          strokeOpacity: 0.95,
          strokeStyle: "solid",
          fillColor: "#22c55e",
          fillOpacity: 0.30,
        },
      };

      drawingManager = new kakao.maps.drawing.DrawingManager(options);

      // 새 도형 생성
      kakao.maps.event.addListener(drawingManager, "drawend", function (data) {
        // drawend는 신규 생성 시 주로 타며, polygon 데이터는 getData로 저장 기준 잡음
        editDeleted = false;
        const rings = getEditableRingsWgs84();
        const sample = rings?.[0]?.slice?.(0,3) || [];
        log(`[LOG] drawend: 편집 폴리곤 생성/수정, 구역 ${rings.length}개`, "info");
        if (sample.length) log(`[DEBUG] sample: ${JSON.stringify(sample)}`, "info");
      });

      // 삭제 이벤트(라이브러리 버전에 따라 안 탈 수도 있음. 그래도 시도)
      kakao.maps.event.addListener(drawingManager, "remove", function () {
        const rings = getEditableRingsWgs84();
        if (!rings.length) {
          editDeleted = true;
          log("[WARN] 편집 폴리곤이 삭제되었습니다(X). 저장하면 DB에서도 삭제(null)됩니다.", "warn");
        }
      });

      setOverlayText("지도 초기화 완료.");
      log("[LOG] 지도 초기화 완료.", "info");
    }

    // ================== DrawingManager 데이터 -> WGS84 링 추출 ==================
    function isPointLike(p){
      return p && typeof p === "object" && (
        ("x" in p && "y" in p) ||
        ("lng" in p && "lat" in p) ||
        ("La" in p && "Ma" in p) ||
        ("longitude" in p && "latitude" in p)
      );
    }

    function pointLikeToLatLng(p){
      const lng = Number(p.x ?? p.lng ?? p.La ?? p.longitude);
      const lat = Number(p.y ?? p.lat ?? p.Ma ?? p.latitude);
      if (!isFinite(lat) || !isFinite(lng)) return null;
      return { lat: round6(lat), lng: round6(lng) };
    }

    // DrawingManager.getData() 구조는 버전별 차이가 있어서 안전하게 처리
    function getEditableRingsWgs84(){
      let data;
      try {
        data = drawingManager.getData();
      } catch (e) {
        log("[ERR] drawingManager.getData() 실패", "err");
        return [];
      }

      const raw = data?.polygon;
      if (!raw || !Array.isArray(raw) || !raw.length) return [];

      const rings = [];

      // raw: [ polygon1, polygon2, ... ]
      // polygon: [points...] 또는 [[outer],[hole]...] 형태
      for (const poly of raw) {
        if (!poly || !Array.isArray(poly) || !poly.length) continue;

        // poly가 points 배열인 경우
        if (isPointLike(poly[0])) {
          const pts = poly.map(pointLikeToLatLng).filter(Boolean);
          if (pts.length >= 3) rings.push(pts);
          continue;
        }

        // poly가 rings 배열([[pt...],[pt...]...])인 경우 → outer만 사용
        if (Array.isArray(poly[0]) && poly[0].length && isPointLike(poly[0][0])) {
          const outer = poly[0].map(pointLikeToLatLng).filter(Boolean);
          if (outer.length >= 3) rings.push(outer);
          continue;
        }
      }

      return rings;
    }

    function clearEditablePolygons(){
      editDeleted = false;
      try {
        drawingManager.cancel();
      } catch {}
      try {
        drawingManager.remove(kakao.maps.drawing.OverlayType.POLYGON);
      } catch (e) {
        // remove가 없는 구버전 대비: put 전에 어차피 덮어쓰기 되긴 함
      }
    }

    function putEditableRingsLatLng(ringsLatLng){
      clearEditablePolygons();
      try {
        for (const ring of ringsLatLng) {
          // drawingManager.put expects LatLng[]
          drawingManager.put(kakao.maps.drawing.OverlayType.POLYGON, ring);
        }
      } catch (e) {
        log("[ERR] drawingManager.put 실패(편집 폴리곤 표시)", "err");
      }
      editDeleted = false;
    }

    // ================== API 통신 ==================
    async function fetchRoutes({camp, code, mode="prefix"}) {
      const url = new URL(ROUTE_API_BASE + "/route");
      if (camp) url.searchParams.set("camp", camp);
      if (code) {
        url.searchParams.set("code", code);
        url.searchParams.set("mode", mode);
      }
      log(`[LOG] GET /route 요청: ${url.toString()}`, "info");
      setApiStatus("GET /route 호출 중...");

      const res = await fetch(url.toString(), { cache: "no-store" });
      const json = await res.json().catch(() => ({}));

      if (!res.ok) {
        setApiStatus(`에러 ${res.status}`, true);
        log(`[ERR] GET /route 실패: ${JSON.stringify(json)}`, "err");
        throw new Error("GET 실패");
      }
      setApiStatus("GET 성공");
      return json;
    }

    async function saveRoute(payload) {
      const url = ROUTE_API_BASE + "/route";
      log(`[LOG] POST /route 요청: ${JSON.stringify(payload)}`, "info");
      setApiStatus("POST /route 호출 중...");

      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: JSON.stringify(payload),
      });
      const json = await res.json().catch(() => ({}));

      if (!res.ok) {
        setApiStatus(`POST 에러 ${res.status}`, true);
        log(`[ERR] POST /route 실패: ${JSON.stringify(json)}`, "err");
        throw new Error("POST 실패");
      }

      setApiStatus("POST 성공");
      log(`[LOG] POST /route 응답: ${JSON.stringify(json)}`, "info");
      return json;
    }

    async function fetchOsm(bbox){
      // bbox: [minLng,minLat,maxLng,maxLat]
      const url = new URL(ROUTE_API_BASE + "/osm");
      url.searchParams.set("bbox", bbox.join(","));
      log(`[LOG] GET /osm 요청: ${url.toString()}`, "info");
      setApiStatus("정렬: OSM 데이터 조회 중...");
      const res = await fetch(url.toString(), { cache: "no-store" });
      const json = await res.json().catch(() => ({}));
      if (!res.ok || !json?.ok) {
        setApiStatus(`정렬: OSM 실패`, true);
        log(`[ERR] GET /osm 실패: ${JSON.stringify(json)}`, "err");
        throw new Error("OSM fetch 실패");
      }
      setApiStatus("정렬: OSM 조회 완료");
      return json;
    }

    // ================== 저장 payload 구성 ==================
    function computeCenterFromRings(rings){
      // rings: [{lat,lng}...][] 형태
      const pts = [];
      for (const r of rings) for (const p of r) pts.push(p);
      if (!pts.length) return null;
      let sumLat=0, sumLng=0;
      for (const p of pts) { sumLat += p.lat; sumLng += p.lng; }
      return { lat: sumLat/pts.length, lng: sumLng/pts.length };
    }

    function buildPolygonPayloadFromRings(rings){
      // 1개면 단일 ring, 2개 이상이면 multi 구역
      if (!rings || !rings.length) return null;
      if (rings.length === 1) return rings[0];
      return rings;
    }

    // ================== 저장된 polygon_wgs84 파싱 ==================
    function normalizeStoredPoint(p){
      if (!p) return null;

      // {lat,lng} / {lat,lon}
      if (typeof p.lat === "number" && typeof p.lng === "number") return { lat: p.lat, lng: p.lng };
      if (typeof p.lat === "number" && typeof p.lon === "number") return { lat: p.lat, lng: p.lon };

      // {latitude, longitude}
      if (typeof p.latitude === "number" && typeof p.longitude === "number") return { lat: p.latitude, lng: p.longitude };

      // [a,b] (대개 [lng,lat] 레거시)
      if (Array.isArray(p) && p.length >= 2) {
        const a0 = Number(p[0]);
        const a1 = Number(p[1]);
        if (!isFinite(a0) || !isFinite(a1)) return null;

        // 한국 범위 기반 판단
        const isLat = (v) => v >= 30 && v <= 45;
        const isLng = (v) => v >= 120 && v <= 135;

        // [lng,lat] 형태
        if (isLng(a0) && isLat(a1)) return { lat: a1, lng: a0 };
        // [lat,lng] 형태
        if (isLat(a0) && isLng(a1)) return { lat: a0, lng: a1 };

        // 일반 위경도 범위 heuristic
        if (Math.abs(a0) <= 180 && Math.abs(a1) <= 90) return { lat: a1, lng: a0 }; // [lng,lat] 우선
        if (Math.abs(a0) <= 90 && Math.abs(a1) <= 180) return { lat: a0, lng: a1 };

        return null;
      }

      return null;
    }

    function normalizePolygonWgs84ToRingsLatLng(polygon_wgs84){
      if (!polygon_wgs84) return [];

      // 1) 단일 ring인지 multi인지 판별
      // - 단일 ring: [point, point, ...]
      // - multi: [ [point...], [point...] ... ]
      const ringsRaw = (Array.isArray(polygon_wgs84) && polygon_wgs84.length)
        ? (
            // polygon_wgs84[0]가 point-like이면 단일 ring
            (typeof polygon_wgs84[0] === "object" && !Array.isArray(polygon_wgs84[0]) && normalizeStoredPoint(polygon_wgs84[0]))
              ? [polygon_wgs84]
              : (
                  // polygon_wgs84[0]가 배열이고 내부가 point-like면 multi
                  (Array.isArray(polygon_wgs84[0])) ? polygon_wgs84 : [polygon_wgs84]
                )
          )
        : [];

      const out = [];

      for (const ring of ringsRaw) {
        if (!Array.isArray(ring) || ring.length < 3) continue;
        const pts = [];
        for (const p of ring) {
          const n = normalizeStoredPoint(p);
          if (!n) continue;
          if (!isFinite(n.lat) || !isFinite(n.lng)) continue;
          if (Math.abs(n.lat) > 90 || Math.abs(n.lng) > 180) continue;
          pts.push(new kakao.maps.LatLng(n.lat, n.lng));
        }
        if (pts.length >= 3) out.push(pts);
      }
      return out;
    }

    // ================== 라우트 렌더링 (정적) ==================
    function clearStaticOverlays(){
      for (const it of staticItems) {
        it.polygons?.forEach(p => p.setMap(null));
        it.labels?.forEach(l => l.setMap(null));
      }
      staticItems = [];
    }

    function setLabelsVisible(on){
      labelsOn = on;
      labelBtn.textContent = labelsOn ? "라우트 숨기기" : "라우트 표시";

      // 기존 라벨 제거 후 재생성/숨김
      for (const it of staticItems) {
        it.labels?.forEach(l => l.setMap(null));
        it.labels = [];
        if (labelsOn) {
          it.labels = createRouteLabels(it.key, it.ringsLatLng, getRouteColor(it.key));
        }
      }
    }

    function getRouteColor(key){
      const c = routeColorMap.get(key);
      if (c) return c;
      // fallback
      const h = hashHue(key);
      return `hsl(${h}, 85%, 45%)`;
    }

    function hashHue(str){
      let h = 0;
      for (let i=0;i<str.length;i++) h = (h*31 + str.charCodeAt(i)) >>> 0;
      return h % 360;
    }

    function hueDist(a,b){
      let d = Math.abs(a-b) % 360;
      if (d > 180) d = 360 - d;
      return d;
    }

    function bboxIntersects(a,b, margin=0){
      // a,b: [minX,minY,maxX,maxY]
      return !(a[2]+margin < b[0] || b[2]+margin < a[0] || a[3]+margin < b[1] || b[3]+margin < a[1]);
    }

    function itemToTurfFeature(item){
      if (!window.turf) return null;

      const polys = [];
      for (const ringLatLng of item.ringsLatLng) {
        const coords = ringLatLng.map(ll => [ll.getLng(), ll.getLat()]);
        if (coords.length < 3) continue;
        const first = coords[0];
        const last  = coords[coords.length-1];
        if (first[0] !== last[0] || first[1] !== last[1]) coords.push(first);
        polys.push([coords]); // Polygon coords = [outerRing]
      }

      if (!polys.length) return null;
      if (polys.length === 1) return turf.polygon(polys[0], { key: item.key });
      return turf.multiPolygon(polys, { key: item.key });
    }

    function buildColorMapByAdjacency(items){
      // items: [{key, ringsLatLng}]
      if (!window.turf || !items.length) {
        const m = new Map();
        for (const it of items) m.set(it.key, `hsl(${hashHue(it.key)}, 85%, 45%)`);
        return m;
      }

      // 후보 hue(15도 간격 = 24개)
      const candidates = [];
      for (let h=0; h<360; h+=15) candidates.push(h);

      // feature + buffer + bbox
      const features = items.map(itemToTurfFeature);
      const buffers  = features.map(f => {
        try { return turf.buffer(f, 0.03, {units:"kilometers"}); } catch { return f; } // 30m
      });
      const bboxes   = buffers.map(b => {
        try { return turf.bbox(b); } catch { return null; }
      });

      // 인접 그래프
      const neighbors = new Map();
      for (const it of items) neighbors.set(it.key, new Set());

      for (let i=0;i<items.length;i++){
        if (!buffers[i] || !bboxes[i]) continue;
        for (let j=i+1;j<items.length;j++){
          if (!buffers[j] || !bboxes[j]) continue;
          if (!bboxIntersects(bboxes[i], bboxes[j])) continue;

          let adj = false;
          try {
            adj = turf.booleanIntersects(buffers[i], buffers[j]);
          } catch (e) {
            adj = false;
          }
          if (adj) {
            neighbors.get(items[i].key).add(items[j].key);
            neighbors.get(items[j].key).add(items[i].key);
          }
        }
      }

      // 면적 큰 순으로 색상 배정(인접 대비 최우선)
      const order = items.map((it, idx) => {
        let area = 0;
        try { area = turf.area(features[idx]) || 0; } catch {}
        return { key: it.key, idx, area };
      }).sort((a,b) => b.area - a.area);

      const hueByKey = new Map();

      for (const node of order) {
        const key = node.key;
        const neigh = [...(neighbors.get(key) || [])];
        const usedHues = neigh.map(k => hueByKey.get(k)).filter(v => typeof v === "number");

        const baseHue = hashHue(key);

        let bestHue = null;
        let bestScore = -1;

        for (const cand of candidates) {
          let score;
          if (!usedHues.length) {
            // 이웃 없으면 baseHue에 가장 가까운 후보
            score = 999 - hueDist(cand, baseHue);
          } else {
            // 이웃 있으면: 이웃 색들과의 최소 거리 최대화
            const minD = Math.min(...usedHues.map(h => hueDist(h, cand)));
            // tie-break: baseHue와 너무 멀지 않게
            score = minD * 10 - hueDist(cand, baseHue) * 0.1;
          }

          if (score > bestScore) {
            bestScore = score;
            bestHue = cand;
          }
        }

        if (typeof bestHue !== "number") bestHue = baseHue;
        hueByKey.set(key, bestHue);
      }

      const out = new Map();
      for (const it of items) {
        const h = hueByKey.get(it.key) ?? hashHue(it.key);
        out.set(it.key, `hsl(${h}, 85%, 45%)`);
      }
      return out;
    }

    // ================== 라벨 위치 계산(중요: 126D 문제 해결) ==================
    function computeBoundsCenterLatLng(ringLatLng){
      const b = new kakao.maps.LatLngBounds();
      ringLatLng.forEach(ll => b.extend(ll));
      return b.getCenter();
    }

    // “북쪽(위) 우선 내부점” 탐색 → 실패 시 pointOnFeature
    function computeNorthInsideLabelLatLng(ringLatLng){
      if (!window.turf || !ringLatLng || ringLatLng.length < 3) {
        return computeBoundsCenterLatLng(ringLatLng);
      }

      const coords = ringLatLng.map(ll => [ll.getLng(), ll.getLat()]);
      if (coords.length < 3) return computeBoundsCenterLatLng(ringLatLng);

      const first = coords[0];
      const last  = coords[coords.length-1];
      if (first[0] !== last[0] || first[1] !== last[1]) coords.push(first);

      let poly;
      try {
        poly = turf.polygon([coords]);
      } catch (e) {
        return computeBoundsCenterLatLng(ringLatLng);
      }

      let bbox;
      try { bbox = turf.bbox(poly); } catch { bbox = null; }
      if (!bbox) return computeBoundsCenterLatLng(ringLatLng);

      const minLng = bbox[0], minLat = bbox[1], maxLng = bbox[2], maxLat = bbox[3];
      const w = Math.max(1e-9, maxLng - minLng);
      const h = Math.max(1e-9, maxLat - minLat);

      const centerLng = (minLng + maxLng) / 2;

      // 후보 lng를 조금씩 좌우로 흔들면서 "위쪽부터" 내부점 찾기
      const lngCandidates = [
        centerLng,
        centerLng - w * 0.15, centerLng + w * 0.15,
        centerLng - w * 0.30, centerLng + w * 0.30
      ];

      const steps = 28;
      for (let s=0; s<=steps; s++){
        // top 10%부터 내려오면서 탐색 (전체 높이의 75% 범위)
        const t = s / steps;
        const lat = (maxLat - h*0.10) - (h*0.75) * t;

        for (const lng of lngCandidates){
          const pt = turf.point([lng, lat]);
          let inside = false;
          try { inside = turf.booleanPointInPolygon(pt, poly); } catch {}
          if (inside) return new kakao.maps.LatLng(lat, lng);
        }
      }

      // fallback: 폴리곤 내부점(대체로 안정)
      try {
        const p = turf.pointOnFeature(poly).geometry.coordinates; // [lng,lat]
        return new kakao.maps.LatLng(p[1], p[0]);
      } catch (e) {
        return computeBoundsCenterLatLng(ringLatLng);
      }
    }

    function createRouteLabels(key, ringsLatLng, color){
      const labels = [];
      if (!labelsOn) return labels;

      for (let i=0;i<ringsLatLng.length;i++){
        const ring = ringsLatLng[i];
        if (!ring || ring.length < 3) continue;

        const pos = computeNorthInsideLabelLatLng(ring);

        const content = document.createElement("div");
        content.className = "route-label";
        content.textContent = key;

        // 라벨 테두리도 색상 반영(구분감 증가)
        content.style.borderColor = color.replace("hsl", "hsla").replace(")", ", 0.55)");
        content.style.background  = "rgba(255,255,255,0.86)";

        const overlay = new kakao.maps.CustomOverlay({
          position: pos,
          content,
          yAnchor: 1.0,
          zIndex: 9999
        });
        overlay.setMap(map);
        labels.push(overlay);
      }
      return labels;
    }

    function renderStaticItems(items){
      clearStaticOverlays();

      // 색상맵 생성(인접 대비)
      routeColorMap = buildColorMapByAdjacency(items);

      const bounds = new kakao.maps.LatLngBounds();
      let hasAny = false;

      for (const item of items) {
        const color = getRouteColor(item.key);

        const polys = [];
        for (const ring of item.ringsLatLng) {
          const poly = new kakao.maps.Polygon({
            map,
            path: ring,
            strokeWeight: 4,
            strokeColor: color,
            strokeOpacity: 0.98,
            strokeStyle: "solid",
            fillColor: color,
            fillOpacity: 0.20,
          });

          kakao.maps.event.addListener(poly, "click", () => {
            setEditTarget(item.key);
          });

          polys.push(poly);

          ring.forEach(ll => { bounds.extend(ll); hasAny = true; });
        }

        const labels = labelsOn ? createRouteLabels(item.key, item.ringsLatLng, color) : [];

        staticItems.push({
          key: item.key,
          row: item.row,
          ringsLatLng: item.ringsLatLng,
          polygons: polys,
          labels
        });
      }

      if (hasAny) map.setBounds(bounds);
    }

    // 편집 대상 전환: 해당 key 폴리곤을 녹색(편집)으로 이동
    function setEditTarget(key){
      const found = staticItems.find(it => it.key === key);
      if (!found) {
        log(`[WARN] 편집 대상 전환 실패: ${key} not found`, "warn");
        return;
      }

      editTargetKey = key;
      editTargetRow = found.row || null;
      editDeleted = false;

      routeInput.value = key;

      // 해당 key의 정적 폴리곤/라벨은 숨기고, DrawingManager로 옮김
      found.polygons?.forEach(p => p.setMap(null));
      found.labels?.forEach(l => l.setMap(null));
      found.labels = [];

      // 편집 폴리곤 세팅
      putEditableRingsLatLng(found.ringsLatLng);

      log(`[LOG] 편집 대상 전환: ${key}`, "info");
      setOverlayText(`편집 대상: ${key} (녹색)`);
    }

    // ================== 로드/표시 ==================
    async function loadAndShow(){
      const camp = campInput.value.trim();
      const code = routeInput.value.trim();

      if (!camp) {
        alert("캠프 이름은 필수입니다.");
        return;
      }

      // 편집 상태 초기화
      editTargetKey = null;
      editTargetRow = null;
      editDeleted = false;
      clearEditablePolygons();

      try {
        const data = await fetchRoutes({ camp, code: code || "", mode: "prefix" });

        const rows = Array.isArray(data) ? data : (Array.isArray(data?.rows) ? data.rows : []);
        if (!rows.length) {
          log("[WARN] GET 결과 없음", "warn");
          alert("일치하는 라우트가 없습니다.");
          clearStaticOverlays();
          return;
        }

        // 폴리곤 있는 row만 그룹핑
        const items = [];
        for (const row of rows) {
          const key = (row?.code || row?.full_code || "").trim();
          if (!key) continue;

          const ringsLatLng = normalizePolygonWgs84ToRingsLatLng(row?.polygon_wgs84);
          if (!ringsLatLng.length) continue;

          items.push({ key, row, ringsLatLng });
        }

        if (!items.length) {
          log("[WARN] polygon_wgs84가 있는 row가 없습니다.", "warn");
          alert("표시 가능한 폴리곤 데이터가 없습니다.");
          clearStaticOverlays();
          return;
        }

        // key 중복 제거(동일 code가 여러 row로 올 경우 camp row 우선)
        // 여기서는 간단히: 같은 key면 첫 번째 유지
        const uniq = new Map();
        for (const it of items) {
          if (!uniq.has(it.key)) uniq.set(it.key, it);
        }

        const list = [...uniq.values()].sort((a,b) => a.key.localeCompare(b.key));
        renderStaticItems(list);

        // 자동 편집대상: code가 있고 동일 key가 있으면 그걸 편집으로
        if (code) {
          const match = list.find(it => it.key === code);
          if (match) setEditTarget(match.key);
          else {
            setOverlayText(`표시 ${list.length}개 (편집 대상: 없음)`);
            log(`[LOG] 불러오기 완료. 표시 ${list.length}개 (편집 대상: 없음)`, "info");
          }
        } else {
          setOverlayText(`camp 전체 표시 ${list.length}개 (편집 대상: 없음)`);
          log(`[LOG] 불러오기 완료. 표시 ${list.length}개 (편집 대상: 없음)`, "info");
        }
      } catch (e) {
        console.error(e);
        alert("라우트 조회 중 오류가 발생했습니다.");
      }
    }

    // ================== 저장 ==================
    async function saveCurrent(){
      const camp = campInput.value.trim();
      const code = routeInput.value.trim();

      if (!camp || !code) {
        alert("캠프 이름과 라우트 코드를 모두 입력해주세요.");
        return;
      }

      const rings = getEditableRingsWgs84();

      // X로 다 지운 경우: null 저장(삭제)
      if (editDeleted || !rings.length) {
        log("[WARN] 저장: 편집 폴리곤 없음 → polygon=null 저장(삭제) 시도", "warn");
        try {
          await saveRoute({
            camp,
            code,
            polygon_wgs84: null,
            center_wgs84: null
          });
          alert("삭제(폴리곤 null) 저장 완료");
          await loadAndShow();
          return;
        } catch (e) {
          console.error(e);
          alert("삭제 저장 중 오류가 발생했습니다. (worker가 null 저장을 허용하는지 확인 필요)");
          return;
        }
      }

      // 정상 저장
      const center = computeCenterFromRings(rings);
      log(`[LOG] 저장 준비: code=${code}, 구역 ${rings.length}개, 중심 (${center.lat.toFixed(6)}, ${center.lng.toFixed(6)})`, "info");

      const polygonPayload = buildPolygonPayloadFromRings(rings);

      try {
        await saveRoute({
          camp,
          code,
          polygon_wgs84: polygonPayload,
          center_wgs84: center
        });
        alert("저장 완료되었습니다.");
        await loadAndShow();
      } catch (e) {
        console.error(e);
        alert("저장 중 오류가 발생했습니다.");
      }
    }

    // ================== 지도 정렬(OSM 스냅) ==================
    function computeBboxFromRings(rings){
      let minLat =  90, maxLat = -90, minLng =  180, maxLng = -180;
      for (const ring of rings) {
        for (const p of ring) {
          minLat = Math.min(minLat, p.lat);
          maxLat = Math.max(maxLat, p.lat);
          minLng = Math.min(minLng, p.lng);
          maxLng = Math.max(maxLng, p.lng);
        }
      }
      return [minLng, minLat, maxLng, maxLat];
    }

    function ensureClosedCoords(coords){
      if (!coords || coords.length < 3) return coords || [];
      const first = coords[0];
      const last  = coords[coords.length-1];
      if (first[0] !== last[0] || first[1] !== last[1]) coords = coords.concat([first]);
      return coords;
    }

    function removeConsecutiveNearDuplicates(coords, tolDeg=1e-7){
      if (!coords || coords.length < 2) return coords || [];
      const out = [coords[0]];
      for (let i=1;i<coords.length;i++){
        const prev = out[out.length-1];
        const cur  = coords[i];
        const d = Math.abs(prev[0]-cur[0]) + Math.abs(prev[1]-cur[1]);
        if (d < tolDeg) continue;
        out.push(cur);
      }
      return out;
    }

    function densifyClosedRing(coordsClosed, stepMeters){
      if (!window.turf || !coordsClosed || coordsClosed.length < 4) return coordsClosed || [];

      let coords = coordsClosed.slice();

      // 예상 포인트 수가 너무 많아지면 step을 자동으로 키움
      try {
        const line = turf.lineString(coords);
        const perimKm = turf.length(line, {units:"kilometers"});
        let stepKm = stepMeters / 1000;
        let expected = Math.max(8, Math.floor(perimKm / stepKm));
        if (expected > ALIGN.MAX_DENSIFIED_POINTS) {
          stepKm = perimKm / ALIGN.MAX_DENSIFIED_POINTS;
          stepMeters = stepKm * 1000;
        }
      } catch {}

      const stepKm = stepMeters / 1000;

      const out = [];
      for (let i=0;i<coords.length-1;i++){
        const a = coords[i];
        const b = coords[i+1];
        out.push(a);

        let segLen = 0;
        try { segLen = turf.length(turf.lineString([a,b]), {units:"kilometers"}); } catch { segLen = 0; }

        const n = Math.floor(segLen / stepKm);
        if (n > 1) {
          for (let j=1;j<n;j++){
            const dist = j * stepKm;
            try {
              const p = turf.along(turf.lineString([a,b]), dist, {units:"kilometers"}).geometry.coordinates;
              out.push(p);
            } catch {}
          }
        }
      }
      out.push(coords[coords.length-1]);
      return out;
    }

    function snapCoordsToRoad(coords, roadMulti){
      if (!window.turf || !roadMulti || !coords || !coords.length) return coords || [];
      const out = [];
      for (const c of coords) {
        let snapped = c;
        try {
          const np = turf.nearestPointOnLine(roadMulti, turf.point(c), {units:"kilometers"});
          const distM = (np?.properties?.dist ?? Infinity) * 1000;
          if (distM <= ALIGN.ROAD_SNAP_METERS) snapped = np.geometry.coordinates;
        } catch {}
        out.push(snapped);
      }
      return out;
    }

    function extractOuterRingsFromFeature(feat){
      const g = feat?.type === "Feature" ? feat.geometry : feat;
      const rings = [];

      if (!g) return rings;
      if (g.type === "Polygon") {
        if (g.coordinates?.[0]?.length >= 4) rings.push(g.coordinates[0]);
      } else if (g.type === "MultiPolygon") {
        for (const poly of g.coordinates || []) {
          if (poly?.[0]?.length >= 4) rings.push(poly[0]);
        }
      }
      return rings;
    }

    function coordsRingToWgsPoints(ringCoords){
      // ringCoords: [[lng,lat],... , [lng,lat]] closed
      let coords = ringCoords;
      if (coords.length >= 2) {
        const f = coords[0], l = coords[coords.length-1];
        if (f[0] === l[0] && f[1] === l[1]) coords = coords.slice(0,-1);
      }
      const pts = coords
        .map(c => ({ lat: round6(c[1]), lng: round6(c[0]) }))
        .filter(p => isFinite(p.lat) && isFinite(p.lng) && Math.abs(p.lat)<=90 && Math.abs(p.lng)<=180);

      return (pts.length >= 3) ? pts : null;
    }

    function includeBuildings(routeFeat, buildings){
      if (!window.turf || !routeFeat || !buildings?.length) return routeFeat;

      let merged = routeFeat;
      let included = 0;

      let routeBbox;
      try { routeBbox = turf.bbox(routeFeat); } catch { routeBbox = null; }

      for (const b of buildings) {
        if (!b) continue;

        if (routeBbox) {
          let bb;
          try { bb = turf.bbox(b); } catch { bb = null; }
          if (bb && !bboxIntersects(routeBbox, bb)) continue;
        }

        let inter = null;
        try {
          if (!turf.booleanIntersects(routeFeat, b)) continue;
          inter = turf.intersect(routeFeat, b);
        } catch {
          inter = null;
        }
        if (!inter) continue;

        let bArea = 0, iArea = 0;
        try { bArea = turf.area(b); } catch {}
        try { iArea = turf.area(inter); } catch {}
        if (!bArea) continue;

        const ratio = iArea / bArea;
        if (ratio >= ALIGN.BUILDING_RATIO) {
          try {
            const u = turf.union(merged, b);
            if (u) merged = u;
            included++;
          } catch {}
        }
      }

      if (included) log(`[LOG] 정렬: 건물 포함 ${included}개(>=${Math.round(ALIGN.BUILDING_RATIO*100)}%)`, "info");
      return merged;
    }

    function alignOneRingWithOsm(ringWgs, roadMulti, buildingFeatures){
      if (!window.turf) return [ringWgs];

      // ringWgs: [{lat,lng}...]
      let coords = ringWgs.map(p => [p.lng, p.lat]);
      coords = removeConsecutiveNearDuplicates(coords);
      coords = ensureClosedCoords(coords);

      // densify → snap
      coords = densifyClosedRing(coords, ALIGN.DENSIFY_STEP_METERS);
      coords = snapCoordsToRoad(coords, roadMulti);

      coords = removeConsecutiveNearDuplicates(coords);
      coords = ensureClosedCoords(coords);

      // polygon 생성
      let poly;
      try {
        poly = turf.polygon([coords]);
      } catch (e) {
        return [ringWgs];
      }

      // simplify/clean
      try { poly = turf.cleanCoords(poly); } catch {}
      try { poly = turf.simplify(poly, {tolerance: ALIGN.SIMPLIFY_TOLERANCE_DEG, highQuality:true}); } catch {}

      // unkink(자가교차 분해)
      let parts = [poly];
      try {
        const unk = turf.unkinkPolygon(poly);
        if (unk?.features?.length) parts = unk.features;
      } catch {}

      const outRings = [];

      for (const part of parts) {
        let merged = part;

        // 건물 포함(50% rule)
        merged = includeBuildings(merged, buildingFeatures);

        // 최종 simplify/clean
        try { merged = turf.cleanCoords(merged); } catch {}
        try { merged = turf.simplify(merged, {tolerance: ALIGN.SIMPLIFY_TOLERANCE_DEG, highQuality:true}); } catch {}

        const ringsCoords = extractOuterRingsFromFeature(merged);
        for (const rc of ringsCoords) {
          const pts = coordsRingToWgsPoints(rc);
          if (pts) outRings.push(pts);
        }
      }

      return outRings.length ? outRings : [ringWgs];
    }

    async function alignAndAutoSave(){
      const camp = campInput.value.trim();
      const code = routeInput.value.trim();

      if (!camp || !code) {
        alert("캠프 이름과 라우트 코드를 모두 입력해주세요.");
        return;
      }

      const rings = getEditableRingsWgs84();
      if (!rings.length) {
        alert("정렬할 편집 폴리곤이 없습니다. (녹색 편집 폴리곤을 먼저 선택/생성하세요)");
        return;
      }

      log("[LOG] 지도 정렬 시작", "info");

      // bbox + margin
      let bbox = computeBboxFromRings(rings);
      bbox = [
        bbox[0] - ALIGN.OSM_MARGIN_DEG,
        bbox[1] - ALIGN.OSM_MARGIN_DEG,
        bbox[2] + ALIGN.OSM_MARGIN_DEG,
        bbox[3] + ALIGN.OSM_MARGIN_DEG
      ];

      // OSM 로드
      let osm;
      try {
        osm = await fetchOsm(bbox);
      } catch (e) {
        alert("OSM 데이터 조회 실패. worker에 /osm 엔드포인트가 있는지 확인하세요.");
        return;
      }

      // roads multiLine
      const roadsRaw = (osm.roads || []).slice(0, ALIGN.MAX_ROADS);
      let roadMulti = null;
      if (window.turf && roadsRaw.length) {
        try {
          const lines = roadsRaw
            .map(r => r?.coords)
            .filter(c => Array.isArray(c) && c.length >= 2);
          if (lines.length) roadMulti = turf.multiLineString(lines);
        } catch {}
      }

      // buildings features
      const buildingsRaw = (osm.buildings || []).slice(0, ALIGN.MAX_BUILDINGS);
      const buildingFeatures = [];
      if (window.turf && buildingsRaw.length) {
        for (const b of buildingsRaw) {
          const c = b?.coords;
          if (!Array.isArray(c) || c.length < 4) continue;
          // close
          const first = c[0];
          const last = c[c.length-1];
          const ring = (first[0]===last[0] && first[1]===last[1]) ? c : c.concat([first]);
          try {
            buildingFeatures.push(turf.polygon([ring]));
          } catch {}
        }
      }

      // 각 ring 정렬
      const aligned = [];
      for (const ring of rings) {
        const out = alignOneRingWithOsm(ring, roadMulti, buildingFeatures);
        aligned.push(...out);
      }

      if (!aligned.length) {
        alert("정렬 결과가 비었습니다.");
        return;
      }

      // 편집 폴리곤 교체 표시
      const alignedLatLng = aligned.map(r => r.map(p => new kakao.maps.LatLng(p.lat, p.lng)));
      putEditableRingsLatLng(alignedLatLng);

      log(`[LOG] 지도 정렬 적용: 구역 ${aligned.length}개`, "info");

      // 자동 저장
      const center = computeCenterFromRings(aligned);
      const polygonPayload = buildPolygonPayloadFromRings(aligned);

      try {
        setApiStatus("정렬: 저장 중...");
        await saveRoute({
          camp,
          code,
          polygon_wgs84: polygonPayload,
          center_wgs84: center
        });
        setApiStatus("정렬 완료");
        log("[LOG] 지도 정렬 완료(자동 저장)", "info");
        await loadAndShow();
      } catch (e) {
        console.error(e);
        alert("정렬 저장 중 오류가 발생했습니다.");
      }
    }

    // ================== 이벤트 바인딩 ==================
    loadBtn.addEventListener("click", loadAndShow);

    drawBtn.addEventListener("click", () => {
      clearEditablePolygons();
      editTargetKey = routeInput.value.trim() || null;
      editTargetRow = null;
      editDeleted = false;

      try { drawingManager.cancel(); } catch {}
      try { drawingManager.select(kakao.maps.drawing.OverlayType.POLYGON); } catch {}

      log("[LOG] 새로 그리기: 다각형 모드 진입. 지도를 클릭해서 영역을 그리세요.", "info");
      setOverlayText("새로 그리기 모드: 지도에서 영역을 그리세요.");
    });

    addBtn.addEventListener("click", () => {
      // 기존 편집 폴리곤 유지 + 추가로 하나 더 그리기
      editDeleted = false;
      try { drawingManager.cancel(); } catch {}
      try { drawingManager.select(kakao.maps.drawing.OverlayType.POLYGON); } catch {}
      log("[LOG] 구역 추가: 기존 편집 폴리곤 유지 + 새 다각형을 추가로 그리세요.", "info");
      setOverlayText("구역 추가 모드: 새 구역을 그리세요.");
    });

    saveBtn.addEventListener("click", saveCurrent);

    alignBtn.addEventListener("click", alignAndAutoSave);

    labelBtn.addEventListener("click", () => {
      setLabelsVisible(!labelsOn);
      log(labelsOn ? "[LOG] 라우트 라벨 ON" : "[LOG] 라우트 라벨 OFF", "info");
    });

    resetBtn.addEventListener("click", () => {
      clearEditablePolygons();
      clearStaticOverlays();
      editTargetKey = null;
      editTargetRow = null;
      editDeleted = false;
      setOverlayText("지도 초기화 완료. 새로 그리기 또는 불러오기 가능.");
      log("[LOG] 지도 초기화 완료.", "info");
    });

    // ================== 초기 실행 ==================
    kakao.maps.load(initMap);
  </script>
</body>
</html>
