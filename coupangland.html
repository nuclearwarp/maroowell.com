<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>CoupangLand</title>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#ffffff;
      --line:#e6e8ef;
      --text:#111827;
      --muted:#6b7280;
      --primary:#2563eb;
      --primary-weak:rgba(37, 99, 235, .10);
      --shadow:0 10px 30px rgba(0,0,0,.08);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
      background: linear-gradient(180deg, #f5f7ff 0%, #ffffff 40%, #ffffff 100%);
      color:var(--text);
    }

    .topbar{
      position:sticky;
      top:0;
      z-index:50;
      background: rgba(255,255,255,.9);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .topbar-inner{
      max-width: 1440px;
      margin:0 auto;
      padding:18px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
    }

    /* Title */
    .brand{
      display:flex;
      align-items:baseline;
      gap:10px;
      user-select:none;
    }
    .brand .coupang{
      font-weight:900;
      font-size:34px;
      letter-spacing:-.6px;
      line-height:1;
    }
    .brand .coupang span:nth-child(1){color:#e11d48;} /* c */
    .brand .coupang span:nth-child(2){color:#f97316;} /* o */
    .brand .coupang span:nth-child(3){color:#f59e0b;} /* u */
    .brand .coupang span:nth-child(4){color:#22c55e;} /* p */
    .brand .coupang span:nth-child(5){color:#38bdf8;} /* a */
    .brand .coupang span:nth-child(6){color:#3b82f6;} /* n */
    .brand .coupang span:nth-child(7){color:#1d4ed8;} /* g */
    .brand .land{
      font-weight:900;
      font-size:34px;
      letter-spacing:-.6px;
      color:#7a4a21; /* 흙색 */
      line-height:1;
    }

    .top-actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .btn{
      border:1px solid #cfd6ff;
      background:#fff;
      color:#111827;
      padding:10px 14px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.06);
    }
    .btn.primary{
      border-color:#a8b7ff;
      background:#eef2ff;
      color:#1f2a8a;
    }
    .btn.danger{
      border-color:#fca5a5;
      background:#fff5f5;
      color:#b91c1c;
    }

    .wrap{
      max-width:1440px;
      margin:0 auto;
      padding:18px;
    }

    /* Layout: map bigger, right smaller */
    .grid{
      display:grid;
      grid-template-columns: 1.25fr .75fr; /* 왼쪽 더 큼 */
      gap:16px;
      align-items:start;
    }
    @media (max-width: 1100px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card-hd{
      padding:16px 16px 10px 16px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card-hd h2{
      margin:0;
      font-size:16px;
      letter-spacing:-.2px;
    }
    .pill{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      background:#f3f4f6;
      border:1px solid #e5e7eb;
      color:#111827;
      font-weight:700;
      white-space:nowrap;
    }

    .card-bd{padding:14px 16px 16px 16px;}

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:12px;
    }
    .input{
      flex:1;
      min-width:260px;
      padding:12px 12px;
      border:1px solid #e5e7eb;
      border-radius:12px;
      outline:none;
      font-weight:600;
    }
    .select{
      padding:12px 12px;
      border:1px solid #e5e7eb;
      border-radius:12px;
      font-weight:700;
      background:#fff;
    }

    .crumbs{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .chip{
      padding:8px 12px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
      cursor:pointer;
      font-weight:800;
      color:#111827;
      box-shadow:0 6px 14px rgba(0,0,0,.06);
    }
    .chip.active{
      border-color:#a8b7ff;
      background:#eef2ff;
      color:#1f2a8a;
    }

    /* Map bigger */
    .map-wrap{
      position:relative;
      border-radius:16px;
      overflow:hidden;
      border:1px solid #e5e7eb;
      background:#f8fafc;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.03);
    }
    #map{
      width:100%;
      height: 68vh;
      min-height:560px;
      max-height:820px;
    }
    .map-loading{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(255,255,255,.55);
      backdrop-filter: blur(6px);
      z-index:10;
      font-weight:900;
      color:#111827;
    }
    .map-loading.show{display:flex;}

    /* Right panel lists */
    .section{
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px 12px;
      background:#fafbff;
      margin-top:10px;
    }
    .section h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:#111827;
      letter-spacing:-.2px;
    }
    .list{
      margin:0;
      padding-left:18px;
      color:#111827;
      font-weight:650;
      font-size:13px;
      line-height:1.6;
    }
    .muted{color:var(--muted); font-weight:650; font-size:12px;}

    /* Label overlay (지역명 + 숫자) */
    .region-label{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 8px;
      border-radius:999px;
      border:1px solid rgba(0,0,0,.12);
      background:rgba(255,255,255,.92);
      box-shadow:0 10px 22px rgba(0,0,0,.10);
      white-space:nowrap;
      transform: translate(-50%, -50%);
      pointer-events:auto;
      cursor:pointer;
      user-select:none;
    }
    .region-label .name{
      font-size:11px;
      font-weight:900;
      color:#111827;
      letter-spacing:-.2px;
    }
    .region-label .count{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:20px;
      height:20px;
      padding:0 6px;
      border-radius:999px;
      background:#2563eb;
      color:#fff;
      font-size:12px;
      font-weight:900;
      line-height:1;
    }

    .tiny-toggle{
      margin-left:auto;
      display:flex;
      align-items:center;
      gap:8px;
      font-size:12px;
      color:#111827;
      font-weight:800;
    }
    .toggle{
      border:1px solid #e5e7eb;
      border-radius:999px;
      padding:6px 10px;
      cursor:pointer;
      background:#fff;
      user-select:none;
    }
    .toggle.active{
      background:#eef2ff;
      border-color:#a8b7ff;
      color:#1f2a8a;
    }

    .admin{
      margin-top:16px;
    }
    textarea{
      width:100%;
      min-height:160px;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      font-weight:650;
      line-height:1.5;
      outline:none;
      resize:vertical;
    }
    .admin-actions{
      margin-top:10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
  </style>

  <!-- Kakao 지도 SDK -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&libraries=services"></script>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="coupang" aria-label="coupang">
          <span>c</span><span>o</span><span>u</span><span>p</span><span>a</span><span>n</span><span>g</span>
        </div>
        <div class="land">Land</div>
      </div>

      <div class="top-actions">
        <button class="btn primary" id="btnAll">전체 보기</button>
        <button class="btn" id="btnCopy">현재 화면 요약 복사</button>
        <button class="btn danger" id="btnReset">데이터 초기화</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="grid">
      <!-- LEFT -->
      <div class="card">
        <div class="card-hd">
          <h2>지도 기반 조회</h2>
          <div class="pill" id="dataCountPill">데이터: 0건</div>
        </div>

        <div class="card-bd">
          <div class="row">
            <input class="input" id="q" placeholder="검색: 예) 대구 / 대구광역시 / 중구 / 칠성동 / 영등포구 / 마루웰" />
            <button class="btn" id="btnSearch">검색</button>

            <select class="select" id="vendorSel" title="업체 필터">
              <option value="">업체: 전체</option>
            </select>
          </div>

          <div class="row" style="margin-top:-4px;">
            <div class="crumbs" id="crumbs"></div>

            <div class="tiny-toggle" id="dongToggleWrap" style="display:none;">
              <div class="toggle active" id="toggleDataDongs">표시: 데이터 있는 동</div>
              <div class="toggle" id="toggleAllDongs">표시: 전체 동</div>
            </div>
          </div>

          <div class="map-wrap">
            <div id="map"></div>
            <div class="map-loading" id="mapLoading">경계 불러오는 중…</div>
          </div>

          <div class="admin">
            <div class="muted" style="margin-bottom:8px;">데이터 입력/수정(관리용)</div>
            <textarea id="dataBox"></textarea>
            <div class="admin-actions">
              <button class="btn primary" id="btnApply">파싱/적용</button>
              <button class="btn" id="btnSample">샘플 로드</button>
              <button class="btn" id="btnExport">유니크 목록 내보내기</button>
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div class="card-hd">
          <h2>현재 선택 상세</h2>
          <div class="pill" id="scopePill">전체</div>
        </div>
        <div class="card-bd">
          <div class="section">
            <h3>선택 범위</h3>
            <div class="muted" id="scopeText">전체</div>
            <div style="height:8px;"></div>
            <div class="muted">업체 필터: <b id="vendorText">전체</b></div>
            <div style="height:8px;"></div>
            <div class="muted">유니크(업체+지역): <b id="uniqText">0</b></div>
          </div>

          <div class="section">
            <h3>업체 분포 (가나다순)</h3>
            <ul class="list" id="vendorDist"></ul>
            <div class="muted" id="vendorDistEmpty" style="display:none;">표시할 데이터가 없습니다.</div>
          </div>

          <div class="section">
            <h3>동별 업체 (동 가나다순 / 업체 가나다순)</h3>
            <ul class="list" id="dongByVendors"></ul>
            <div class="muted" id="dongByVendorsEmpty" style="display:none;">표시할 데이터가 없습니다.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  /**********************************************************************
   * 0) 설정: 경계 데이터 URL
   **********************************************************************/
  const BOUNDARY = {
    SIDO_URLS: [
      "https://cdn.jsdelivr.net/gh/southkorea/southkorea-maps@master/kostat/2012/json/provinces-geo-simple.json",
      "https://cdn.jsdelivr.net/gh/southkorea/southkorea-maps@master/kostat/2018/json/skorea-provinces-2018-geo.json",
    ],
    SIGUNGU_URLS: [
      "https://cdn.jsdelivr.net/gh/southkorea/southkorea-maps@master/kostat/2018/json/skorea-municipalities-2018-geo.json",
    ],
    DONG_URL_TEMPLATE: (sidoName) => {
      const fname = `hangjeongdong_${sidoName}.geojson`;
      return [
        `./boundaries/${fname}`,
        `https://cdn.jsdelivr.net/gh/raqoon886/Local_HangJeongDong@master/${encodeURIComponent(fname)}`
      ];
    }
  };

  /**********************************************************************
   * 1) 데이터(테스트) 기본값
   **********************************************************************/
  const SAMPLE_TEXT_RAW = `영등포구 대림동 마루웰
영등포구 대림동 마루웰
분당구 대장동 투네스트
용인시 수지구 동천동 투네스트
용인시 수지구 동천동 마루웰
용인시 수지구 동천동 강동물류
영등포구 신길동 마루웰
대구광역시 중구 칠성동 마루웰
대구광역시 중구 동인동 마루웰
서울특별시 강서구 염창동 투네스트
서울특별시 강서구 염창동 마루웰
경기도 용인시 수지구 동천동 마루웰
대구광역시 달서구 월성동 지엔제이
대구광역시 중구 대봉동 123로지스
대구광역시 중구 동인동 123로지스
대구광역시 달성군 화원읍 태호물류
대구광역시 동구 검사동 정직한물류
대구광역시 달서구 감삼동 에스제이
대구광역시 수성구 만촌동 수성영업소
용인시 기흥구 마북동 성하
용인시 기흥구 마북동 타이탄
경기도 화성시 영천동 씨제이대한통운 서울장지
경기도 용인시 기흥구 하갈동 신화종합물류
경기도 용인시 기흥구 영덕동 신화종합물류
경기도 용인시 기흥구 보정동 CTR종합물류
경기도 성남시 분당구 분당동 천상로지스틱스
경기도 성남시 분당구 정자동 아이비그룹
경기도 고양시 일산서구 일산동 HR그룹
경기도 고양시 일산서구 일산동 삼보로직스
경기도 고양시 일산서구 일산동 YS물류
경기도 고양시 일산서구 일산동 JK글로벌로직스
경기도 고양시 일산서구 주엽동 가화컴퍼니
경기도 고양시 일산서구 주엽동 삼보로직스
대구광역시 북구 국우동 제일로지스
대구광역시 북구 학정동 제일로지스
대구광역시 북구 동호동 제일로지스
대구광역시 북구 사수동 제일로지스
대구광역시 북구 금호동 제일로지스
대구광역시 북구 팔달동 제일로지스
대구광역시 북구 침산동 제일로지스
대구광역시 북구 대현동 제일로지스
대구광역시 동구 신천동 제일로지스
대구광역시 동구 신암동 제일로지스
대구광역시 수성구 두산동 제일로지스
대구광역시 수성구 파동 제일로지스
경상북도 경산시 중산동 제일로지스
경상북도 경산시 정평동 제일로지스
경상북도 경산시 대평동 제일로지스
경상북도 경산시 백천동 제일로지스
경상북도 경산시 유곡동 제일로지스
경상북도 경산시 평산동 제일로지스
경상북도 경산시 점천동 제일로지스
경상북도 경산시 신천동 제일로지스
경상북도 경산시 내동 제일로지스
경상북도 경산시 남방동 제일로지스
경상북도 경산시 여천동 제일로지스
경상북도 경산시 남산면 제일로지스
경상북도 경산시 사동 제일로지스
경상북도 경산시 계양동 제일로지스
경상북도 경산시 삼풍동 제일로지스
경상북도 경산시 갑제동 제일로지스
경상북도 경산시 압량읍 제일로지스
경상북도 경산시 진량읍 제일로지스
대구광역시 동구 지묘동 제일로지스
대구광역시 동구 숙천동 제일로지스
대구광역시 동구 사복동 제일로지스
대구광역시 동구 내곡동 제일로지스
대구광역시 수성구 범어동 제일로지스
대구광역시 달서구 두류동 제일로지스
대구광역시 달서구 성당동 제일로지스
대구광역시 남구 대명동 제일로지스
대구광역시 북구 칠성동 제일로지스
대구광역시 북구 동변동 제일로지스
대구광역시 북구 서변동 제일로지스`;

  const SAMPLE_TEXT = SAMPLE_TEXT_RAW.replaceAll("제일로지스", "제일로직스");

  /**********************************************************************
   * 2) 상태
   **********************************************************************/
  const els = {
    map: document.getElementById('map'),
    mapLoading: document.getElementById('mapLoading'),
    q: document.getElementById('q'),
    btnSearch: document.getElementById('btnSearch'),
    btnAll: document.getElementById('btnAll'),
    btnCopy: document.getElementById('btnCopy'),
    btnReset: document.getElementById('btnReset'),

    dataCountPill: document.getElementById('dataCountPill'),
    crumbs: document.getElementById('crumbs'),
    scopePill: document.getElementById('scopePill'),
    scopeText: document.getElementById('scopeText'),
    vendorSel: document.getElementById('vendorSel'),
    vendorText: document.getElementById('vendorText'),
    uniqText: document.getElementById('uniqText'),

    vendorDist: document.getElementById('vendorDist'),
    vendorDistEmpty: document.getElementById('vendorDistEmpty'),
    dongByVendors: document.getElementById('dongByVendors'),
    dongByVendorsEmpty: document.getElementById('dongByVendorsEmpty'),

    dataBox: document.getElementById('dataBox'),
    btnApply: document.getElementById('btnApply'),
    btnSample: document.getElementById('btnSample'),
    btnExport: document.getElementById('btnExport'),

    dongToggleWrap: document.getElementById('dongToggleWrap'),
    toggleDataDongs: document.getElementById('toggleDataDongs'),
    toggleAllDongs: document.getElementById('toggleAllDongs'),
  };

  const state = {
    records: [], // {sido, sigungu, dong, vendor}
    vendorFilter: "",

    // 선택(클릭/검색으로 확정된 것)
    selectedSido: "",
    selectedSigungu: "",
    selectedSidoFeature: null,
    selectedSigunguFeature: null,

    // 동 표시 옵션
    showAllDongs: false,

    // 경계 캐시
    cache: {
      sido: null,
      sigungu: null,
      dongBySido: new Map(), // sidoName -> geojson
    },

    // 현재 지도 레이어(줌 기반)
    currentLayer: "sido", // "sido" | "sigungu" | "dong"

    // Kakao objects
    map: null,
    polygons: [],
    labels: [],

    // 비동기 렌더 레이스 방지용 토큰
    renderSeq: 0,
  };

  /**********************************************************************
   * 3) 유틸
   **********************************************************************/
  function showLoading(on){
    els.mapLoading.classList.toggle('show', !!on);
  }

  function norm(s){ return (s || "").toString().trim(); }
  function normLoose(s){ return norm(s).replace(/\s+/g, ""); }

  function looseEq(a, b){
    const x = normLoose(a);
    const y = normLoose(b);
    if (!x || !y) return false;
    return x === y || x.includes(y) || y.includes(x);
  }

  function normalizeVendorName(v){
    const vv = norm(v);
    if (vv === "제일로지스") return "제일로직스";
    return vv;
  }

  // Daegu 같은 영문이 들어오면 한국어로 강제 매핑
  const SIDO_ALIAS = new Map([
    ["Seoul","서울특별시"],
    ["Busan","부산광역시"],
    ["Daegu","대구광역시"],
    ["Incheon","인천광역시"],
    ["Gwangju","광주광역시"],
    ["Daejeon","대전광역시"],
    ["Ulsan","울산광역시"],
    ["Sejong","세종특별자치시"],
    ["Gyeonggi","경기도"],
    ["Gangwon","강원특별자치도"],
    ["Chungbuk","충청북도"],
    ["Chungnam","충청남도"],
    ["Jeonbuk","전북특별자치도"],
    ["Jeonnam","전라남도"],
    ["Gyeongbuk","경상북도"],
    ["Gyeongnam","경상남도"],
    ["Jeju","제주특별자치도"],
  ]);

  function normalizeSidoName(name){
    const n = norm(name);
    if (SIDO_ALIAS.has(n)) return SIDO_ALIAS.get(n);
    return n;
  }

  function normalizeSigunguForMatch(rawName, focusSido){
    let nm = norm(rawName);
    const fs = norm(focusSido);
    if (fs && nm.includes(fs)){
      nm = nm.replace(fs, "").trim();
    }
    nm = nm.replace(/^\/+/, "").trim();
    nm = nm.replace(/\s+/g, " ").trim();
    return nm || norm(rawName);
  }

  async function fetchFirstJSON(urls){
    let lastErr = null;
    for (const url of urls){
      try{
        const res = await fetch(url, { cache: "force-cache" });
        if (!res.ok) throw new Error(`HTTP ${res.status} @ ${url}`);
        return await res.json();
      }catch(e){
        lastErr = e;
      }
    }
    throw lastErr || new Error("fetchFirstJSON failed");
  }

  function clearMapObjects(){
    for (const p of state.polygons) p.setMap(null);
    for (const l of state.labels) l.setMap(null);
    state.polygons = [];
    state.labels = [];
  }

  function geometryToLatLngPaths(geom){
    const out = [];
    if (!geom) return out;

    const mk = (ring) => ring.map(([lng,lat]) => new kakao.maps.LatLng(lat, lng));

    if (geom.type === "Polygon"){
      const ring = geom.coordinates?.[0] || [];
      out.push(mk(ring));
    } else if (geom.type === "MultiPolygon"){
      for (const poly of (geom.coordinates || [])){
        const ring = poly?.[0] || [];
        out.push(mk(ring));
      }
    }
    return out;
  }

  function featureBounds(feature){
    const b = new kakao.maps.LatLngBounds();
    const geom = feature?.geometry;
    if (!geom) return b;

    const coordsList = [];
    if (geom.type === "Polygon") coordsList.push(geom.coordinates);
    if (geom.type === "MultiPolygon") coordsList.push(...geom.coordinates);

    for (const poly of coordsList){
      if (!poly || !poly[0]) continue;
      for (const [lng,lat] of poly[0]){
        b.extend(new kakao.maps.LatLng(lat, lng));
      }
    }
    return b;
  }

  function featureBBox(feature){
    const geom = feature?.geometry;
    if (!geom) return null;

    let minLat=Infinity, maxLat=-Infinity, minLng=Infinity, maxLng=-Infinity;

    const feedRing = (ring) => {
      for (const [lng,lat] of ring){
        if (lat < minLat) minLat = lat;
        if (lat > maxLat) maxLat = lat;
        if (lng < minLng) minLng = lng;
        if (lng > maxLng) maxLng = lng;
      }
    };

    if (geom.type === "Polygon"){
      const ring = geom.coordinates?.[0];
      if (ring) feedRing(ring);
    } else if (geom.type === "MultiPolygon"){
      for (const poly of (geom.coordinates || [])){
        const ring = poly?.[0];
        if (ring) feedRing(ring);
      }
    }

    if (!isFinite(minLat)) return null;
    return { minLat, maxLat, minLng, maxLng };
  }

  // centroid(라벨/필터용)
  function featureCentroid(feature){
    const geom = feature?.geometry;
    if (!geom) return null;

    let ring = null;
    if (geom.type === "Polygon") ring = geom.coordinates?.[0];
    if (geom.type === "MultiPolygon") ring = geom.coordinates?.[0]?.[0];
    if (!ring || ring.length === 0) return null;

    let sx=0, sy=0, n=0;
    for (const [lng,lat] of ring){
      sx += lng; sy += lat; n++;
    }
    return { lng: sx/n, lat: sy/n };
  }

  function getFeatureName(feature){
    const p = feature?.properties || {};
    return norm(
      p.name || p.NAME_1 || p.NAME_2 || p.NAME || p.CTP_KOR_NM || p.SIG_KOR_NM || p.adm_nm || ""
    );
  }

  function dongGetNames(feature){
    const p = feature?.properties || {};
    const adm = norm(p.adm_nm || "");
    const parts = adm.split(/\s+/g).filter(Boolean);
    const sido = parts[0] || norm(p.sido || p.CTP_KOR_NM || "");
    const sigungu = parts.slice(1, parts.length-1).join(" ") || norm(p.sigungu || p.SIG_KOR_NM || p.sgg_nm || "");
    const dong = parts[parts.length-1] || norm(p.emd_nm || p.DONG || "");
    return { sido, sigungu, dong };
  }

  function uniq(arr){ return Array.from(new Set(arr)); }

  /**********************************************************************
   * 4) 데이터 파싱(주소 축약 케이스 보정)
   **********************************************************************/
  const GU_TO_SIDO = new Map([
    ["영등포구","서울특별시"],
    ["강서구","서울특별시"],
    ["분당구","경기도"],
    ["수지구","경기도"],
    ["기흥구","경기도"],
    ["일산서구","경기도"],
  ]);
  const DISTRICT_TO_FULL_SIGUNGU = new Map([
    ["분당구","성남시 분당구"],
    ["수지구","용인시 수지구"],
    ["기흥구","용인시 기흥구"],
  ]);
  const CITY_TO_SIDO = new Map([
    ["용인시","경기도"],
    ["화성시","경기도"],
    ["성남시","경기도"],
    ["고양시","경기도"],
  ]);

  function parseDataText(text){
    const lines = (text || "").split(/\r?\n/g).map(s => s.trim()).filter(Boolean);
    const out = [];
    for (const line of lines){
      const parts = line.split(/\s+/g).filter(Boolean);
      if (parts.length < 3) continue;
      let vendor = parts[parts.length-1];
      vendor = normalizeVendorName(vendor);

      const addr = parts.slice(0, -1);

      let sido = "";
      let sigungu = "";
      let dong = "";

      const first = addr[0] || "";
      const isSidoToken = /(특별시|광역시|특별자치시|특별자치도|도)$/.test(first);

      if (isSidoToken){
        sido = normalizeSidoName(first);

        if (addr.length >= 3){
          const t1 = addr[1], t2 = addr[2];
          if (/(시|군)$/.test(t1) && /(구)$/.test(t2)){
            sigungu = `${t1} ${t2}`;
            dong = addr[3] || "";
          } else {
            sigungu = t1;
            dong = t2;
          }
        }
      } else {
        if (/(구)$/.test(first)){
          sido = GU_TO_SIDO.get(first) || "서울특별시";
          sigungu = DISTRICT_TO_FULL_SIGUNGU.get(first) || first;
          dong = addr[1] || "";
        } else if (/(시|군)$/.test(first)){
          sido = CITY_TO_SIDO.get(first) || "경기도";
          if (addr.length >= 3 && /(구)$/.test(addr[1])){
            sigungu = `${first} ${addr[1]}`;
            dong = addr[2] || "";
          } else {
            sigungu = first;
            dong = addr[1] || "";
          }
        } else {
          sido = "서울특별시";
          sigungu = first;
          dong = addr[1] || "";
        }
      }

      sido = norm(sido);
      sigungu = norm(sigungu);
      dong = norm(dong);
      vendor = norm(vendor);

      if (!sido || !sigungu || !dong || !vendor) continue;
      out.push({sido, sigungu, dong, vendor});
    }

    // 유니크(업체+지역) 기준 중복 제거
    const seen = new Set();
    const uniqOut = [];
    for (const r of out){
      const k = `${r.vendor}|${r.sido}|${r.sigungu}|${r.dong}`;
      if (seen.has(k)) continue;
      seen.add(k);
      uniqOut.push(r);
    }
    return uniqOut;
  }

  /**********************************************************************
   * 5) 통계(오른쪽 패널)
   **********************************************************************/
  function filteredRecords(){
    const vf = norm(state.vendorFilter);
    return state.records.filter(r => !vf || r.vendor === vf);
  }

  function recordsInScope(){
    const recs = filteredRecords();
    const s = norm(state.selectedSido);
    const g = norm(state.selectedSigungu);

    return recs.filter(r => {
      if (s && normLoose(r.sido) !== normLoose(s)) return false;
      if (g && !looseEq(r.sigungu, g)) return false;
      return true;
    });
  }

  function vendorDistList(){
    const recs = recordsInScope();
    const m = new Map();
    for (const r of recs){
      m.set(r.vendor, (m.get(r.vendor) || 0) + 1);
    }
    return Array.from(m.entries()).sort((a,b)=> a[0].localeCompare(b[0], 'ko'));
  }

  function dongByVendorList(){
    const recs = recordsInScope();
    const m = new Map(); // dong -> Map(vendor -> count)
    for (const r of recs){
      const key = r.dong;
      if (!m.has(key)) m.set(key, new Map());
      const vm = m.get(key);
      vm.set(r.vendor, (vm.get(r.vendor) || 0) + 1);
    }
    const dongs = Array.from(m.keys()).sort((a,b)=> a.localeCompare(b,'ko'));
    const out = [];
    for (const d of dongs){
      const vm = m.get(d);
      const vendors = Array.from(vm.entries()).sort((a,b)=> a[0].localeCompare(b[0],'ko'));
      out.push({ dong: d, vendors });
    }
    return out;
  }

  function buildScopeLabel(){
    const s = norm(state.selectedSido);
    const g = norm(state.selectedSigungu);
    if (!s) return { short:"전체", long:"전체" };
    if (s && !g) return { short:s, long:s };
    return { short:`${s}`, long:`${s} / ${g}` };
  }

  function refreshRightPanel(){
    const scope = buildScopeLabel();
    els.scopePill.textContent = scope.short;
    els.scopeText.textContent = scope.long;

    els.vendorText.textContent = state.vendorFilter ? state.vendorFilter : "전체";
    els.uniqText.textContent = recordsInScope().length;

    // 업체 분포
    const vd = vendorDistList();
    els.vendorDist.innerHTML = "";
    els.vendorDistEmpty.style.display = vd.length ? "none" : "block";
    for (const [name, cnt] of vd){
      const li = document.createElement('li');
      li.textContent = `${name}: ${cnt}`;
      els.vendorDist.appendChild(li);
    }

    // 동별 업체
    const dbv = dongByVendorList();
    els.dongByVendors.innerHTML = "";
    els.dongByVendorsEmpty.style.display = dbv.length ? "none" : "block";
    for (const item of dbv){
      const li = document.createElement('li');
      const vendorsText = item.vendors.map(([v,c]) => `${v}(${c})`).join(", ");
      li.textContent = `${item.dong}: ${vendorsText}`;
      els.dongByVendors.appendChild(li);
    }
  }

  /**********************************************************************
   * 6) 경계 로딩
   **********************************************************************/
  async function loadSido(){
    if (state.cache.sido) return state.cache.sido;
    const json = await fetchFirstJSON(BOUNDARY.SIDO_URLS);
    state.cache.sido = json;
    return json;
  }
  async function loadSigungu(){
    if (state.cache.sigungu) return state.cache.sigungu;
    const json = await fetchFirstJSON(BOUNDARY.SIGUNGU_URLS);
    state.cache.sigungu = json;
    return json;
  }
  async function loadDongForSido(sidoName){
    const key = normalizeSidoName(sidoName);
    if (state.cache.dongBySido.has(key)) return state.cache.dongBySido.get(key);
    const urls = BOUNDARY.DONG_URL_TEMPLATE(key);
    const json = await fetchFirstJSON(urls);
    state.cache.dongBySido.set(key, json);
    return json;
  }

  /**********************************************************************
   * 7) 점-폴리곤 포함 판정(센터 기반 focus)
   **********************************************************************/
  function pointInRing(pt, ring){
    let inside = false;
    for (let i=0, j=ring.length-1; i<ring.length; j=i++){
      const xi = ring[i][0], yi = ring[i][1];
      const xj = ring[j][0], yj = ring[j][1];
      const intersect = ((yi > pt.lat) !== (yj > pt.lat)) &&
        (pt.lng < (xj - xi) * (pt.lat - yi) / ((yj - yi) || 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function pointInFeature(pt, feature){
    const g = feature?.geometry;
    if (!g) return false;

    if (g.type === "Polygon"){
      const ring = g.coordinates?.[0];
      if (!ring) return false;
      return pointInRing(pt, ring);
    }
    if (g.type === "MultiPolygon"){
      for (const poly of (g.coordinates || [])){
        const ring = poly?.[0];
        if (ring && pointInRing(pt, ring)) return true;
      }
      return false;
    }
    return false;
  }

  function findSidoFeatureByName(sidoGeo, name){
    const target = normalizeSidoName(name);
    for (const f of (sidoGeo?.features || [])){
      const nm = normalizeSidoName(getFeatureName(f));
      if (normLoose(nm) === normLoose(target)) return f;
    }
    return null;
  }

  function getSelectedOrFindSidoFeature(sidoGeo, focusSido){
    const fs = normalizeSidoName(focusSido);
    if (state.selectedSidoFeature){
      const sel = normalizeSidoName(getFeatureName(state.selectedSidoFeature));
      if (fs && normLoose(sel) === normLoose(fs)) return state.selectedSidoFeature;
    }
    return fs ? findSidoFeatureByName(sidoGeo, fs) : null;
  }

  function findSigunguFeatureByName(sigunguGeo, focusSidoFeature, focusSidoName, sigunguName){
    const target = norm(sigunguName);
    const feats = sigunguGeo?.features || [];
    const bboxSido = focusSidoFeature ? featureBBox(focusSidoFeature) : null;

    for (const f of feats){
      if (focusSidoFeature){
        const c = featureCentroid(f);
        if (!c) continue;

        if (bboxSido){
          if (c.lat < bboxSido.minLat || c.lat > bboxSido.maxLat || c.lng < bboxSido.minLng || c.lng > bboxSido.maxLng) continue;
        }
        if (!pointInFeature({lat:c.lat, lng:c.lng}, focusSidoFeature)) continue;
      }

      const nm = normalizeSigunguForMatch(getFeatureName(f), focusSidoName);
      if (looseEq(nm, target)) return f;
    }
    return null;
  }

  function pickSidoByCenter(sidoGeo, pt){
    for (const f of (sidoGeo?.features || [])){
      const nm = normalizeSidoName(getFeatureName(f));
      if (pointInFeature(pt, f)) return nm;
    }
    return "";
  }

  function pickSigunguByCenter(sigunguGeo, focusSidoFeature, focusSidoName, pt){
    const feats = sigunguGeo?.features || [];
    const bboxSido = focusSidoFeature ? featureBBox(focusSidoFeature) : null;

    for (const f of feats){
      if (focusSidoFeature){
        const c = featureCentroid(f);
        if (!c) continue;

        if (bboxSido){
          if (c.lat < bboxSido.minLat || c.lat > bboxSido.maxLat || c.lng < bboxSido.minLng || c.lng > bboxSido.maxLng) continue;
        }
        if (!pointInFeature({lat:c.lat, lng:c.lng}, focusSidoFeature)) continue;
      }

      if (pointInFeature(pt, f)){
        return normalizeSigunguForMatch(getFeatureName(f), focusSidoName);
      }
    }
    return "";
  }

  /**********************************************************************
   * 8) 줌 기반 레이어 결정 (여기가 핵심 수정)
   **********************************************************************/
  function getDesiredLayerByZoom(){
    const lv = state.map.getLevel(); // 숫자 클수록 줌아웃
    const hasSido = !!norm(state.selectedSido);

    // ✅ 선택 없는 상태에서 너무 일찍 시군구/동으로 내려가면 라벨 폭발 → sido를 오래 유지
    if (!hasSido){
      if (lv >= 11) return "sido";
      if (lv >= 7) return "sigungu";
      return "dong";
    }

    // ✅ 시도 선택 후 "대구 전체 스케일(대략 lv=11 근처)"에서 구가 안 뜨던 문제 해결:
    //    선택이 있으면 sido는 lv>=12에서만, lv=11은 sigungu로 내려오게.
    if (lv >= 12) return "sido";
    if (lv >= 7) return "sigungu";
    return "dong";
  }

  /**********************************************************************
   * 9) 지도 렌더(폴리곤/라벨)
   **********************************************************************/
  function vendorCountForRegion(sidoName, sigunguName, dongName){
    const vf = norm(state.vendorFilter);
    const recs = state.records.filter(r => {
      if (vf && r.vendor !== vf) return false;
      if (sidoName && normLoose(r.sido) !== normLoose(sidoName)) return false;
      if (sigunguName && !looseEq(r.sigungu, sigunguName)) return false;
      if (dongName && normLoose(r.dong) !== normLoose(dongName)) return false;
      return true;
    });
    return new Set(recs.map(r => r.vendor)).size;
  }

  function makeLabelOverlay(lat, lng, name, count, onClick){
    const div = document.createElement('div');
    div.className = 'region-label';

    const nameEl = document.createElement('span');
    nameEl.className = 'name';
    nameEl.textContent = name;
    div.appendChild(nameEl);

    // 0개면 숫자 표시 없음
    if (count > 0){
      const c = document.createElement('span');
      c.className = 'count';
      c.textContent = String(count);
      div.appendChild(c);
    }

    div.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      onClick?.();
    });

    const overlay = new kakao.maps.CustomOverlay({
      position: new kakao.maps.LatLng(lat, lng),
      content: div,
      yAnchor: 0.5,
      xAnchor: 0.5,
      zIndex: 5
    });
    overlay.setMap(state.map);
    state.labels.push(overlay);
  }

  function drawFeaturePolygons(features, style, onClickFeature){
    for (const f of features){
      const paths = geometryToLatLngPaths(f.geometry);
      for (const path of paths){
        const poly = new kakao.maps.Polygon({
          path,
          strokeWeight: style.strokeWeight,
          strokeColor: style.strokeColor,
          strokeOpacity: style.strokeOpacity,
          strokeStyle: 'solid',
          fillColor: style.fillColor,
          fillOpacity: style.fillOpacity
        });

        poly.setMap(state.map);
        state.polygons.push(poly);

        kakao.maps.event.addListener(poly, 'mouseover', () => {
          poly.setOptions({ fillOpacity: Math.min(style.fillOpacity + 0.08, 0.20) });
        });
        kakao.maps.event.addListener(poly, 'mouseout', () => {
          poly.setOptions({ fillOpacity: style.fillOpacity });
        });
        kakao.maps.event.addListener(poly, 'click', () => onClickFeature?.(f));
      }
    }
  }

  async function renderMap(){
    const mySeq = ++state.renderSeq;
    showLoading(true);

    try{
      // 1) 기본 경계 로드
      const [sidoGeo, sigunguGeo] = await Promise.all([loadSido(), loadSigungu()]);
      if (mySeq !== state.renderSeq) return;

      const center = state.map.getCenter();
      const centerPt = { lat: center.getLat(), lng: center.getLng() };

      // 2) 1차 desired 결정
      let desired = getDesiredLayerByZoom();

      // 3) focusSido 결정 (선택 우선, 없으면 center로)
      let focusSido = normalizeSidoName(state.selectedSido || pickSidoByCenter(sidoGeo, centerPt) || "");

      // ✅ 바다/국외 등으로 focusSido가 안 잡히면 sigungu/dong 금지 → sido로 강제 폴백
      if (!focusSido && desired !== "sido"){
        desired = "sido";
      }

      const focusSidoFeature = focusSido ? getSelectedOrFindSidoFeature(sidoGeo, focusSido) : null;

      // 4) dong일 때만 focusSigungu 필요
      let focusSigungu = "";
      let focusSigunguFeature = null;

      if (desired === "dong"){
        focusSigungu = norm(state.selectedSigungu) || pickSigunguByCenter(sigunguGeo, focusSidoFeature, focusSido, centerPt);

        // ✅ 그래도 못 잡으면 동은 포기하고 sigungu로 폴백
        if (!focusSigungu){
          desired = "sigungu";
        } else {
          if (state.selectedSigunguFeature){
            const selNm = normalizeSigunguForMatch(getFeatureName(state.selectedSigunguFeature), focusSido);
            if (looseEq(selNm, focusSigungu)) focusSigunguFeature = state.selectedSigunguFeature;
          }
          if (!focusSigunguFeature){
            focusSigunguFeature = findSigunguFeatureByName(sigunguGeo, focusSidoFeature, focusSido, focusSigungu);
          }
        }
      }

      // 5) dong 데이터는 최종 desired가 dong일 때만 로드
      let dongGeo = null;
      if (desired === "dong"){
        if (focusSido){
          dongGeo = await loadDongForSido(focusSido);
          if (mySeq !== state.renderSeq) return;
        } else {
          desired = "sigungu";
        }
      }

      // 6) 최종 레이어 확정 + UI 토글
      state.currentLayer = desired;
      els.dongToggleWrap.style.display = (desired === "dong") ? "flex" : "none";

      // 7) 여기서만 clear (로딩 실패/레이스 시 폴리곤 텅 비는 현상 방지)
      clearMapObjects();

      // 스타일(너무 진했던 것 완화)
      const styleSIDO = { strokeWeight: 3, strokeColor:'#2563eb', strokeOpacity:0.45, fillColor:'#2563eb', fillOpacity:0.03 };
      const styleSIG  = { strokeWeight: 3, strokeColor:'#2563eb', strokeOpacity:0.55, fillColor:'#2563eb', fillOpacity:0.04 };
      const styleDONG = { strokeWeight: 2, strokeColor:'#2563eb', strokeOpacity:0.55, fillColor:'#2563eb', fillOpacity:0.05 };

      // =========================
      // LAYER: SIDO
      // =========================
      if (desired === "sido"){
        const feats = (sidoGeo.features || []).map(f => {
          f.__fixedName = normalizeSidoName(getFeatureName(f));
          return f;
        });

        drawFeaturePolygons(feats, styleSIDO, (f) => {
          const nm = normalizeSidoName(f.__fixedName || getFeatureName(f));
          selectSido(nm, f);
        });

        for (const f of feats){
          const nm = normalizeSidoName(f.__fixedName || getFeatureName(f));
          const c = featureCentroid(f);
          if (!c) continue;
          const vcnt = vendorCountForRegion(nm, "", "");
          makeLabelOverlay(c.lat, c.lng, nm, vcnt, () => selectSido(nm, f));
        }
      }

      // =========================
      // LAYER: SIGUNGU
      // =========================
      if (desired === "sigungu"){
        const featsAll = sigunguGeo.features || [];

        // ✅ 선택된/포커스된 시도 내부의 시군구만 보여주기(속성키 변화에도 안정)
        let feats = featsAll;
        if (focusSidoFeature){
          const bb = featureBBox(focusSidoFeature);
          feats = featsAll.filter(f => {
            const c = featureCentroid(f);
            if (!c) return false;
            if (bb){
              if (c.lat < bb.minLat || c.lat > bb.maxLat || c.lng < bb.minLng || c.lng > bb.maxLng) return false;
            }
            return pointInFeature({lat:c.lat, lng:c.lng}, focusSidoFeature);
          });

          // 혹시 centroid 필터가 빈다면(예외 케이스) 속성 기반으로 한번 더 폴백
          if (!feats.length){
            feats = featsAll.filter(f => {
              const p = f.properties || {};
              const s = normalizeSidoName(p.province || p.CTP_KOR_NM || p.sido || p.SIDO || "");
              return s && normLoose(s) === normLoose(focusSido);
            });
          }
        } else {
          // focusSidoFeature를 못 구했는데 sigungu로 왔다면, 안전하게 "현 지도 중심에 포함되는 시군구 1개만" 표시
          const pick = featsAll.find(f => pointInFeature(centerPt, f));
          feats = pick ? [pick] : [];
        }

        drawFeaturePolygons(feats, styleSIG, (f) => {
          const raw = getFeatureName(f);
          const nm = normalizeSigunguForMatch(raw, focusSido);
          selectSigungu(focusSido, nm, f);
        });

        for (const f of feats){
          const raw = getFeatureName(f);
          const nm = normalizeSigunguForMatch(raw, focusSido);
          const c = featureCentroid(f);
          if (!c) continue;

          const vcnt = vendorCountForRegion(focusSido, nm, "");
          makeLabelOverlay(c.lat, c.lng, nm, vcnt, () => selectSigungu(focusSido, nm, f));
        }
      }

      // =========================
      // LAYER: DONG
      // =========================
      if (desired === "dong"){
        const focusS = normalizeSidoName(focusSido);
        const focusG = norm(focusSigungu);

        const featsAll = dongGeo?.features || [];

        // ✅ 선택된 구 폴리곤 기준으로 centroid 포함 여부로 동을 안정 필터링
        const bbG = focusSigunguFeature ? featureBBox(focusSigunguFeature) : null;

        const feats = [];
        for (const f of featsAll){
          const n = dongGetNames(f);
          const sidoOk = !focusS || normLoose(normalizeSidoName(n.sido)) === normLoose(focusS);
          if (!sidoOk) continue;

          const dongName = norm(n.dong);
          if (!dongName) continue;

          // centroid
          const c = featureCentroid(f);
          if (!c) continue;

          if (focusSigunguFeature){
            if (bbG){
              if (c.lat < bbG.minLat || c.lat > bbG.maxLat || c.lng < bbG.minLng || c.lng > bbG.maxLng) continue;
            }
            if (!pointInFeature({lat:c.lat, lng:c.lng}, focusSigunguFeature)) continue;
          } else {
            // 폴백: 문자열 느슨 매칭(기존 방식보다 약간 강화)
            const sg = norm(n.sigungu);
            if (focusG && sg){
              const ok = looseEq(sg, focusG);
              if (!ok) continue;
            }
          }

          const vcnt = vendorCountForRegion(focusS, focusG, dongName);
          if (!state.showAllDongs && vcnt <= 0) continue;

          f.__dongName = dongName;
          feats.push(f);
        }

        drawFeaturePolygons(feats, styleDONG, () => { /* dong click 확장 가능 */ });

        // 라벨: 데이터 있는 동만
        for (const f of feats){
          const dongName = f.__dongName || dongGetNames(f).dong;
          const vcnt = vendorCountForRegion(focusS, focusG, dongName);
          if (vcnt <= 0) continue;

          const c = featureCentroid(f);
          if (!c) continue;
          makeLabelOverlay(c.lat, c.lng, dongName, vcnt, () => {});
        }
      }

    } catch(e){
      // 실패 시 기존 폴리곤을 유지하는 편이 안전하지만, 현재 구조는 로딩 완료 후 clear라서
      // 여기서 굳이 clear하지 않는다.
      console.error(e);
    } finally {
      if (mySeq === state.renderSeq) showLoading(false);
    }
  }

  /**********************************************************************
   * 10) 선택(클릭/검색) 핸들러
   **********************************************************************/
  function selectSido(sidoName, feature){
    state.selectedSido = normalizeSidoName(sidoName);
    state.selectedSigungu = "";
    state.selectedSidoFeature = feature || null;
    state.selectedSigunguFeature = null;

    refreshCrumbs();
    refreshRightPanel();

    const b = featureBounds(feature);
    if (!b.isEmpty()) state.map.setBounds(b);

    scheduleRender();
  }

  function selectSigungu(sidoName, sigunguName, feature){
    state.selectedSido = normalizeSidoName(sidoName || state.selectedSido);
    state.selectedSigungu = norm(sigunguName);
    state.selectedSigunguFeature = feature || null;

    // selectedSidoFeature 없으면 찾아둠(필터 안정화)
    if (!state.selectedSidoFeature){
      loadSido().then(sidoGeo => {
        state.selectedSidoFeature = findSidoFeatureByName(sidoGeo, state.selectedSido);
      }).catch(()=>{});
    }

    refreshCrumbs();
    refreshRightPanel();

    const b = featureBounds(feature);
    if (!b.isEmpty()) state.map.setBounds(b);

    // ✅ 구 클릭하면 동까지 들어가게(요구사항)
    // dong threshold가 lv<=6이므로 6으로 강제
    if (state.map.getLevel() > 6) state.map.setLevel(6);

    scheduleRender();
  }

  function clearSelectionToAll(){
    state.selectedSido = "";
    state.selectedSigungu = "";
    state.selectedSidoFeature = null;
    state.selectedSigunguFeature = null;

    refreshCrumbs();
    refreshRightPanel();

    state.map.setLevel(13);
    state.map.setCenter(new kakao.maps.LatLng(36.5, 127.9));
    scheduleRender();
  }

  function goUpOneStep(){
    if (state.selectedSigungu){
      state.selectedSigungu = "";
      state.selectedSigunguFeature = null;
    } else if (state.selectedSido){
      state.selectedSido = "";
      state.selectedSidoFeature = null;
    }
    refreshCrumbs();
    refreshRightPanel();
    scheduleRender();
  }

  function refreshCrumbs(){
    els.crumbs.innerHTML = "";

    const make = (label, active, onClick) => {
      const d = document.createElement('div');
      d.className = 'chip' + (active ? ' active' : '');
      d.textContent = label;
      d.addEventListener('click', onClick);
      return d;
    };

    els.crumbs.appendChild(make("전체", !state.selectedSido, () => clearSelectionToAll()));

    if (state.selectedSido){
      els.crumbs.appendChild(make(state.selectedSido, true, () => {
        state.selectedSigungu = "";
        state.selectedSigunguFeature = null;
        refreshCrumbs();
        refreshRightPanel();
        scheduleRender();
      }));
    }
    if (state.selectedSigungu){
      els.crumbs.appendChild(make(state.selectedSigungu, true, () => {}));
    }

    if (state.selectedSido || state.selectedSigungu){
      els.crumbs.appendChild(make("← 한 단계 위", false, () => goUpOneStep()));
    }
  }

  /**********************************************************************
   * 11) 렌더 스케줄러(줌/이동 연타 안정화)
   **********************************************************************/
  let renderTimer = null;
  function scheduleRender(){
    if (renderTimer) clearTimeout(renderTimer);
    renderTimer = setTimeout(() => {
      renderMap().catch(console.error);
    }, 90);
  }

  /**********************************************************************
   * 12) 업체 셀렉트/데이터 박스
   **********************************************************************/
  function refreshVendorSelect(){
    const vendors = uniq(state.records.map(r => r.vendor)).sort((a,b)=>a.localeCompare(b,'ko'));
    const cur = state.vendorFilter;

    els.vendorSel.innerHTML = `<option value="">업체: 전체</option>` + vendors.map(v => `<option value="${v}">${v}</option>`).join("");
    els.vendorSel.value = cur || "";
  }

  function setRecords(records){
    state.records = records || [];
    els.dataCountPill.textContent = `데이터: ${state.records.length}건`;
    refreshVendorSelect();
    refreshRightPanel();
    scheduleRender();
  }

  /**********************************************************************
   * 13) 검색
   **********************************************************************/
  function runSearch(){
    const q = norm(els.q.value);
    if (!q){
      scheduleRender();
      return;
    }

    // 업체명이 정확히 일치하면 업체 필터로
    const vendors = new Set(state.records.map(r => r.vendor));
    if (vendors.has(q)){
      state.vendorFilter = q;
      els.vendorSel.value = q;
      refreshRightPanel();
      scheduleRender();
      return;
    }

    // 시도 우선
    const sidoTry = normalizeSidoName(q);
    const sidoExists = new Set(state.records.map(r => r.sido)).has(sidoTry);
    if (sidoExists){
      state.selectedSido = sidoTry;
      state.selectedSigungu = "";
      state.selectedSidoFeature = null;
      state.selectedSigunguFeature = null;
      refreshCrumbs();
      refreshRightPanel();
      scheduleRender();
      return;
    }

    // 시군구로 찾기
    const sigSet = new Set(state.records.map(r => r.sigungu));
    if (sigSet.has(q)){
      const r = state.records.find(x => x.sigungu === q);
      state.selectedSido = r?.sido || "";
      state.selectedSigungu = q;
      state.selectedSidoFeature = null;
      state.selectedSigunguFeature = null;
      refreshCrumbs();
      refreshRightPanel();
      scheduleRender();
      return;
    }

    // 동으로 찾기
    const dongSet = new Set(state.records.map(r => r.dong));
    if (dongSet.has(q)){
      const r = state.records.find(x => x.dong === q);
      if (r){
        state.selectedSido = r.sido;
        state.selectedSigungu = r.sigungu;
        state.selectedSidoFeature = null;
        state.selectedSigunguFeature = null;
        refreshCrumbs();
        refreshRightPanel();
        state.map.setLevel(6);
        scheduleRender();
      }
      return;
    }

    // fallback: 부분 포함
    const found = state.records.find(r =>
      r.sido.includes(q) || r.sigungu.includes(q) || r.dong.includes(q)
    );
    if (found){
      state.selectedSido = found.sido;
      state.selectedSigungu = found.sigungu;
      state.selectedSidoFeature = null;
      state.selectedSigunguFeature = null;
      refreshCrumbs();
      refreshRightPanel();
      state.map.setLevel(7);
      scheduleRender();
    }
  }

  /**********************************************************************
   * 14) 복사/내보내기
   **********************************************************************/
  function copySummary(){
    const scope = buildScopeLabel().long;
    const vf = state.vendorFilter ? state.vendorFilter : "전체";
    const uniqCount = recordsInScope().length;

    const vd = vendorDistList().map(([v,c]) => `- ${v}: ${c}`).join("\n");
    const dbv = dongByVendorList().map(x => `- ${x.dong}: ${x.vendors.map(([v,c])=>`${v}(${c})`).join(", ")}`).join("\n");

    const text = `[CoupangLand]\n선택범위: ${scope}\n업체필터: ${vf}\n유니크(업체+지역): ${uniqCount}\n\n[업체 분포]\n${vd || "- 없음"}\n\n[동별 업체]\n${dbv || "- 없음"}`;

    navigator.clipboard.writeText(text).then(() => {
      alert("복사 완료");
    }).catch(() => {
      prompt("복사 실패: 아래 텍스트를 수동 복사하세요.", text);
    });
  }

  function exportUniqueList(){
    const rows = recordsInScope()
      .map(r => `${r.sido} ${r.sigungu} ${r.dong} ${r.vendor}`)
      .sort((a,b)=>a.localeCompare(b,'ko'));
    const text = rows.join("\n");
    navigator.clipboard.writeText(text).then(() => {
      alert("유니크 목록 복사 완료");
    }).catch(() => {
      prompt("복사 실패: 아래 텍스트를 수동 복사하세요.", text);
    });
  }

  /**********************************************************************
   * 15) 초기화/샘플/적용
   **********************************************************************/
  function loadFromStorage(){
    const t = localStorage.getItem("coupangland_data_text");
    const txt = (t && t.trim()) ? t : SAMPLE_TEXT;
    els.dataBox.value = txt.replaceAll("제일로지스","제일로직스");
    setRecords(parseDataText(els.dataBox.value));
  }

  function applyDataBox(){
    // ✅ 저장/파싱 전 “제일로지스 → 제일로직스” 강제 치환
    let txt = (els.dataBox.value || "").replaceAll("제일로지스","제일로직스");
    els.dataBox.value = txt;
    localStorage.setItem("coupangland_data_text", txt);
    setRecords(parseDataText(txt));
  }

  function resetAll(){
    localStorage.removeItem("coupangland_data_text");
    state.vendorFilter = "";
    els.vendorSel.value = "";
    clearSelectionToAll();
    els.dataBox.value = SAMPLE_TEXT;
    setRecords(parseDataText(SAMPLE_TEXT));
  }

  /**********************************************************************
   * 16) 이벤트 바인딩
   **********************************************************************/
  els.btnSearch.addEventListener('click', runSearch);
  els.q.addEventListener('keydown', (e) => { if (e.key === "Enter") runSearch(); });

  els.vendorSel.addEventListener('change', () => {
    state.vendorFilter = els.vendorSel.value || "";
    refreshRightPanel();
    scheduleRender();
  });

  els.btnAll.addEventListener('click', clearSelectionToAll);
  els.btnCopy.addEventListener('click', copySummary);
  els.btnReset.addEventListener('click', () => {
    if (confirm("데이터를 초기화할까요?")) resetAll();
  });

  els.btnApply.addEventListener('click', applyDataBox);
  els.btnSample.addEventListener('click', () => {
    els.dataBox.value = SAMPLE_TEXT;
    applyDataBox();
  });
  els.btnExport.addEventListener('click', exportUniqueList);

  els.toggleDataDongs.addEventListener('click', () => {
    state.showAllDongs = false;
    els.toggleDataDongs.classList.add('active');
    els.toggleAllDongs.classList.remove('active');
    scheduleRender();
  });
  els.toggleAllDongs.addEventListener('click', () => {
    state.showAllDongs = true;
    els.toggleAllDongs.classList.add('active');
    els.toggleDataDongs.classList.remove('active');
    scheduleRender();
  });

  /**********************************************************************
   * 17) 지도 초기화 + 줌/이동에 따른 자동 레이어 전환
   **********************************************************************/
  function initMap(){
    const center = new kakao.maps.LatLng(36.5, 127.9);
    state.map = new kakao.maps.Map(els.map, { center, level: 13 });

    kakao.maps.event.addListener(state.map, 'zoom_changed', () => scheduleRender());
    kakao.maps.event.addListener(state.map, 'dragend', () => scheduleRender());
  }

  /**********************************************************************
   * 18) 부팅
   **********************************************************************/
  initMap();
  refreshCrumbs();
  loadFromStorage();
  scheduleRender();

})();
</script>
</body>
</html>
