<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="referrer" content="origin" />

  <!-- 썸네일 이미지 (필수) -->
  <meta property="og:image" content="https://maroowell.com/assets/og/maroowell-1200x630.png?v=1" />
  <meta property="og:image:secure_url" content="https://maroowell.com/assets/og/maroowell-1200x630.png?v=1" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:image:alt" content="Maroowell" />

  <title>Maroowell 우편번호 검색기</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico?v=2" />

  <style>
    :root{
      --headerH: 52px;
      --bg:#0f1115;
      --card:#161a22;
      --muted:#8b95a7;
      --text:#e6e9ef;
      --line:#232838;
    }
    *{box-sizing:border-box}
    html,body{height:100%; overflow:hidden;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:14px/1.4 system-ui,AppleSDGothicNeo,"Segoe UI",Roboto;
    }

    header{
      display:flex;
      gap:8px;
      align-items:center;
      padding:12px 16px;
      height:var(--headerH);
      background:#161a22;
      border-bottom:1px solid var(--line);
      position:sticky;
      top:0;
      z-index:50;
    }
    header h1{font-size:18px;font-weight:800;letter-spacing:0.2px;margin:0}
    .muted{color:var(--muted);font-size:12px}
    .spacer{flex:1}

    header a.saveLink{
      color:var(--muted);
      font-size:12px;
      text-decoration:none;
      opacity:.10;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.08);
      user-select:none;
    }
    header a.saveLink:hover{opacity:.22;border-color:rgba(255,255,255,.18)}

    #app{
      display:grid;
      grid-template-columns:360px 1fr;
      height:calc(100dvh - var(--headerH));
      min-height:0;
    }

    #panel{
      padding:14px;
      border-right:1px solid var(--line);
      background:#10141b;
      overflow:auto;
      min-height:0;
    }

    #mapWrap{
      position:relative;
      height:100%;
      min-height:0;
      display:flex;
    }

    #map,#roadview{
      flex:1;
      width:100%;
      height:100%;
      min-width:0;
      min-height:0;
    }
    #roadview{display:none}
    #mapWrap.roadview-open #roadview{display:block}

    .map-controls{
      position:absolute;
      top:10px;
      right:10px;
      z-index:10;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .map-controls button{
      background:rgba(15,17,21,0.82);
      border-color:#2a3142;
      backdrop-filter: blur(6px);
    }
    .map-controls .hint{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid #2a3142;
      background:rgba(15,17,21,0.72);
      color:#cbd5e1;
      font-size:12px;
    }

    label{display:block;margin:10px 0 6px;color:#9aa6b2}
    input,textarea,button{font:inherit}
    textarea{
      width:100%;
      background:#0c0f14;
      border:1px solid #2a3142;
      color:var(--text);
      padding:10px;
      border-radius:10px;
      min-height:90px;
    }
    input{
      width:100%;
      background:#0c0f14;
      border:1px solid #2a3142;
      color:var(--text);
      padding:10px;
      border-radius:10px;
    }

    button{
      background:#1b2230;
      border:1px solid #2a3142;
      color:var(--text);
      padding:6px 10px;
      border-radius:10px;
      cursor:pointer;
    }
    button:hover{border-color:#3a4561}
    button.danger{
      background:#2a1416;
      border-color:#7f1d1d;
      color:#fecaca;
    }
    button.danger:hover{border-color:#ef4444}

    button.merge-on{
      background:#0f2a1f;
      border-color:#22c55e;
      color:#bbf7d0;
    }
    button.merge-on:hover{border-color:#4ade80}

    .zip-label{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:4px 10px;
      border-radius:999px;
      font-weight:800;
      font-size:12px;
      letter-spacing:0.2px;
      color:#0b1220;
      background:rgba(255,255,255,0.92);
      border:2px solid rgba(15,23,42,0.28);
      box-shadow:0 2px 10px rgba(0,0,0,0.22);
      user-select:none;
      pointer-events:none;
      transform:translateY(-2px);
      white-space:nowrap;
    }

    .row{display:flex;gap:8px;flex-wrap:wrap}
    .list{margin-top:10px;display:flex;flex-wrap:wrap;gap:6px}
    .chip{
      border:1px solid #2a3142;
      border-radius:999px;
      padding:6px 10px;
      background:#0c0f14;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .chip button{
      border:none;
      background:transparent;
      color:#94a3b8;
      cursor:pointer;
    }

    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.55);
      z-index:9999;
      padding:16px;
    }
    .modal.open{display:flex}
    .modalCard{
      width:min(520px, 100%);
      background:#0f1626;
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 14px;
      background:#111b2e;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .modalTop b{font-size:14px}
    .modalTop button{
      background:transparent;
      border:1px solid rgba(255,255,255,.12);
      padding:4px 10px;
      border-radius:10px;
      color:#cbd5e1;
    }
    .modalBody{padding:14px}
    .modalBody .row{justify-content:flex-end;margin-top:10px}
    .pill{
      display:inline-flex;
      align-items:flex-start;
      gap:8px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      background:rgba(0,0,0,.22);
      color:#cbd5e1;
      font-size:12px;
      margin-bottom:10px;
      line-height:1.35;
      width:100%;
    }

    @media (max-width: 900px){
      html,body{overflow:auto;}
      #app{grid-template-columns:1fr; height:auto;}
      #panel{order:2; height:auto;}
      #mapWrap{height:60vh;}
      #mapWrap.roadview-open{flex-direction:column;}
    }
  </style>

  <!-- Daum 우편번호 -->
  <script src="https://t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js"></script>

  <!-- proj4 (5179 -> 4326 변환용) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>

  <!-- turf (병합) -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

  <!-- Kakao 지도 SDK -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3"></script>
</head>

<body>
  <header>
    <a href="/coupangRouteMap.html" style="display:flex;align-items:center">
      <img src="/favicon.ico" alt="Maroowell Logo" style="width:24px;height:24px;transform:translateY(-2px);cursor:pointer" />
    </a>
    <h1>Maroowell 우편번호 검색기</h1>
    <span class="muted">다중 우편번호 권역 검색기 · Kakao Map</span>
    <span class="spacer"></span>
    <a id="saveLink" class="saveLink" href="https://map.kakao.com" target="_blank" rel="noreferrer">Kakao Map</a>
  </header>

  <div id="app">
    <aside id="panel">
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="muted">우편번호 여러 개 동시 조회</div>
          <div class="muted">쉼표/공백/줄바꿈 모두 가능</div>
        </div>
        <button id="openAddr">주소검색 추가</button>
      </div>

      <label style="margin-top:12px">우편번호 목록</label>
      <textarea id="zipInput" placeholder="예: 07420, 07421 07422&#10;또는 붙여넣기"></textarea>

      <div class="row" style="margin-top:8px">
        <button id="addBtn">추가</button>
        <button id="searchBtn">지도표시</button>
        <button id="mergeBtn">병합</button>
        <button id="saveBtn">저장</button>
        <button id="clearBtn" class="danger">초기화</button>
      </div>

      <div class="list" id="zipList"></div>

      <p class="muted" style="margin-top:10px">
        • 잘못된 우편번호나 데이터가 없는 경우 미탑재로 안내됩니다.
      </p>
    </aside>

    <div id="mapWrap">
      <div id="map"></div>
      <div id="roadview"></div>
      <div class="map-controls">
        <button id="toggleMapType" title="일반/위성 전환">위성</button>
        <button id="toggleRoadview" title="로드뷰 보기/종료">로드뷰</button>
        <span id="roadviewHint" class="hint" style="display:none">로드뷰: 파란 길(ROADVIEW) 클릭</span>
      </div>
    </div>
  </div>

  <!-- 저장 모달 -->
  <div id="saveModal" class="modal" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-label="폴리곤 저장">
      <div class="modalTop">
        <b>폴리곤 저장</b>
        <button id="saveCloseBtn">닫기</button>
      </div>
      <div class="modalBody">
        <div class="pill">
          • 현재 선택된 우편번호 폴리곤들을 “병합 결과”로 저장합니다.<br/>
          • 저장 시 최종 링은 “원본 면적”으로 클립되어 <b>절대 커지지 않습니다.</b>
        </div>

        <label>캠프(camp)</label>
        <input id="saveCampInput" placeholder="예: M익산1 ..." />

        <label style="margin-top:10px">라우트 코드(code)</label>
        <input id="saveCodeInput" placeholder="예: 익산0그룹 ..." />

        <div class="row">
          <button id="saveDoBtn">저장</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function(){
      "use strict";

      // ====== 엔드포인트 ======
      const ZIP_API_URL = "https://zip.maroowell.com/?zipcode=";
      const ROUTE_ENDPOINT = "https://route.maroowell.com/route";

      // 스냅 거리(미터) - 계산만, 저장/표시는 origMask로 클립해서 절대 커지지 않게 함
      const MERGE_SNAP_METERS = 35;

      // 너무 작은 찌꺼기 제거(㎡)
      const MIN_COMPONENT_AREA_SQM = 800;

      const $ = (sel) => document.querySelector(sel);
      const parseZips = (raw) => [...new Set((raw || "").match(/\d{5}/g) || [])];

      const state = {
        map: null,

        polygons: new Map(), // zip -> [kakao Polygon]
        labels:   new Map(), // zip -> [overlay]
        geoByZip: new Map(), // zip -> turf Feature(MultiPolygon)

        selectedZips: new Set(),

        mergeMode: false,
        mergedPolygons: [],
        mergedRingsWgs84: null,         // ✅ 저장 포맷: rings[]
        mergedOutlineRingsWgs84: null,  // ✅ 표시용: 외곽/홀 경계 링들

        isSatellite: false,
        roadviewOn: false,
        roadviewOpen: false,
        roadview: null,
        roadviewClient: null,
        roadviewClickHandler: null,

        colors: [
          "#ff4b4b","#22c55e","#fbbf24","#3b82f6",
          "#22d3ee","#c084fc","#f472b6","#60a5fa",
          "#34d399","#f97316"
        ]
      };

      function pickColor(seed) {
        let h = 0;
        const s = String(seed);
        for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
        return state.colors[h % state.colors.length];
      }

      function darkenHex(hex, amt=0.18){
        if (!hex || hex[0] !== "#" || hex.length !== 7) return hex;
        const r = Math.max(0, Math.min(255, Math.round(parseInt(hex.slice(1,3),16) * (1-amt))));
        const g = Math.max(0, Math.min(255, Math.round(parseInt(hex.slice(3,5),16) * (1-amt))));
        const b = Math.max(0, Math.min(255, Math.round(parseInt(hex.slice(5,7),16) * (1-amt))));
        return "#" + [r,g,b].map(v=>v.toString(16).padStart(2,"0")).join("");
      }

      // ===== proj4 =====
      proj4.defs(
        "EPSG:5179",
        "+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 " +
          "+x_0=1000000 +y_0=2000000 +ellps=GRS80 " +
          "+towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
      );
      proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

      function convertPoint(x, y) {
        let lon, lat;
        try {
          const out = proj4("EPSG:5179", "EPSG:4326", [x, y]);
          lon = out[0]; lat = out[1];
        } catch {}
        if (!isFinite(lat) || !isFinite(lon) || lat < 30 || lat > 45 || lon < 120 || lon > 135) {
          lon = x; lat = y;
        }
        return { lat, lon };
      }

      // ===== 지도 =====
      function createMap() {
        if (!(window.kakao && kakao.maps)) {
          alert("카카오 지도 SDK 로딩 실패");
          return;
        }
        state.map = new kakao.maps.Map($("#map"), {
          center: new kakao.maps.LatLng(37.5665, 126.978),
          level: 8
        });

        window.addEventListener("resize", () => {
          if (!state.map) return;
          const c = state.map.getCenter();
          state.map.relayout();
          state.map.setCenter(c);
          if (state.roadviewOn && state.roadview && typeof state.roadview.relayout === "function") {
            state.roadview.relayout();
          }
        });
      }

      function setMapTypeSatellite(on) {
        state.isSatellite = !!on;
        if (!state.map) return;
        state.map.setMapTypeId(
          state.isSatellite ? kakao.maps.MapTypeId.HYBRID : kakao.maps.MapTypeId.ROADMAP
        );
        $("#toggleMapType").textContent = state.isSatellite ? "일반" : "위성";
      }

      // ===== 로드뷰 =====
      function ensureRoadview() {
        if (state.roadview && state.roadviewClient) return;
        state.roadview = new kakao.maps.Roadview($("#roadview"));
        state.roadviewClient = new kakao.maps.RoadviewClient();
      }

      function setRoadviewOverlay(on) {
        if (!state.map) return;
        try {
          if (on) state.map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
          else state.map.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
        } catch {}
      }

      function setRoadviewAt(latlng) {
        ensureRoadview();
        const radii = [80, 200, 500, 1200];
        const tryFind = (i) => {
          state.roadviewClient.getNearestPanoId(latlng, radii[i], (panoId) => {
            if (panoId === null || panoId === undefined) {
              if (i < radii.length - 1) return tryFind(i + 1);
              alert("이 위치 근처에는 로드뷰가 없습니다.");
              return;
            }
            state.roadviewOpen = true;
            $("#mapWrap").classList.add("roadview-open");
            setTimeout(() => state.roadview.relayout(), 0);
            state.roadview.setPanoId(panoId, latlng);
          });
        };
        tryFind(0);
      }

      function setRoadviewOn(on) {
        state.roadviewOn = !!on;
        if (!state.roadviewOn) state.roadviewOpen = false;

        $("#roadviewHint").style.display = state.roadviewOn ? "inline-flex" : "none";
        $("#toggleRoadview").textContent = state.roadviewOn ? "로드뷰 종료" : "로드뷰";

        if (!state.roadviewOn) $("#mapWrap").classList.remove("roadview-open");

        if (state.map) {
          const c = state.map.getCenter();
          state.map.relayout();
          state.map.setCenter(c);
        }

        if (state.roadviewOn) {
          setRoadviewOverlay(true);
          if (!state.roadviewClickHandler && state.map) {
            state.roadviewClickHandler = (mouseEvent) => {
              if (!state.roadviewOn) return;
              if (mouseEvent && mouseEvent.latLng) setRoadviewAt(mouseEvent.latLng);
            };
            kakao.maps.event.addListener(state.map, "click", state.roadviewClickHandler);
          }
        } else {
          setRoadviewOverlay(false);
          if (state.roadviewClickHandler && state.map) {
            kakao.maps.event.removeListener(state.map, "click", state.roadviewClickHandler);
          }
          state.roadviewClickHandler = null;
        }
      }

      // ===== UI =====
      function renderZipChips() {
        const list = $("#zipList");
        list.innerHTML = "";

        [...state.selectedZips].sort().forEach((z) => {
          const div = document.createElement("div");
          div.className = "chip";
          const color = pickColor(z);
          div.innerHTML =
            `<b>${z}</b>` +
            `<span style="display:inline-block;width:10px;height:10px;border-radius:2px;background:${color}"></span>` +
            `<button title="삭제">✕</button>`;

          div.querySelector("button").onclick = async () => {
            state.selectedZips.delete(z);
            removeZipData(z);
            renderZipChips();
            if (state.mergeMode) await mergeOn(true);
          };

          list.appendChild(div);
        });
      }

      function removeZipData(zip) {
        if (state.polygons.has(zip)) {
          state.polygons.get(zip).forEach(p => p.setMap(null));
          state.polygons.delete(zip);
        }
        if (state.labels.has(zip)) {
          state.labels.get(zip).forEach(l => l.setMap(null));
          state.labels.delete(zip);
        }
        state.geoByZip.delete(zip);
      }

      function setOriginalVisible(on) {
        const map = on ? state.map : null;
        for (const arr of state.polygons.values()) arr.forEach(p => p.setMap(map));
        for (const arr of state.labels.values())   arr.forEach(l => l.setMap(map));
      }

      // ===== 라벨 =====
      function centroidOfLngLatRing(ringLngLat) {
        if (!ringLngLat || ringLngLat.length < 3) return null;
        const pts = ringLngLat.slice();
        const f = pts[0], l = pts[pts.length - 1];
        if (f[0] !== l[0] || f[1] !== l[1]) pts.push([f[0], f[1]]);

        let area2 = 0, cx6 = 0, cy6 = 0;
        for (let i = 0; i < pts.length - 1; i++) {
          const x0 = pts[i][0], y0 = pts[i][1];
          const x1 = pts[i+1][0], y1 = pts[i+1][1];
          const f2 = x0*y1 - x1*y0;
          area2 += f2;
          cx6 += (x0 + x1) * f2;
          cy6 += (y0 + y1) * f2;
        }
        if (!isFinite(area2) || Math.abs(area2) < 1e-14) return null;
        const cx = cx6 / (3 * area2);
        const cy = cy6 / (3 * area2);
        if (!isFinite(cx) || !isFinite(cy)) return null;
        return new kakao.maps.LatLng(cy, cx);
      }

      function createZipLabelOverlay(zip, color, pos) {
        const el = document.createElement("div");
        el.className = "zip-label";
        el.textContent = zip;
        el.style.borderColor = color;

        return new kakao.maps.CustomOverlay({
          position: pos,
          content: el,
          yAnchor: 0.5,
          zIndex: 9999
        });
      }

      // ===== ZIP 응답 정규화 =====
      function isPoint(v){ return Array.isArray(v) && v.length>=2 && isFinite(v[0]) && isFinite(v[1]); }

      function normalizeToMultiPolygon5179(polygon5179) {
        if (!Array.isArray(polygon5179) || polygon5179.length === 0) return null;

        if (isPoint(polygon5179[0])) return [ [ polygon5179 ] ];
        if (Array.isArray(polygon5179[0]) && polygon5179[0].length && isPoint(polygon5179[0][0])) return [ polygon5179 ];
        if (Array.isArray(polygon5179[0]) && polygon5179[0].length &&
            Array.isArray(polygon5179[0][0]) && polygon5179[0][0].length &&
            isPoint(polygon5179[0][0][0])) return polygon5179;

        return null;
      }

      function closeRingLngLat(ring) {
        if (!ring || ring.length < 3) return ring;
        const f = ring[0], l = ring[ring.length - 1];
        if (f[0] !== l[0] || f[1] !== l[1]) ring.push([f[0], f[1]]);
        return ring;
      }

      function convert5179MultiToWgs84(multi5179) {
        const out = [];
        for (const poly of multi5179) {
          const ringsOut = [];
          for (const ring of poly) {
            const ringOut = [];
            for (const pt of ring) {
              if (!isPoint(pt)) continue;
              const x = Number(pt[0]), y = Number(pt[1]);
              const { lat, lon } = convertPoint(x, y);
              if (!isFinite(lat) || !isFinite(lon)) continue;
              ringOut.push([lon, lat]);
            }
            if (ringOut.length >= 3) {
              closeRingLngLat(ringOut);
              if (ringOut.length >= 4) ringsOut.push(ringOut);
            }
          }
          if (ringsOut.length) out.push(ringsOut);
        }
        return out.length ? out : null;
      }

      function drawZipMultiPolygon(zip, wgsMultiCoords) {
        const color = pickColor(zip);
        const polys = [];
        const overlays = [];

        for (const polyRings of wgsMultiCoords) {
          const ringsLatLng = polyRings.map(ring => {
            const latlngs = ring.map(([lng,lat]) => new kakao.maps.LatLng(lat, lng));
            if (latlngs.length > 1) {
              const f = latlngs[0], l = latlngs[latlngs.length - 1];
              if (f.getLat() === l.getLat() && f.getLng() === l.getLng()) latlngs.pop();
            }
            return latlngs;
          }).filter(r => r.length >= 3);

          if (!ringsLatLng.length) continue;

          const pathForKakao = (ringsLatLng.length === 1) ? ringsLatLng[0] : ringsLatLng;

          const poly = new kakao.maps.Polygon({
            map: state.map,
            path: pathForKakao,
            strokeWeight: 3,
            strokeColor: color,
            strokeOpacity: 1,
            strokeStyle: "solid",
            fillColor: color,
            fillOpacity: 0.25
          });

          polys.push(poly);

          const outerRing = polyRings[0];
          const center = centroidOfLngLatRing(outerRing);
          if (center) {
            const ov = createZipLabelOverlay(zip, color, center);
            ov.setMap(state.map);
            overlays.push(ov);
          }
        }

        if (polys.length) state.polygons.set(zip, polys);
        if (overlays.length) state.labels.set(zip, overlays);
      }

      async function drawSelected() {
        const targets = [...state.selectedZips].filter(z => !state.geoByZip.has(z));
        if (!targets.length) return;

        const notFound = [];

        for (const zip of targets) {
          try {
            const res = await fetch(`${ZIP_API_URL}${encodeURIComponent(zip)}`, { cache: "no-store" });
            const data = await res.json();

            if (!data || !Array.isArray(data.polygon5179) || data.polygon5179.length === 0) {
              notFound.push(zip);
              continue;
            }

            const norm = normalizeToMultiPolygon5179(data.polygon5179);
            if (!norm) { notFound.push(zip); continue; }

            const wgs = convert5179MultiToWgs84(norm);
            if (!wgs) { notFound.push(zip); continue; }

            const feature = {
              type: "Feature",
              properties: { zip },
              geometry: { type: "MultiPolygon", coordinates: wgs }
            };
            state.geoByZip.set(zip, feature);

            drawZipMultiPolygon(zip, wgs);
          } catch {
            notFound.push(zip);
          }
        }

        if (notFound.length) alert(`폴리곤을 그리지 못한 우편번호: ${notFound.join(", ")}`);
      }

      // ===== Bounds =====
      function fitBoundsAllOriginal() {
        if (!state.map) return;
        const b = new kakao.maps.LatLngBounds();
        let has = false;

        for (const arr of state.polygons.values()) {
          for (const poly of arr) {
            const path = poly.getPath();

            if (Array.isArray(path)) {
              path.forEach(ll => { b.extend(ll); has = true; });
              continue;
            }

            if (path && typeof path.getLength === "function" && typeof path.getAt === "function") {
              for (let i = 0; i < path.getLength(); i++) {
                const ring = path.getAt(i);
                if (ring && typeof ring.getLength === "function") {
                  for (let j = 0; j < ring.getLength(); j++) {
                    b.extend(ring.getAt(j));
                    has = true;
                  }
                }
              }
            }
          }
        }
        if (has) state.map.setBounds(b);
      }

      function fitBoundsToRings(rings) {
        if (!state.map || !rings || !rings.length) return;
        const b = new kakao.maps.LatLngBounds();
        let has = false;
        for (const ring of rings) {
          for (const pt of ring) {
            if (!Array.isArray(pt) || pt.length < 2) continue;
            b.extend(new kakao.maps.LatLng(pt[1], pt[0]));
            has = true;
          }
        }
        if (has) state.map.setBounds(b);
      }

      // ===== 병합 UI =====
      function setMergeUI(on){
        state.mergeMode = !!on;
        const btn = $("#mergeBtn");
        btn.textContent = state.mergeMode ? "해제" : "병합";
        btn.classList.toggle("merge-on", state.mergeMode);
      }

      function clearMerged(){
        state.mergedPolygons.forEach(p => p.setMap(null));
        state.mergedPolygons = [];
        state.mergedRingsWgs84 = null;
        state.mergedOutlineRingsWgs84 = null;
      }

      // ===== 병합 (turf 안정화) =====
      function flattenToPolygonFeatures(feature) {
        try {
          const fc = turf.flatten(feature);
          return (fc && fc.features) ? fc.features.filter(f => f?.geometry?.type === "Polygon") : [];
        } catch { return []; }
      }

      function stabilizeFeature(f){
        let out = f;
        try { out = turf.truncate(out, { precision: 6, mutate: false }); } catch {}
        try { out = turf.cleanCoords(out); } catch {}
        try { out = turf.rewind(out, { reverse: false }); } catch {}
        return out;
      }

      function safeBuffer(f, meters){
        if (!meters || meters === 0) return f;
        try {
          return turf.buffer(f, meters, { units: "meters", steps: 16 });
        } catch (e) {
          console.warn("[merge] buffer fail -> use original", e);
          return f;
        }
      }

      function safeUnion(a, b){
        try {
          return turf.union(a, b);
        } catch (e) {
          console.warn("[merge] union fail", e);
          return null;
        }
      }

      function safeIntersect(a, b){
        try {
          const out = turf.intersect(a, b);
          return out || null;
        } catch (e) {
          console.warn("[merge] intersect fail", e);
          return null;
        }
      }

      function mergeFeaturesWithSnap(features, snapMeters) {
        if (!features.length) return null;

        const leftovers = [];
        let merged = null;

        for (const raw of features) {
          const f0 = stabilizeFeature(raw);
          const fb = stabilizeFeature(safeBuffer(f0, snapMeters));

          if (!merged) {
            merged = fb;
            continue;
          }

          let u = safeUnion(merged, fb);

          if (!u) {
            const m2 = stabilizeFeature(merged);
            const f2 = stabilizeFeature(raw);
            u = safeUnion(m2, f2);
          }

          if (!u) {
            leftovers.push(fb);
            continue;
          }

          merged = stabilizeFeature(u);
        }

        if (leftovers.length) {
          try {
            const fc = turf.featureCollection([merged, ...leftovers].filter(Boolean));
            const combined = turf.combine(fc);
            if (combined?.features?.[0]) merged = combined.features[0];
          } catch (e) {
            console.warn("[merge] combine fail", e);
          }
        }

        return merged;
      }

      function getSelectedFeatures(){
        const feats = [];
        for (const z of state.selectedZips) {
          const f = state.geoByZip.get(z);
          if (f) feats.push(f);
        }
        return feats;
      }

      // ====== ✅ 핵심: 홀(구멍) 유지하면서 rings[]를 "소수 개"로 ======

      function closestVertexPair(ringA, ringB){
        // ringA/B: [[lng,lat]...]
        let best = null;
        let bestD = Infinity;

        const aLen = ringA?.length || 0;
        const bLen = ringB?.length || 0;
        if (aLen < 2 || bLen < 2) return null;

        for (let i = 0; i < aLen; i++) {
          const a = ringA[i];
          if (!Array.isArray(a) || a.length < 2) continue;
          const ax = +a[0], ay = +a[1];
          if (!isFinite(ax) || !isFinite(ay)) continue;

          for (let j = 0; j < bLen; j++) {
            const b = ringB[j];
            if (!Array.isArray(b) || b.length < 2) continue;
            const bx = +b[0], by = +b[1];
            if (!isFinite(bx) || !isFinite(by)) continue;

            const dx = ax - bx, dy = ay - by;
            const d2 = dx*dx + dy*dy;
            if (d2 < bestD) {
              bestD = d2;
              best = { a:[ax,ay], b:[bx,by] };
            }
          }
        }
        return best;
      }

      function pointInPolyStrict(pt, poly){
        try {
          return turf.booleanPointInPolygon(pt, poly, { ignoreBoundary: true });
        } catch {
          return false;
        }
      }

      // polygonize 결과에서 "큰 outer(구멍 포함)" 같은 잘못된 면 제거:
      // - 원본(polyFeature) 내부에 있어야 함
      // - 그리고 hole 내부 점을 포함하면 탈락 (구멍을 덮는 면)
      function polygonizePiecesForDonut(polyFeature, outer, holes){
        if (typeof turf.polygonize !== "function") return null;
        if (!outer || outer.length < 4 || !holes?.length) return null;

        try {
          const lines = [];
          lines.push(turf.lineString(outer));
          holes.forEach(h => lines.push(turf.lineString(h)));

          // hole 내부를 찍는 점(각 hole당 1개)
          const holePts = holes.map(h => turf.pointOnFeature(turf.polygon([h])));

          // hole마다 outer와 가장 가까운 vertex-vertex로 bridge 1개
          holes.forEach(h => {
            const pair = closestVertexPair(h, outer);
            if (!pair) return;
            lines.push(turf.lineString([pair.a, pair.b]));
          });

          const fc = turf.featureCollection(lines);
          const polyFC = turf.polygonize(fc);

          const out = [];

          for (const cand of (polyFC?.features || [])) {
            if (!cand?.geometry || cand.geometry.type !== "Polygon") continue;

            // 면 안에 찍히는 점
            const pOn = turf.pointOnFeature(cand);

            // 1) 원본 donut 영역 안쪽이어야 함
            if (!pointInPolyStrict(pOn, polyFeature)) continue;

            // 2) hole 내부 점을 포함하면(= hole을 덮는 면) 탈락
            let coversHole = false;
            for (const hp of holePts) {
              if (pointInPolyStrict(hp, cand)) { coversHole = true; break; }
            }
            if (coversHole) continue;

            // 3) 너무 작은 찌꺼기 제거
            const a = turf.area(cand);
            if (isFinite(a) && a < MIN_COMPONENT_AREA_SQM) continue;

            const r = cand.geometry.coordinates?.[0];
            if (Array.isArray(r) && r.length >= 4) {
              closeRingLngLat(r);
              out.push(r);
            }
          }

          // 보통 2개 정도로 끝남 (깔끔)
          return out.length ? out : null;
        } catch (e) {
          console.warn("[merge] polygonizePiecesForDonut failed", e);
          return null;
        }
      }

      function splitPolygonToPayloadRings(polyFeature){
        const coords = polyFeature?.geometry?.coordinates;
        if (!Array.isArray(coords) || !coords.length) return { payloadRings: [], outlineRings: [] };

        const outer = coords[0];
        const holes = coords.slice(1).filter(r => Array.isArray(r) && r.length >= 4);

        const outlineRings = [];
        if (Array.isArray(outer) && outer.length >= 4) outlineRings.push(outer);
        holes.forEach(h => outlineRings.push(h));

        // hole 없으면 그냥 outer 1개
        if (!holes.length) return { payloadRings: [outer], outlineRings };

        // ✅ 핵심: polygonize+bridge로 hole 없는 "소수 조각"으로 분해
        const pieces = polygonizePiecesForDonut(polyFeature, outer, holes);
        if (pieces && pieces.length) return { payloadRings: pieces, outlineRings };

        // 만약 polygonize가 죽는 환경이면(드묾) fallback은 outer로(최소한 포맷은 유지)
        // (여기서 fallback을 tesselate로 가면 다시 조각지옥이라 일부러 안 감)
        console.warn("[merge] polygonize not available or failed -> fallback outer (hole may fill)");
        return { payloadRings: [outer], outlineRings };
      }

      // ✅ 저장/표시 공통 계산
      async function computeMergedRings(){
        await drawSelected();

        const feats = getSelectedFeatures().map(stabilizeFeature).filter(Boolean);
        if (!feats.length) return null;

        const mergedSnap = mergeFeaturesWithSnap(feats, MERGE_SNAP_METERS);
        if (!mergedSnap) return null;

        // 원본 면적 마스크(확장 없음)
        let origMask = null;
        try {
          const fc = turf.featureCollection(feats);
          const comb = turf.combine(fc);
          origMask = comb?.features?.[0] || null;
        } catch (e) {
          console.warn("[merge] orig mask fail", e);
        }

        // 스냅으로 늘어난 부분을 원본 면적으로 클립
        const mergedClipped =
          (origMask ? safeIntersect(mergedSnap, origMask) : null) || origMask || mergedSnap;

        let polys = flattenToPolygonFeatures(mergedClipped);
        polys = polys.filter(p => { try { return turf.area(p) >= MIN_COMPONENT_AREA_SQM; } catch { return true; }});

        const payloadRings = [];
        const outlineRings = [];

        for (const p of polys) {
          const stabilized = stabilizeFeature(p);

          const { payloadRings: pr, outlineRings: or } = splitPolygonToPayloadRings(stabilized);
          pr.forEach(r => { if (Array.isArray(r) && r.length >= 4) payloadRings.push(r); });
          or.forEach(r => { if (Array.isArray(r) && r.length >= 4) outlineRings.push(r); });
        }

        if (!payloadRings.length) return null;

        return {
          payloadRings,
          outlineRings: outlineRings.length ? outlineRings : payloadRings
        };
      }

      async function mergeOn(rebuildOnly=false){
        try {
          const res = await computeMergedRings();
          if (!res) { if(!rebuildOnly) alert("병합 결과가 없습니다."); return; }

          const { payloadRings, outlineRings } = res;

          clearMerged();
          state.mergedRingsWgs84 = payloadRings;        // ✅ 저장용(기존 포맷)
          state.mergedOutlineRingsWgs84 = outlineRings; // ✅ 표시용

          const mergedColor = darkenHex(pickColor("merged"), 0.18);

          // 1) fill (stroke 숨김) -> 조각 seam 안 보이게
          for (const ring of payloadRings) {
            const latlngs = ring.map(([lng,lat]) => new kakao.maps.LatLng(lat, lng));
            if (latlngs.length > 1) {
              const f = latlngs[0], l = latlngs[latlngs.length - 1];
              if (f.getLat() === l.getLat() && f.getLng() === l.getLng()) latlngs.pop();
            }
            if (latlngs.length < 3) continue;

            const polyFill = new kakao.maps.Polygon({
              map: state.map,
              path: latlngs,
              strokeWeight: 1,
              strokeOpacity: 0,
              strokeColor: mergedColor,
              fillColor: mergedColor,
              fillOpacity: 0.20
            });
            state.mergedPolygons.push(polyFill);
          }

          // 2) 외곽/홀 경계 Polyline
          for (const ring of outlineRings) {
            const latlngs = ring.map(([lng,lat]) => new kakao.maps.LatLng(lat, lng));
            if (latlngs.length > 1) {
              const f = latlngs[0], l = latlngs[latlngs.length - 1];
              if (f.getLat() === l.getLat() && f.getLng() === l.getLng()) latlngs.pop();
            }
            if (latlngs.length < 2) continue;

            const line = new kakao.maps.Polyline({
              map: state.map,
              path: latlngs,
              strokeWeight: 6,
              strokeColor: mergedColor,
              strokeOpacity: 1,
              strokeStyle: "solid"
            });
            state.mergedPolygons.push(line);
          }

          setOriginalVisible(false);
          setMergeUI(true);
          fitBoundsToRings(outlineRings);
        } catch (e) {
          console.warn("[merge] mergeOn crashed:", e);
          clearMerged();
          setOriginalVisible(true);
          setMergeUI(false);
          if (!rebuildOnly) alert("병합 실패(지오메트리 오류).");
        }
      }

      function mergeOff(){
        clearMerged();
        setOriginalVisible(true);
        setMergeUI(false);
        fitBoundsAllOriginal();
      }

      async function toggleMerge(){
        if (state.mergeMode) mergeOff();
        else await mergeOn(false);
      }

      // ===== 저장 =====
      function openSaveModal(){
        $("#saveCampInput").value = localStorage.getItem("mw_save_camp") || "";
        $("#saveCodeInput").value = localStorage.getItem("mw_save_code") || "";
        $("#saveModal").classList.add("open");
        $("#saveModal").setAttribute("aria-hidden","false");
        setTimeout(() => { $("#saveCampInput").focus(); }, 0);
      }

      function closeSaveModal(){
        $("#saveBtn")?.focus?.();
        $("#saveModal").classList.remove("open");
        $("#saveModal").setAttribute("aria-hidden","true");
      }

      async function saveMergedToDB(){
        const camp = ($("#saveCampInput").value || "").trim();
        const code = ($("#saveCodeInput").value || "").trim();
        if (!camp) return alert("camp를 입력하세요");
        if (!code) return alert("code(라우트 코드)를 입력하세요");

        let rings = state.mergedRingsWgs84;

        if (!rings || !rings.length) {
          const res = await computeMergedRings();
          rings = res?.payloadRings || null;
        }

        if (!rings || !rings.length) {
          alert("저장할 병합 결과가 없습니다.");
          return;
        }

        // ✅ 기존 저장 형식 그대로: rings[]
        const payload = { camp, code, polygon_wgs84: rings };

        const res = await fetch(ROUTE_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify(payload)
        });

        const text = await res.text();
        let j = null;
        try { j = text ? JSON.parse(text) : null; } catch {}

        if (!res.ok) {
          const msg = j?.error || j?.message || text || `HTTP ${res.status}`;
          alert("저장 실패: " + msg);
          return;
        }

        localStorage.setItem("mw_save_camp", camp);
        localStorage.setItem("mw_save_code", code);

        closeSaveModal();
        alert("저장 완료");
      }

      // ===== 초기화 =====
      function clearAll(){
        for (const arr of state.polygons.values()) arr.forEach(p => p.setMap(null));
        for (const arr of state.labels.values())   arr.forEach(l => l.setMap(null));
        state.polygons.clear();
        state.labels.clear();
        state.geoByZip.clear();

        clearMerged();
        setMergeUI(false);

        state.selectedZips.clear();
        renderZipChips();

        setRoadviewOn(false);
      }

      // ===== 바인딩 =====
      function bindUI(){
        $("#addBtn").onclick = async () => {
          parseZips($("#zipInput").value).forEach(z => state.selectedZips.add(z));
          $("#zipInput").value = "";
          renderZipChips();
          if (state.mergeMode) await mergeOn(true);
        };

        $("#searchBtn").onclick = async () => {
          await drawSelected();
          if (state.mergeMode) await mergeOn(true);
          else fitBoundsAllOriginal();
        };

        $("#mergeBtn").onclick = async () => { await toggleMerge(); };

        $("#saveBtn").onclick = openSaveModal;
        $("#clearBtn").onclick = clearAll;

        $("#toggleMapType").onclick = () => setMapTypeSatellite(!state.isSatellite);
        $("#toggleRoadview").onclick = () => setRoadviewOn(!state.roadviewOn);

        $("#openAddr").onclick = () => {
          new daum.Postcode({
            oncomplete: (d) => {
              if (d.zonecode) {
                state.selectedZips.add(d.zonecode);
                renderZipChips();
              }
            }
          }).open();
        };

        $("#saveLink").onclick = (e) => { e.preventDefault(); openSaveModal(); };

        $("#saveCloseBtn").onclick = closeSaveModal;
        $("#saveDoBtn").onclick = saveMergedToDB;

        const preset = parseZips(new URLSearchParams(location.search).get("zips"));
        preset.forEach(z => state.selectedZips.add(z));
        renderZipChips();
        if (preset.length) {
          drawSelected().then(() => fitBoundsAllOriginal());
        }

        setMergeUI(false);
      }

      document.addEventListener("DOMContentLoaded", () => {
        createMap();
        bindUI();
      });
    })();
  </script>
</body>
</html>
