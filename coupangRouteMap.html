<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ë§ˆë£¨ì›° ë¼ìš°íŠ¸ í¸ì§‘ê¸°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico?v=2" />

  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a2d;
      --panel2:#0c1627;
      --txt:#e6eefc;
      --muted:#93a4c7;
      --line:rgba(255,255,255,.08);
      --btn:#162744;
      --btn2:#1a2f55;
      --danger:#6b1b1b;
      --ok:#1a5a3a;
      --warn:#6a4b13;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; background:#0a0f1a;}
    .wrap{display:flex; height:100%;}
    .left{
      width:360px; min-width:340px; max-width:420px;
      background:linear-gradient(180deg,var(--bg),#070b13);
      color:var(--txt);
      border-right:1px solid var(--line);
      padding:14px 14px 10px 14px;
      overflow:auto;
    }
    .title{font-size:18px; font-weight:800; letter-spacing:.2px; margin:2px 0 10px; display:flex; align-items:center; gap:6px;}
    .subtitle{font-size:12px; color:var(--muted); margin:-6px 0 14px;}
    .group{background:rgba(255,255,255,.03); border:1px solid var(--line); border-radius:12px; padding:10px; margin:10px 0;}
    .label{font-size:12px; color:var(--muted); margin:6px 0 6px;}
    input[type="text"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
    }
    input[type="text"]:focus{border-color:rgba(255,255,255,.25)}
    .row{display:flex; gap:8px; align-items:center;}
    .row > *{flex:1}
    .btn{
      padding:10px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:var(--btn);
      color:var(--txt);
      cursor:pointer;
      font-weight:700;
      font-size:13px;
      white-space:nowrap;
    }
    .btn:hover{background:var(--btn2)}
    .btn.danger{background:rgba(107,27,27,.35); border-color:rgba(255,60,60,.22)}
    .btn.danger:hover{background:rgba(107,27,27,.55)}
    .btn.ok{background:rgba(26,90,58,.35); border-color:rgba(0,255,140,.18)}
    .btn.ok:hover{background:rgba(26,90,58,.55)}
    .btn.warn{background:rgba(106,75,19,.35); border-color:rgba(255,180,0,.18)}
    .btn.warn:hover{background:rgba(106,75,19,.55)}
    .help{font-size:12px; color:var(--muted); line-height:1.5; margin-top:8px;}
    .logWrap{
      border-radius:12px;
      border:1px solid var(--line);
      overflow:hidden;
      background:rgba(0,0,0,.25);
      margin-top:10px;
    }
    .logHeader{
      padding:8px 10px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between;
      font-size:12px; color:var(--muted);
    }
    .log{
      height:170px;
      overflow:auto;
      padding:8px 10px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      white-space:pre-wrap;
      color:#d9e5ff;
    }
    .pill{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      font-size:12px;
      color:var(--muted);
    }

    .map{flex:1; position:relative;}
    #mapWrap{
      position:absolute;
      inset:0;
      display:flex;
      min-width:0;
      min-height:0;
    }
    #map,#roadview{
      flex:1;
      width:100%;
      height:100%;
      min-width:0;
      min-height:0;
    }
    #roadview{display:none}
    #mapWrap.roadview-open #roadview{display:block}

    .floatingHint{
      position:absolute;
      top:10px; left:10px;
      background:rgba(0,0,0,.55);
      color:#fff;
      border:1px solid rgba(255,255,255,.14);
      border-radius:10px;
      padding:8px 10px;
      font-size:12px;
      max-width:520px;
      display:none;
      z-index:20;
    }

    .map-controls{
      position:absolute;
      top:10px;
      right:10px;
      z-index:30;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .map-controls button{
      background:rgba(11,18,32,0.78);
      border:1px solid rgba(255,255,255,.14);
      color:#e6eefc;
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-weight:800;
      font-size:12px;
      backdrop-filter: blur(6px);
    }
    .map-controls button:hover{
      background:rgba(15,26,45,0.86);
      border-color:rgba(255,255,255,.22);
    }
    .map-controls .hint{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,0.55);
      color:#cbd5e1;
      font-size:12px;
    }

    .sep{height:1px; background:var(--line); margin:10px 0;}
    .small{font-size:11px; color:var(--muted);}

    /* ====== ì£¼ì†Œê²€ìƒ‰ ëª¨ë‹¬ ====== */
    .modalBack{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:9999;
      padding:16px;
    }
    .modalCard{
      width:640px;
      max-width:96vw;
      height:70vh;
      max-height:84vh;
      background:linear-gradient(180deg, rgba(15,26,45,.98), rgba(11,18,32,.98));
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      box-shadow:0 18px 70px rgba(0,0,0,.55);
    }
    .modalHeader{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex;
      gap:8px;
      align-items:center;
    }
    .modalHeader input{
      flex:1;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.22);
      color:var(--txt);
      outline:none;
      font-size:14px;
    }
    .modalHeader input:focus{border-color:rgba(255,255,255,.25)}
    .modalBody{
      padding:10px;
      overflow:auto;
      flex:1;
    }
    .resultItem{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:12px;
      padding:10px 12px;
      margin-bottom:8px;
      cursor:pointer;
    }
    .resultItem:hover{
      border-color:rgba(0,194,255,.35);
      background:rgba(0,194,255,.06);
    }
    .resultTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .resultName{
      font-weight:900;
      color:#ffffff;
      font-size:14px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .resultMeta{
      font-size:12px;
      color:var(--muted);
      margin-top:4px;
      line-height:1.4;
    }
    .resultTag{
      display:inline-flex;
      align-items:center;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.22);
      color:#cbd5e1;
      font-weight:800;
      font-size:11px;
      white-space:nowrap;
    }
    .modalFooter{
      padding:10px 12px;
      border-top:1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color:var(--muted);
      font-size:12px;
    }
    .pager{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .pager button{
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.12);
      color:var(--txt);
      padding:6px 10px;
      border-radius:999px;
      cursor:pointer;
      font-weight:900;
      font-size:12px;
    }
    .pager button:hover{
      border-color:rgba(255,255,255,.22);
    }

    @media (max-width: 900px){
      #mapWrap.roadview-open{
        flex-direction:column;
      }
      .modalCard{
        height:78vh;
      }
    }
  </style>

  <!-- Kakao Maps (Drawing ë¼ì´ë¸ŒëŸ¬ë¦¬ ì œê±°: a.e is not a function ê·¼ì› ì°¨ë‹¨) -->
  <!-- ë³¸ì¸ ì•±í‚¤ë¡œ êµì²´ -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3&autoload=false&libraries=services"></script>
</head>

<body>
<div class="wrap">
  <div class="left">
    <div class="title">
      <a href="/index.html" style="display:flex;align-items:center">
        <img src="/favicon.ico" alt="Maroowell Logo" style="width:24px;height:24px;transform:translateY(-2px);cursor:pointer" />
      </a>
      <span>ë§ˆë£¨ì›° ë¼ìš°íŠ¸ í¸ì§‘ê¸°</span>
    </div>

    <div class="group">
      <div class="label">ìº í”„ ì´ë¦„ (ì˜ˆ: í‰ì–‘1)</div>
      <input id="campInput" type="text" value="" />

      <div class="label">ë¼ìš°íŠ¸ ì½”ë“œ (ì˜ˆ: 101A,101B) â€” ë¹„ìš°ë©´ camp ì „ì²´ í‘œì‹œ</div>
      <input id="codeInput" type="text" value="" />

      <div class="sep"></div>

      <div class="label">ë²¤ë” ì •ë³´(ì„œë¸Œë¼ìš°íŠ¸ ë‹¨ìœ„)</div>
      <input id="vendorNameInput" type="text" placeholder="ë²¤ë” ì´ë¦„" />
      <div style="height:8px"></div>
      <input id="vendorBizInput" type="text" placeholder="ì‚¬ì—…ìë²ˆí˜¸ (ì˜ˆ: 123-45-67890)" />

      <div style="height:10px"></div>
      <div class="row">
        <button id="vendorSaveBtn" class="btn ok">ë²¤ë” ì €ì¥</button>
        <button id="vendorClearBtn" class="btn danger">ë²¤ë” ë¹„ìš°ê¸°</button>
      </div>

      <div class="help">
        - ì„ íƒëœ ë¼ìš°íŠ¸ì˜ ë²¤ë” ì •ë³´ë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
      </div>

      <div class="sep"></div>

      <div class="label">ì…ì°¨ì§€ ì •ë³´(ì„œë¸Œë¼ìš°íŠ¸ ë‹¨ìœ„)</div>
      <input id="deliveryNameInput" type="text" placeholder="ì…ì°¨ì§€ (ì˜ˆ: ë³¸ìº í”„ or ì‹ì‚¬ë™MB)" />
      <div style="height:8px"></div>
      <input id="deliveryAddrInput" type="text" placeholder="ì…ì°¨ì§€ ì£¼ì†Œ (ìƒì„¸íˆ)" />

      <div style="height:10px"></div>
      <div class="row">
        <button id="deliveryNaviBtn" class="btn warn">ì¹´ì¹´ì˜¤ë‚´ë¹„</button>
        <button id="deliverySaveBtn" class="btn ok">ì…ì°¨ì§€ ì €ì¥</button>
        <button id="deliveryClearBtn" class="btn danger">ì…ì°¨ì§€ ë¹„ìš°ê¸°</button>
      </div>

      <div class="help">
        - ì¹´ì¹´ì˜¤ë‚´ë¹„: ì…ë ¥í•œ ì£¼ì†Œë¡œ ì¹´ì¹´ì˜¤ë§µ/ë‚´ë¹„ ì‹¤í–‰<br/>
        - ì„ íƒëœ ë¼ìš°íŠ¸ì˜ ì…ì°¨ì§€ ì •ë³´ë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
      </div>
    </div>

    <div class="group" id="addressListGroup" style="display:none">
      <div class="label">ë°°ì†¡ì§€ ëª©ë¡ (ì…ì°¨ì§€â†’ë°°ì†¡ì§€ ë„¤ë¹„)</div>
      <div id="addressList" style="max-height:300px; overflow-y:auto; margin-top:8px;"></div>
      <div class="help small" style="margin-top:8px;">
        ê° ë°°ì†¡ì§€ë¡œ ê°€ëŠ” ê²½ë¡œë¥¼ ì¹´ì¹´ì˜¤ë‚´ë¹„ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
      </div>
    </div>

    <div class="group">
      <div class="row">
        <button id="loadBtn" class="btn">ë¶ˆëŸ¬ì˜¤ê¸°</button>
        <button id="drawNewBtn" class="btn warn">ìƒˆë¡œ ê·¸ë¦¬ê¸°</button>
        <button id="drawAddBtn" class="btn warn">êµ¬ì—­ ì¶”ê°€</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="saveBtn" class="btn ok">ì €ì¥</button>
        <button id="deletePolyBtn" class="btn danger">í´ë¦¬ê³¤ ì‚­ì œ</button>
        <button id="alignBtn" class="btn">ì§€ë„ ì •ë ¬</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="addrBtn" class="btn">ì£¼ì†Œê²€ìƒ‰</button>
        <button id="labelToggleBtn" class="btn">ë¼ìš°íŠ¸ ë¼ë²¨ ON</button>
        <button id="resetBtn" class="btn">ì§€ë„ ì´ˆê¸°í™”</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="shareBtn" class="btn ok" style="width:100%;">ğŸ”— ê³µìœ  ë§í¬ ìƒì„±</button>
      </div>

      <div class="help">
        - í¸ì§‘: í´ë¦¬ê³¤ í´ë¦­ â†’ ê¼­ì§“ì  ë“œë˜ê·¸ë¡œ ìˆ˜ì •, ìš°í´ë¦­ìœ¼ë¡œ ì  ì‚­ì œ<br/>
        - ìƒˆë¡œ ê·¸ë¦¬ê¸°: Enterë¡œ ì™„ë£Œ, ìš°í´ë¦­ìœ¼ë¡œ ì·¨ì†Œ, ESCë¡œ ë‚˜ê°€ê¸°<br/>
        - êµ¬ì—­ ì¶”ê°€: ê°™ì€ ì½”ë“œì— í´ë¦¬ê³¤ ì¶”ê°€ (ë‹¤êµ¬ì—­ ì§€ì›)<br/>
        - ì§€ë„ ì •ë ¬: OSM ë„ë¡œ/ê±´ë¬¼ ì˜¤ë²„ë ˆì´ í‘œì‹œ<br/>
        - <strong>ê³µìœ  ë§í¬</strong>: ë‹¤ë¥¸ ì‚¬ëŒì—ê²Œ ë³´ë‚¼ ìˆ˜ ìˆëŠ” ì½ê¸° ì „ìš© ì§€ë„ ë§í¬ ìƒì„±
      </div>
    </div>

    <div class="logWrap">
      <div class="logHeader">
        <span class="pill" id="statusPill">READY</span>
        <span class="small" id="selectedInfo">ì„ íƒ: ì—†ìŒ</span>
      </div>
      <div class="log" id="log"></div>
    </div>

    <div class="help small" style="margin-top:10px;">
      ğŸ’¡ íŒ: ì¤‘ê°„ ì (íšŒìƒ‰)ì„ í´ë¦­í•˜ë©´ ìƒˆ ê¼­ì§“ì  ì¶”ê°€, ê¼­ì§“ì  ìš°í´ë¦­ìœ¼ë¡œ ì‚­ì œ
    </div>
  </div>

  <div class="map">
    <div id="mapWrap">
      <div id="map"></div>
      <div id="roadview"></div>

      <div class="map-controls">
        <button id="toggleMapType" title="ì¼ë°˜/ìœ„ì„± ì „í™˜">ìœ„ì„±</button>
        <button id="toggleRoadview" title="ë¡œë“œë·° ë³´ê¸°/ì¢…ë£Œ">ë¡œë“œë·°</button>
        <span id="roadviewHint" class="hint" style="display:none">ë¡œë“œë·°: íŒŒë€ ê¸¸(ROADVIEW) í´ë¦­</span>
      </div>

      <div class="floatingHint" id="hint"></div>
    </div>
  </div>
</div>

<!-- ì£¼ì†Œê²€ìƒ‰ ëª¨ë‹¬ -->
<div class="modalBack" id="searchModal">
  <div class="modalCard">
    <div class="modalHeader">
      <input id="searchQueryInput" type="text" placeholder="ì£¼ì†Œ / ì¥ì†Œ / í‚¤ì›Œë“œ (ì˜ˆ: ì„œìš¸ëŒ€ì…êµ¬ì—­, ì˜ë“±í¬ íƒ€ì„ìŠ¤í€˜ì–´, 123-45, ì‹ ë„ë¦¼)" />
      <button id="searchDoBtn" class="btn">ê²€ìƒ‰</button>
      <button id="searchCloseBtn" class="btn danger">ë‹«ê¸°</button>
    </div>
    <div class="modalBody">
      <div class="small" style="margin-bottom:10px; color:var(--muted);">
        - ì¹´ì¹´ì˜¤ì§€ë„ ê²€ìƒ‰ì²˜ëŸ¼: í‚¤ì›Œë“œ ê²€ìƒ‰ ê²°ê³¼ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œì‹œí•©ë‹ˆë‹¤. ê²°ê³¼ê°€ ì—†ìœ¼ë©´ ì£¼ì†Œê²€ìƒ‰ìœ¼ë¡œ í•œ ë²ˆ ë” ì‹œë„í•©ë‹ˆë‹¤.<br/>
        - í•­ëª© í´ë¦­ ì‹œ ì§€ë„ ì´ë™/ë§ˆì»¤ í‘œì‹œ í›„ ìë™ ë‹«í˜
      </div>
      <div id="searchResults"></div>
    </div>
    <div class="modalFooter">
      <div>Enter: ê²€ìƒ‰ Â· ESC: ë‹«ê¸°</div>
      <div class="pager" id="searchPager" style="display:none"></div>
    </div>
  </div>
</div>

<script>
(() => {
  // ====== í™˜ê²½ ì„¤ì • ======
  const API_BASE = "https://route.maroowell.com"; // í•„ìš”ì‹œ ë³€ê²½
  const ROUTE_ENDPOINT = `${API_BASE}/route`;
  const OSM_ENDPOINT = `${API_BASE}/osm`;
  const ADDRESS_ENDPOINT = `${API_BASE}/addresses`;

  // ====== DOM ======
  const $ = (id) => document.getElementById(id);
  const campInput = $("campInput");
  const codeInput = $("codeInput");
  const vendorNameInput = $("vendorNameInput");
  const vendorBizInput = $("vendorBizInput");
  const deliveryNameInput = $("deliveryNameInput");
  const deliveryAddrInput = $("deliveryAddrInput");

  const loadBtn = $("loadBtn");
  const drawNewBtn = $("drawNewBtn");
  const drawAddBtn = $("drawAddBtn");
  const addrBtn = $("addrBtn");
  const saveBtn = $("saveBtn");
  const deletePolyBtn = $("deletePolyBtn");
  const alignBtn = $("alignBtn");
  const labelToggleBtn = $("labelToggleBtn");
  const resetBtn = $("resetBtn");
  const vendorSaveBtn = $("vendorSaveBtn");
  const vendorClearBtn = $("vendorClearBtn");
  const deliveryNaviBtn = $("deliveryNaviBtn");
  const deliverySaveBtn = $("deliverySaveBtn");
  const deliveryClearBtn = $("deliveryClearBtn");
  const shareBtn = $("shareBtn");

  const logEl = $("log");
  const statusPill = $("statusPill");
  const selectedInfo = $("selectedInfo");
  const hintEl = $("hint");

  // ì§€ë„ ì»¨íŠ¸ë¡¤
  const toggleMapTypeBtn = $("toggleMapType");
  const toggleRoadviewBtn = $("toggleRoadview");
  const roadviewHintEl = $("roadviewHint");
  const mapWrapEl = $("mapWrap");

  // ê²€ìƒ‰ ëª¨ë‹¬
  const searchModalEl = $("searchModal");
  const searchQueryInput = $("searchQueryInput");
  const searchDoBtn = $("searchDoBtn");
  const searchCloseBtn = $("searchCloseBtn");
  const searchResultsEl = $("searchResults");
  const searchPagerEl = $("searchPager");

  // ====== ë¡œê·¸ ======
  const ts = () => {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    const ss = String(d.getSeconds()).padStart(2,"0");
    return `[${hh}:${mm}:${ss}]`;
  };
  function setStatus(t, kind="READY") {
    statusPill.textContent = kind;
    statusPill.style.borderColor =
      kind === "ERR" ? "rgba(255,60,60,.35)" :
      kind === "WARN" ? "rgba(255,180,0,.30)" :
      kind === "OK" ? "rgba(0,255,140,.22)" :
      "rgba(255,255,255,.10)";
    statusPill.style.background =
      kind === "ERR" ? "rgba(255,60,60,.12)" :
      kind === "WARN" ? "rgba(255,180,0,.10)" :
      kind === "OK" ? "rgba(0,255,140,.08)" :
      "rgba(255,255,255,.04)";
    if (t) log(`${kind} ${t}`);
  }
  function log(msg) {
    logEl.textContent += `${ts()} ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function hint(msg, show=true) {
    hintEl.textContent = msg;
    hintEl.style.display = show ? "block" : "none";
  }

  // ====== ìƒíƒœ ======
  let map, geocoder, places;

  /** @type {Array<any>} */
  let routeRows = []; // APIì—ì„œ ë°›ì€ rowë“¤
  let addressRows = []; // ë°°ì†¡ì§€ ëª©ë¡

  /**
   * rowId -> { row, polygons: kakao.maps.Polygon[], labels: kakao.maps.CustomOverlay[] }
   */
  const overlayById = new Map();

  // í¸ì§‘(ë²„í…ìŠ¤ í•¸ë“¤) ìƒíƒœ
  let selectedRouteId = null;
  let editHandles = []; // kakao.maps.Marker[]
  let editPolygons = []; // kakao.maps.Polygon[]
  let labelOn = true;

  // âœ… (ì¶”ê°€) í´ë¦¬ê³¤ ê°œë³„ ì‚­ì œ X ì˜¤ë²„ë ˆì´
  let deleteOverlays = []; // kakao.maps.CustomOverlay[]

  // ì»¤ìŠ¤í…€ ë“œë˜ê·¸ ìƒíƒœ
  let draggingVertex = null; // { marker, polygon, index }

  // ê·¸ë¦¬ê¸° ìƒíƒœ
  let drawMode = null; // "new" | "add" | null
  let drawPoints = []; // kakao.maps.LatLng[]
  let drawMarkers = []; // kakao.maps.Marker[]
  let drawLine = null; // kakao.maps.Polyline

  // OSM ì˜¤ë²„ë ˆì´
  let osmOverlays = [];

  // ====== (ì¶”ê°€) ìœ„ì„± / ë¡œë“œë·° ìƒíƒœ ======
  let isSatellite = false;
  let roadviewOn = false;      // ê¸¸ ì„ íƒ í¬í•¨ ëª¨ë“œ
  let roadviewOpen = false;    // ì‹¤ì œ ë¡œë“œë·° í™”ë©´ open ì—¬ë¶€
  let roadview = null;
  let roadviewClient = null;
  let roadviewClickHandler = null;

  // ====== (ì¶”ê°€) ì£¼ì†Œê²€ìƒ‰ ëª¨ë‹¬ ìƒíƒœ ======
  let searchModalOpen = false;
  let searchMarker = null;
  let searchInfo = null;
  let lastPagination = null;

  // ====== ì»¬ëŸ¬ íŒ”ë ˆíŠ¸(ì¸ì ‘ ìƒ‰ êµ¬ë¶„ ê°•í™”) ======
  const COLOR_PALETTE = [
    "#00C2FF", "#FF4D6D", "#FFD166", "#06D6A0", "#A78BFA",
    "#F97316", "#22C55E", "#E11D48", "#3B82F6", "#F59E0B",
    "#14B8A6", "#8B5CF6", "#84CC16", "#EC4899", "#0EA5E9",
    "#EF4444", "#10B981", "#FBBF24", "#6366F1", "#FB7185"
  ];
  function hashCode(str) {
    let h = 0;
    for (let i=0;i<str.length;i++){
      h = (h<<5) - h + str.charCodeAt(i);
      h |= 0;
    }
    return Math.abs(h);
  }
  function colorFor(code) {
    const idx = hashCode(code) % COLOR_PALETTE.length;
    return COLOR_PALETTE[idx];
  }

  // ====== API ======
  async function apiGet(url) {
    const res = await fetch(url, { method:"GET" });
    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}
    if (!res.ok) {
      const msg = json?.error || text || `HTTP ${res.status}`;
      throw new Error(msg);
    }
    return json;
  }
  async function apiJson(method, url, body) {
    const res = await fetch(url, {
      method,
      headers: { "Content-Type":"application/json" },
      body: body ? JSON.stringify(body) : undefined
    });
    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}
    if (!res.ok) {
      const msg = json?.error || text || `HTTP ${res.status}`;
      throw new Error(msg);
    }
    return json;
  }

  // ====== ìœ í‹¸: polygon_wgs84 íŒŒì‹± ======
  function parsePolygonWgs84(v, debugId = "") {
    if (!v) return null;
    if (Array.isArray(v)) return v;
    if (typeof v === "string") {
      try {
        const p = JSON.parse(v);
        if (Array.isArray(p)) return p;
      } catch (e) {
        if (debugId) log(`âš  í´ë¦¬ê³¤ íŒŒì‹± ì‹¤íŒ¨: ${debugId}`);
      }
    }
    return null;
  }

  // ====== ì§€ë„ ì˜¤ë²„ë ˆì´ ì •ë¦¬ ======
  function clearAllOverlays() {
    stopEditing();
    stopDraw(true);
    clearOsm();

    for (const {polygons, labels} of overlayById.values()) {
      polygons.forEach(p => p.setMap(null));
      labels.forEach(l => l.setMap(null));
    }
    overlayById.clear();
    routeRows = [];
    selectedRouteId = null;
    selectedInfo.textContent = "ì„ íƒ: ì—†ìŒ";
  }

  function clearOsm() {
    osmOverlays.forEach(o => o.setMap(null));
    osmOverlays = [];
  }

  // ====== ë¼ë²¨ ======
  function centroidOfLatLngs(latlngs) {
    let latSum=0, lngSum=0;
    for (const ll of latlngs) { latSum += ll.getLat(); lngSum += ll.getLng(); }
    return new kakao.maps.LatLng(latSum/latlngs.length, lngSum/latlngs.length);
  }
  function createLabelOverlay(text, position, color) {
    const el = document.createElement("div");
    el.style.padding = "4px 8px";
    el.style.borderRadius = "999px";
    el.style.background = "rgba(0,0,0,.55)";
    el.style.color = "#fff";
    el.style.fontSize = "12px";
    el.style.border = "1px solid rgba(255,255,255,.18)";
    el.style.whiteSpace = "nowrap";
    el.style.boxShadow = "0 2px 10px rgba(0,0,0,.35)";
    el.style.transform = "translateY(-2px)";
    el.innerHTML = `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color};margin-right:6px;vertical-align:middle;"></span>${escapeHtml(text)}`;

    return new kakao.maps.CustomOverlay({
      position,
      content: el,
      yAnchor: 1.0,
      zIndex: 10
    });
  }
  function escapeHtml(s) {
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ====== í´ë¦¬ê³¤ ìƒì„± ======
  function makePolygon(latlngs, strokeColor, fillColor, zIndex=1) {
    return new kakao.maps.Polygon({
      path: latlngs, // ë°˜ë“œì‹œ LatLng[]
      strokeWeight: 3,
      strokeColor,
      strokeOpacity: 1.0,
      strokeStyle: "solid",
      fillColor,
      fillOpacity: 0.15,
      zIndex
    });
  }

  // ====== (ì¶”ê°€) í´ë¦¬ê³¤ ê°œë³„ ì‚­ì œ X ì˜¤ë²„ë ˆì´ ìœ í‹¸ ======
  function clearDeleteOverlays() {
    deleteOverlays.forEach(o => o.setMap(null));
    deleteOverlays = [];
  }

  function getPolygonPathAsArray(polygon) {
    const rawPath = polygon.getPath();
    const out = [];
    if (!rawPath) return out;

    if (Array.isArray(rawPath)) {
      out.push(...rawPath);
      return out;
    }
    if (typeof rawPath.getLength === "function" && typeof rawPath.getAt === "function") {
      for (let i = 0; i < rawPath.getLength(); i++) out.push(rawPath.getAt(i));
      return out;
    }
    return out;
  }

  function createDeleteOverlayForPolygon(polygon) {
    const path = getPolygonPathAsArray(polygon);
    if (!path || path.length < 3) return null;

    const pos = centroidOfLatLngs(path);

    const btn = document.createElement("div");
    btn.textContent = "Ã—";
    btn.title = "ì´ êµ¬ì—­ë§Œ ì‚­ì œ";
    btn.style.width = "22px";
    btn.style.height = "22px";
    btn.style.display = "flex";
    btn.style.alignItems = "center";
    btn.style.justifyContent = "center";
    btn.style.borderRadius = "999px";
    btn.style.cursor = "pointer";
    btn.style.userSelect = "none";
    btn.style.background = "rgba(0,0,0,.72)";
    btn.style.color = "#fff";
    btn.style.border = "1px solid rgba(255,255,255,.22)";
    btn.style.boxShadow = "0 3px 12px rgba(0,0,0,.45)";
    btn.style.fontWeight = "900";
    btn.style.fontSize = "14px";
    btn.style.lineHeight = "1";

    btn.onmouseenter = () => {
      btn.style.background = "rgba(255,60,60,.75)";
      btn.style.borderColor = "rgba(255,60,60,.55)";
    };
    btn.onmouseleave = () => {
      btn.style.background = "rgba(0,0,0,.72)";
      btn.style.borderColor = "rgba(255,255,255,.22)";
    };

    btn.onclick = (e) => {
      if (e && typeof e.stopPropagation === "function") e.stopPropagation();
      deleteSinglePolygonOnly(polygon);
    };

    return new kakao.maps.CustomOverlay({
      position: pos,
      content: btn,
      xAnchor: 0.5,
      yAnchor: 0.5,
      zIndex: 30
    });
  }

  function rebuildDeleteOverlays() {
    clearDeleteOverlays();
    if (!selectedRouteId) return;
    if (!editPolygons || editPolygons.length === 0) return;

    for (const p of editPolygons) {
      const overlay = createDeleteOverlayForPolygon(p);
      if (!overlay) continue;
      overlay.setMap(map);
      deleteOverlays.push(overlay);
    }
  }

  function deleteSinglePolygonOnly(targetPolygon) {
    if (!selectedRouteId || !overlayById.has(selectedRouteId)) return;

    const pack = overlayById.get(selectedRouteId);
    if (!pack || !pack.polygons) return;

    targetPolygon.setMap(null);

    pack.polygons = pack.polygons.filter(p => p !== targetPolygon);
    editPolygons = editPolygons.filter(p => p !== targetPolygon);

    if (pack.polygons.length === 0) {
      updateSelectedLabels();
      stopEditing();
      setStatus("í•´ë‹¹ ë¼ìš°íŠ¸ì˜ êµ¬ì—­ì´ ëª¨ë‘ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤. ì €ì¥í•˜ë©´ ë°˜ì˜ë©ë‹ˆë‹¤.", "WARN");
      return;
    }

    updateSelectedLabels();
    rebuildHandles();
    setStatus("êµ¬ì—­ 1ê°œ ì œê±°(ë¡œì»¬). ì €ì¥ ë²„íŠ¼ì„ ëˆŒëŸ¬ ë°˜ì˜í•˜ì„¸ìš”.", "OK");
  }

  // ====== ë°ì´í„° í‘œì‹œ ======
  function renderRoutes(rows) {
    clearAllOverlays();
    routeRows = rows || [];

    if (!routeRows.length) {
      setStatus("í‘œì‹œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.", "WARN");
      return;
    }

    let bounds = new kakao.maps.LatLngBounds();
    let any = false;

    for (const row of routeRows) {
      const id = row.id;
      const code = row.full_code || row.code || row.route_code || "";
      const camp = row.camp || row.camp_name || "";
      const color = row.color || colorFor(code);
      const debugId = `${camp}/${code}(id=${id})`;

      const poly = parsePolygonWgs84(row.polygon_wgs84, debugId);

      const polygons = [];
      const labels = [];

      if (poly && Array.isArray(poly) && poly.length > 0) {
        let rings = [];

        const first = poly[0];
        if (first && typeof first === 'object' && 'lat' in first && 'lng' in first) {
          rings = [poly];
        } else if (Array.isArray(first)) {
          const firstOfFirst = first[0];
          if (firstOfFirst && typeof firstOfFirst === 'object' && 'lat' in firstOfFirst && 'lng' in firstOfFirst) {
            rings = poly;
          } else if (Array.isArray(firstOfFirst) && firstOfFirst.length >= 2) {
            rings = poly;
          } else if (typeof firstOfFirst === 'number') {
            rings = [poly];
          }
        }

        for (let i=0; i<rings.length; i++) {
          const ring = rings[i];
          if (!Array.isArray(ring) || ring.length < 3) continue;

          const latlngs = ring.map(pt => {
            if (pt && typeof pt === 'object' && 'lat' in pt && 'lng' in pt) {
              return new kakao.maps.LatLng(pt.lat, pt.lng);
            } else if (Array.isArray(pt) && pt.length >= 2) {
              return new kakao.maps.LatLng(pt[1], pt[0]);
            }
            return null;
          }).filter(ll => ll !== null);

          if (latlngs.length < 3) continue;
          const p = makePolygon(latlngs, color, color, 1);
          p.setMap(map);

          kakao.maps.event.addListener(p, "click", () => {
            if (!drawMode) startEditing(id);
          });

          polygons.push(p);
          any = true;
          latlngs.forEach(ll => bounds.extend(ll));

          if (labelOn) {
            const c = centroidOfLatLngs(latlngs);
            const label = createLabelOverlay(code, c, color);
            label.setMap(map);
            labels.push(label);
          }
        }
      }

      overlayById.set(id, { row, polygons, labels });
    }

    if (any) {
      map.setBounds(bounds);
      setStatus(`${routeRows.length}ê°œ ë¼ìš°íŠ¸ ë¡œë“œ ì™„ë£Œ`, "OK");
    } else {
      setStatus(`í´ë¦¬ê³¤ ë°ì´í„° ì—†ìŒ. ìƒˆë¡œ ê·¸ë¦¬ê¸°ë¡œ ìƒì„±í•˜ì„¸ìš”.`, "WARN");
    }
  }

  // ====== í¸ì§‘(ë²„í…ìŠ¤ í•¸ë“¤) ======
  let VERTEX_IMG = null;
  let MID_IMG = null;

  function makeHandleImage(fill="#ffffff", stroke="#111827") {
    const svg =
      `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12">
        <circle cx="6" cy="6" r="5" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
      </svg>`;
    const uri = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    return new kakao.maps.MarkerImage(uri, new kakao.maps.Size(12,12), { offset: new kakao.maps.Point(6,6) });
  }

  function stopEditing() {
    editHandles.forEach(m => m.setMap(null));
    editHandles = [];
    editPolygons = [];
    draggingVertex = null;
    map.setDraggable(true);

    clearDeleteOverlays();

    for (const {row, polygons} of overlayById.values()) {
      const base = row.color || colorFor(row.full_code || "");
      polygons.forEach(p => {
        p.setOptions({
          strokeColor: base,
          fillColor: base,
          strokeWeight: 6,
          fillOpacity: 0.15,
          zIndex: 1
        });
      });
    }
  }

  function startEditing(routeId) {
    if (!overlayById.has(routeId)) return;

    stopDraw(true);
    stopEditing();

    selectedRouteId = routeId;
    const pack = overlayById.get(routeId);
    const { row, polygons } = pack;

    const code = row.full_code || "";
    const camp = row.camp || "";
    selectedInfo.textContent = `ì„ íƒ: ${camp} / ${code} (id=${routeId})`;

    campInput.value = camp;
    codeInput.value = code;
    loadAddresses().catch(err => log(`ë°°ì†¡ì§€ ë¡œë“œ ì‹¤íŒ¨: ${err.message}`));

    vendorNameInput.value = row.vendor_name || "";
    vendorBizInput.value = row.vendor_business_number || "";

    deliveryNameInput.value = row.delivery_location_name || "";
    deliveryAddrInput.value = row.delivery_location_address || "";

    if (!polygons || polygons.length === 0) {
      setStatus(`ì„ íƒ ëŒ€ìƒ ${code}ëŠ” polygonì´ ì—†ìŠµë‹ˆë‹¤. "ìƒˆë¡œ ê·¸ë¦¬ê¸°"ë¡œ ìƒì„±í•˜ì„¸ìš”.`, "WARN");
      return;
    }

    polygons.forEach(p => {
      p.setOptions({ strokeWeight: 8, fillOpacity: 0.25, zIndex: 5 });
    });

    editPolygons = polygons.slice();

    rebuildHandles();
    setStatus(`í¸ì§‘ ëª¨ë“œ: ${code} (ê¼­ì§“ì  ë“œë˜ê·¸ë¡œ ìˆ˜ì •)`, "OK");
  }

  function rebuildHandles() {
    editHandles.forEach(m => m.setMap(null));
    editHandles = [];

    for (const polygon of editPolygons) {
      const rawPath = polygon.getPath();
      if (!rawPath) {
        log(`âš  rebuildHandles: polygon.getPath()ê°€ null`);
        continue;
      }

      const path = [];
      const len = Array.isArray(rawPath) ? rawPath.length : (rawPath.getLength ? rawPath.getLength() : 0);
      for (let i = 0; i < len; i++) {
        path.push(Array.isArray(rawPath) ? rawPath[i] : rawPath.getAt(i));
      }

      if (path.length < 3) continue;

      for (let i=0;i<path.length;i++) {
        ((index, polygon) => {
          const vMarker = new kakao.maps.Marker({
            position: path[index],
            image: VERTEX_IMG,
            clickable: true,
            zIndex: 20
          });

          vMarker.setMap(map);

          kakao.maps.event.addListener(vMarker, "mousedown", (e) => {
            draggingVertex = { marker: vMarker, polygon, index };
            map.setDraggable(false);

            if (e && e.domEvent) {
              e.domEvent.preventDefault();
              e.domEvent.stopPropagation();
            }
          });

          kakao.maps.event.addListener(vMarker, "rightclick", () => {
            const pth = polygon.getPath();
            const len = Array.isArray(pth) ? pth.length : (pth.getLength ? pth.getLength() : 0);
            if (len <= 3) {
              setStatus("ì  ì‚­ì œ ë¶ˆê°€: ìµœì†Œ 3ê°œ ê¼­ì§“ì  ìœ ì§€ í•„ìš”", "WARN");
              return;
            }
            const pathArray = [];
            for (let j = 0; j < len; j++) {
              if (j !== index) {
                pathArray.push(Array.isArray(pth) ? pth[j] : pth.getAt(j));
              }
            }
            polygon.setPath(pathArray);
            updateSelectedLabels();
            rebuildHandles();
          });

          editHandles.push(vMarker);
        })(i, polygon);
      }

      for (let i=0;i<path.length;i++) {
        ((index, polygon) => {
          const a = path[index];
          const b = path[(index+1)%path.length];

          const mid = new kakao.maps.LatLng(
            (a.getLat()+b.getLat())/2,
            (a.getLng()+b.getLng())/2
          );

          const midMarker = new kakao.maps.Marker({
            position: mid,
            clickable: true,
            image: MID_IMG,
            zIndex: 19
          });
          midMarker.setMap(map);

          kakao.maps.event.addListener(midMarker, "click", () => {
            const pth = polygon.getPath();
            const len = Array.isArray(pth) ? pth.length : (pth.getLength ? pth.getLength() : 0);
            const pathArray = [];
            for (let j = 0; j < len; j++) {
              pathArray.push(Array.isArray(pth) ? pth[j] : pth.getAt(j));
              if (j === index) {
                pathArray.push(mid);
              }
            }
            polygon.setPath(pathArray);
            updateSelectedLabels();
            rebuildHandles();
          });

          editHandles.push(midMarker);
        })(i, polygon);
      }
    }

    rebuildDeleteOverlays();
  }

  function updateSelectedLabels() {
    if (!selectedRouteId) return;
    const pack = overlayById.get(selectedRouteId);
    if (!pack) return;
    const { row, polygons, labels } = pack;
    if (!labelOn) return;

    labels.forEach(l => l.setMap(null));
    pack.labels = [];

    const code = row.full_code || "";
    const color = row.color || colorFor(code);

    for (const p of polygons) {
      const rawPath = p.getPath();
      const path = [];
      if (rawPath && typeof rawPath.getLength === 'function') {
        for (let i = 0; i < rawPath.getLength(); i++) {
          path.push(rawPath.getAt(i));
        }
      } else if (Array.isArray(rawPath)) {
        path.push(...rawPath);
      }

      if (path.length < 3) continue;
      const c = centroidOfLatLngs(path);
      const label = createLabelOverlay(code, c, color);
      label.setMap(map);
      pack.labels.push(label);
    }
  }

  // ====== ê·¸ë¦¬ê¸° ëª¨ë“œ ======
  function stopDraw(silent=false) {
    drawMode = null;
    drawPoints = [];
    drawMarkers.forEach(m => m.setMap(null));
    drawMarkers = [];
    if (drawLine) { drawLine.setMap(null); drawLine = null; }
    if (!silent) hint("", false);
  }

  function beginDraw(mode) {
    const camp = campInput.value.trim();
    const code = codeInput.value.trim();
    if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }
    if (!code) { setStatus("codeê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤. (ìƒˆë¡œ ê·¸ë¦¬ê¸°/êµ¬ì—­ ì¶”ê°€ëŠ” code í•„ìˆ˜)", "ERR"); return; }

    // ë¡œë“œë·°/ê²€ìƒ‰ ì¶©ëŒ ë°©ì§€
    setRoadviewOn(false);
    closeSearchModal(true);

    stopEditing();
    stopDraw(true);

    drawMode = mode; // new | add
    drawPoints = [];
    drawMarkers = [];

    if (drawLine) drawLine.setMap(null);
    drawLine = new kakao.maps.Polyline({
      path: [],
      strokeWeight: 3,
      strokeColor: "#00C2FF",
      strokeOpacity: 0.9,
      strokeStyle: "shortdash"
    });
    drawLine.setMap(map);

    hint("ê·¸ë¦¬ê¸° ëª¨ë“œ: ì§€ë„ í´ë¦­ìœ¼ë¡œ ì  ì¶”ê°€ Â· Enterí‚¤ë¡œ ì™„ë£Œ Â· ìš°í´ë¦­ìœ¼ë¡œ ë§ˆì§€ë§‰ ì  ì·¨ì†Œ Â· ESCë¡œ ì·¨ì†Œ", true);
    setStatus(mode === "new" ? "ìƒˆë¡œ ê·¸ë¦¬ê¸° ì‹œì‘" : "êµ¬ì—­ ì¶”ê°€ ì‹œì‘", "OK");
  }

  function addDrawPoint(latlng) {
    drawPoints.push(latlng);

    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
      <circle cx="5" cy="5" r="4" fill="#00C2FF" stroke="#0b1220" stroke-width="1.5"/>
    </svg>`;
    const markerImageSrc = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    const markerImage = new kakao.maps.MarkerImage(markerImageSrc, new kakao.maps.Size(10, 10), {
      offset: new kakao.maps.Point(5, 5)
    });

    const m = new kakao.maps.Marker({
      position: latlng,
      image: markerImage,
      zIndex: 30
    });
    m.setMap(map);
    drawMarkers.push(m);

    drawLine.setPath(drawPoints);
  }

  function popDrawPoint() {
    if (drawPoints.length === 0) return;
    drawPoints.pop();
    const m = drawMarkers.pop();
    if (m) m.setMap(null);
    drawLine.setPath(drawPoints);
  }

  function finishDraw() {
    if (drawPoints.length < 3) {
      setStatus("í´ë¦¬ê³¤ ìƒì„± ì‹¤íŒ¨: ì ì´ 3ê°œ ì´ìƒ í•„ìš”", "WARN");
      return;
    }

    const camp = campInput.value.trim();
    const code = codeInput.value.trim();
    const color = colorFor(code);

    let rowId = selectedRouteId;

    if (drawMode === "new") {
      if (rowId && overlayById.has(rowId)) {
        const pack = overlayById.get(rowId);
        pack.polygons.forEach(p => p.setMap(null));
        pack.labels.forEach(l => l.setMap(null));
        pack.polygons = [];
        pack.labels = [];
      } else {
        for (const [id, pack] of overlayById.entries()) {
          const r = pack.row;
          if ((r.camp||"") === camp && (r.full_code||"") === code) {
            rowId = id;
            pack.polygons.forEach(p => p.setMap(null));
            pack.labels.forEach(l => l.setMap(null));
            pack.polygons = [];
            pack.labels = [];
            break;
          }
        }
      }
    }

    const poly = makePolygon(drawPoints.slice(), color, color, 5);
    poly.setMap(map);
    kakao.maps.event.addListener(poly, "click", () => {
      if (rowId && !drawMode) startEditing(rowId);
    });

    if (!rowId) {
      rowId = `tmp_${camp}_${code}`;
      overlayById.set(rowId, {
        row: {
          id: rowId,
          camp,
          full_code: code,
          color,
          polygon_wgs84: null,
          vendor_name: vendorNameInput.value.trim(),
          vendor_business_number: vendorBizInput.value.trim(),
          delivery_location_name: deliveryNameInput.value.trim(),
          delivery_location_address: deliveryAddrInput.value.trim()
        },
        polygons: [],
        labels: []
      });
    }

    const pack = overlayById.get(rowId);
    pack.row.camp = camp;
    pack.row.full_code = code;
    pack.row.color = color;

    pack.polygons.push(poly);

    if (labelOn) {
      const c = centroidOfLatLngs(drawPoints);
      const label = createLabelOverlay(code, c, color);
      label.setMap(map);
      pack.labels.push(label);
    }

    stopDraw(true);
    selectedRouteId = rowId;
    selectedInfo.textContent = `ì„ íƒ: ${camp} / ${code} (id=${rowId})`;
    editPolygons = pack.polygons.slice();
    rebuildHandles();
    hint("", false);

    setStatus(`í´ë¦¬ê³¤ ìƒì„± ì™„ë£Œ: ${drawMode === "new" ? "êµì²´" : "ì¶”ê°€"} 1ê°œ`, "OK");
  }

  // ====== ì €ì¥ ë°ì´í„° ë§Œë“¤ê¸° ======
  function getCurrentEditedPolygonWgs84ById(id) {
    const pack = overlayById.get(id);
    if (!pack) return null;
    const polys = pack.polygons;
    if (!polys || polys.length === 0) return null;

    const out = [];
    for (const p of polys) {
      const path = p.getPath();
      if (!path || path.length < 3) continue;
      const ring = [];
      for (let i=0;i<path.length;i++) {
        const ll = path[i];
        ring.push([ ll.getLng(), ll.getLat() ]);
      }
      out.push(ring);
    }
    return out.length ? out : null;
  }

  // ====== ë°°ì†¡ì§€ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ======
  async function loadAddresses() {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) return;

      const url = new URL(ADDRESS_ENDPOINT);
      url.searchParams.set("camp", camp);
      if (code) url.searchParams.set("code", code);

      const data = await apiGet(url.toString());
      addressRows = data?.rows || [];

      renderAddressList();
      log(`ë°°ì†¡ì§€ ${addressRows.length}ê°œ ë¡œë“œ ì™„ë£Œ`);
    } catch (e) {
      console.error('ë°°ì†¡ì§€ ë¡œë“œ ì‹¤íŒ¨:', e);
      addressRows = [];
      renderAddressList();
    }
  }

  // ====== ë°°ì†¡ì§€ ëª©ë¡ ë Œë”ë§ ======
  function renderAddressList() {
    const container = document.getElementById("addressList");
    const group = document.getElementById("addressListGroup");

    if (!addressRows || addressRows.length === 0) {
      group.style.display = "none";
      container.innerHTML = "";
      return;
    }

    group.style.display = "block";
    container.innerHTML = "";

    addressRows.forEach((addr, idx) => {
      const item = document.createElement("div");
      item.style.cssText = `
        padding: 8px;
        margin-bottom: 6px;
        background: rgba(0,0,0,0.15);
        border: 1px solid var(--line);
        border-radius: 8px;
        font-size: 12px;
      `;

      const addressText = addr.address || addr.full_address || "ì£¼ì†Œ ì—†ìŒ";
      const dong = addr.dong ? `<span style="color:var(--muted)">(${addr.dong})</span>` : "";

      item.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
          <div style="flex:1; min-width:0;">
            <div style="font-weight:600; color:var(--txt); margin-bottom:2px;">
              ${idx + 1}. ${addressText} ${dong}
            </div>
            <div style="color:var(--muted); font-size:11px;">
              ${addr.zipcode ? `ìš°í¸ë²ˆí˜¸: ${addr.zipcode}` : ""}
            </div>
          </div>
          <button class="btn" style="padding:6px 12px; font-size:11px; white-space:nowrap;"
                  data-addr-id="${addr.id}">
            ë„¤ë¹„
          </button>
        </div>
      `;

      const naviBtn = item.querySelector("button");
      naviBtn.onclick = () => openNaviToAddress(addr);

      container.appendChild(item);
    });
  }

  // ====== ë°°ì†¡ì§€ë¡œ ë„¤ë¹„ ì‹¤í–‰ ======
  async function openNaviToAddress(addr) {
    const deliveryAddr = deliveryAddrInput.value.trim();

    if (!deliveryAddr) {
      setStatus("ì…ì°¨ì§€ ì£¼ì†Œë¥¼ ë¨¼ì € ì…ë ¥í•´ì£¼ì„¸ìš”.", "WARN");
      return;
    }

    if (!addr.center_wgs84) {
      setStatus("ë°°ì†¡ì§€ ì¢Œí‘œ(center_wgs84)ê°€ ì—†ìŠµë‹ˆë‹¤.", "ERR");
      return;
    }

    setStatus(`ê²½ë¡œ ê³„ì‚° ì¤‘: ì…ì°¨ì§€ â†’ ${addr.address || "ë°°ì†¡ì§€"}`, "OK");

    geocoder.addressSearch(deliveryAddr, (result, status) => {
      if (status !== kakao.maps.services.Status.OK || !result?.length) {
        setStatus("ì…ì°¨ì§€ ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", "ERR");
        return;
      }

      const startLat = Number(result[0].y);
      const startLng = Number(result[0].x);

      let endLat, endLng;

      if (typeof addr.center_wgs84 === 'object') {
        endLat = addr.center_wgs84.lat || addr.center_wgs84.latitude;
        endLng = addr.center_wgs84.lng || addr.center_wgs84.lon || addr.center_wgs84.longitude;
      } else if (Array.isArray(addr.center_wgs84) && addr.center_wgs84.length >= 2) {
        const [first, second] = addr.center_wgs84;
        if (Math.abs(first) > Math.abs(second)) {
          endLng = first;
          endLat = second;
        } else {
          endLat = first;
          endLng = second;
        }
      }

      if (!endLat || !endLng || !isFinite(endLat) || !isFinite(endLng)) {
        setStatus("ë°°ì†¡ì§€ ì¢Œí‘œ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.", "ERR");
        log(`center_wgs84: ${JSON.stringify(addr.center_wgs84)}`);
        return;
      }

      const deliveryName = deliveryNameInput.value.trim() || "ì…ì°¨ì§€";
      const addressName = addr.address || "ë°°ì†¡ì§€";

      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

      let naviUrl;
      if (isMobile) {
        naviUrl = `kakaomap://route?sp=${startLat},${startLng}&ep=${endLat},${endLng}&by=CAR`;
      } else {
        naviUrl = `https://map.kakao.com/link/from/${encodeURIComponent(deliveryName)},${startLat},${startLng}/to/${encodeURIComponent(addressName)},${endLat},${endLng}`;
      }

      window.open(naviUrl, "_blank");
      setStatus(`ë„¤ë¹„ ì‹¤í–‰: ${deliveryName} â†’ ${addressName}`, "OK");
      log(`ê²½ë¡œ: (${startLat.toFixed(4)}, ${startLng.toFixed(4)}) â†’ (${endLat.toFixed(4)}, ${endLng.toFixed(4)})`);
    });
  }

  // ====== ë¶ˆëŸ¬ì˜¤ê¸° ======
  async function loadRoutes() {
    try {
      stopEditing();
      stopDraw(true);
      clearOsm();

      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }

      const codes = code ? code.split(/[,\s]+/).map(c => c.trim()).filter(c => c) : [];

      let allRows = [];

      if (codes.length === 0) {
        const url = new URL(ROUTE_ENDPOINT);
        url.searchParams.set("camp", camp);
        url.searchParams.set("mode", "prefix");

        const data = await apiGet(url.toString());

        if (!data || !data.rows) {
          setStatus("ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜", "ERR");
          return;
        }

        allRows = data.rows;
      } else if (codes.length === 1) {
        const url = new URL(ROUTE_ENDPOINT);
        url.searchParams.set("camp", camp);
        url.searchParams.set("mode", "prefix");
        url.searchParams.set("code", codes[0]);

        const data = await apiGet(url.toString());

        if (!data || !data.rows) {
          setStatus("ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜", "ERR");
          return;
        }

        allRows = data.rows;
      } else {
        setStatus(`${codes.length}ê°œ ë¼ìš°íŠ¸ ì¡°íšŒ ì¤‘...`, "OK");

        for (const singleCode of codes) {
          try {
            const url = new URL(ROUTE_ENDPOINT);
            url.searchParams.set("camp", camp);
            url.searchParams.set("mode", "prefix");
            url.searchParams.set("code", singleCode);

            const data = await apiGet(url.toString());

            if (data && data.rows && data.rows.length > 0) {
              allRows.push(...data.rows);
              log(`${singleCode}: ${data.rows.length}ê°œ ë°œê²¬`);
            } else {
              log(`${singleCode}: ë°ì´í„° ì—†ìŒ`);
            }
          } catch (err) {
            log(`${singleCode}: ì¡°íšŒ ì‹¤íŒ¨ - ${err.message}`);
          }
        }
      }

      if (allRows.length === 0) {
        setStatus("ì¡°íšŒëœ ë¼ìš°íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.", "WARN");
        clearAllOverlays();
        return;
      }

      renderRoutes(allRows);

      await loadAddresses();
    } catch (e) {
      console.error(e);
      const errMsg = e.message || String(e);
      if (errMsg.includes("column") && errMsg.includes("does not exist")) {
        setStatus(`ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì˜¤ë¥˜: ${errMsg}. ë°±ì—”ë“œ APIë¥¼ í™•ì¸í•˜ì„¸ìš”.`, "ERR");
        log("íŒíŠ¸: ë°±ì—”ë“œì—ì„œ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì»¬ëŸ¼ì„ ì°¸ì¡°í•˜ê³  ìˆìŠµë‹ˆë‹¤.");
        log("ë°±ì—”ë“œ ì„œë²„ì˜ SQL ì¿¼ë¦¬ì™€ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆë¥¼ í™•ì¸í•˜ì„¸ìš”.");
      } else {
        setStatus(`ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${errMsg}`, "ERR");
      }
    }
  }

  // ====== ì €ì¥(POST) ======
  async function saveCurrent() {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }
      if (!code) { setStatus("codeê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }

      let id = selectedRouteId;
      if (!id || !overlayById.has(id)) {
        for (const [rid, pack] of overlayById.entries()) {
          if ((pack.row.camp||"") === camp && (pack.row.full_code||"") === code) {
            id = rid;
            break;
          }
        }
      }

      const polygonSourceId = id;
      let actualId = id;

      if (actualId && typeof actualId === "string" && actualId.startsWith("tmp_")) {
        const actualRow = routeRows.find(r =>
          (r.camp||"") === camp && (r.full_code||"") === code
        );
        if (actualRow && typeof actualRow.id === "number") {
          actualId = actualRow.id;
          log(`ì„ì‹œ IDë¥¼ ì‹¤ì œ IDë¡œ ë³€í™˜: ${polygonSourceId} â†’ ${actualId}`);
        } else {
          actualId = undefined;
          log(`ì‹¤ì œ rowê°€ ì—†ìŒ. ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.`);
        }
      }

      const polygon_wgs84 = polygonSourceId ? getCurrentEditedPolygonWgs84ById(polygonSourceId) : null;

      if (!actualId) {
        const existingRow = routeRows.find(r => {
          const rCamp = r.camp || r.camp_name || "";
          const rCode = r.full_code || r.code || r.route_code || "";
          return rCamp === camp && rCode === code;
        });
        if (existingRow && typeof existingRow.id === "number") {
          actualId = existingRow.id;
        } else {
          try {
            const url = new URL(ROUTE_ENDPOINT);
            url.searchParams.set("camp", camp);
            url.searchParams.set("code", code);
            url.searchParams.set("mode", "exact");
            const checkData = await apiGet(url.toString());
            if (checkData && checkData.rows && checkData.rows.length > 0) {
              actualId = checkData.rows[0].id;
            }
          } catch (checkErr) {}
        }
      }

      const payload = {
        camp,
        code,
        polygon_wgs84,
        vendor_name: vendorNameInput.value.trim() || null,
        vendor_business_number: vendorBizInput.value.trim() || null,
        delivery_location_name: deliveryNameInput.value.trim() || null,
        delivery_location_address: deliveryAddrInput.value.trim() || null
      };

      if (typeof actualId === "number") {
        payload.id = actualId;
      }

      await apiJson("POST", ROUTE_ENDPOINT, payload);
      setStatus(`ì €ì¥ ì™„ë£Œ`, "OK");

      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`ì €ì¥ ì‹¤íŒ¨: ${e.message}`, "ERR");
    }
  }

  // ====== í´ë¦¬ê³¤ ì‚­ì œ (polygon_wgs84=null) ======
  async function deletePolygon() {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }
      if (!code) { setStatus("codeê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }

      let id = selectedRouteId;
      const payload = (typeof id === "number") ? { id } : { camp, code };

      setStatus("DELETE /route ìš”ì²­ (polygon_wgs84=null)", "OK");
      await apiJson("DELETE", ROUTE_ENDPOINT, payload);
      setStatus("í´ë¦¬ê³¤ ì‚­ì œ ì™„ë£Œ", "OK");

      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`í´ë¦¬ê³¤ ì‚­ì œ ì‹¤íŒ¨: ${e.message}`, "ERR");
    }
  }

  // ====== ë²¤ë” ì €ì¥/ë¹„ìš°ê¸° ======
  async function saveVendorOnly(clear=false) {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }
      if (!code) { setStatus("codeê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }

      let id = selectedRouteId;

      if (id && typeof id === "string" && id.startsWith("tmp_")) {
        const actualRow = routeRows.find(r =>
          (r.camp||"") === camp && (r.full_code||"") === code
        );
        if (actualRow && typeof actualRow.id === "number") {
          id = actualRow.id;
        } else {
          id = undefined;
        }
      }

      const payload = {
        camp,
        code,
        vendor_name: clear ? null : (vendorNameInput.value.trim() || null),
        vendor_business_number: clear ? null : (vendorBizInput.value.trim() || null),
      };

      if (typeof id === "number") {
        payload.id = id;
      }

      setStatus(clear ? "ë²¤ë” ë¹„ìš°ê¸° ì €ì¥" : "ë²¤ë” ì €ì¥", "OK");
      await apiJson("POST", ROUTE_ENDPOINT, payload);
      setStatus(clear ? "ë²¤ë” ë¹„ìš°ê¸° ì™„ë£Œ" : "ë²¤ë” ì €ì¥ ì™„ë£Œ", "OK");
      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`ë²¤ë” ì €ì¥ ì‹¤íŒ¨: ${e.message}`, "ERR");
    }
  }

  // ====== í´ë¦¬ê³¤ ì¤‘ì‹¬ì  ê³„ì‚° ======
  function getRouteCenter() {
    if (!selectedRouteId || !overlayById.has(selectedRouteId)) return null;

    const pack = overlayById.get(selectedRouteId);
    const polygons = pack.polygons;

    if (!polygons || polygons.length === 0) return null;

    const allPoints = [];
    for (const poly of polygons) {
      const path = poly.getPath();
      if (!path) continue;

      const len = Array.isArray(path) ? path.length : (path.getLength ? path.getLength() : 0);
      for (let i = 0; i < len; i++) {
        const pt = Array.isArray(path) ? path[i] : path.getAt(i);
        if (pt) allPoints.push(pt);
      }
    }

    if (allPoints.length === 0) return null;

    return centroidOfLatLngs(allPoints);
  }

  // ====== ì¹´ì¹´ì˜¤ë‚´ë¹„ ì—°ë™ ======
  async function openKakaoNavi() {
    const deliveryName = deliveryNameInput.value.trim() || "ì…ì°¨ì§€";
    const deliveryAddr = deliveryAddrInput.value.trim();

    if (!deliveryAddr) {
      setStatus("ì…ì°¨ì§€ ì£¼ì†Œë¥¼ ë¨¼ì € ì…ë ¥í•´ì£¼ì„¸ìš”.", "WARN");
      return;
    }

    if (!selectedRouteId) {
      setStatus("ë¼ìš°íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.", "WARN");
      return;
    }

    setStatus("ê²½ë¡œ ê³„ì‚° ì¤‘...", "OK");

    geocoder.addressSearch(deliveryAddr, (result, status) => {
      if (status !== kakao.maps.services.Status.OK || !result?.length) {
        setStatus("ì…ì°¨ì§€ ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì •í™•í•œ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.", "ERR");
        return;
      }

      const startLat = Number(result[0].y);
      const startLng = Number(result[0].x);

      const routeCenter = getRouteCenter();
      if (!routeCenter) {
        setStatus("ë¼ìš°íŠ¸ í´ë¦¬ê³¤ì´ ì—†ìŠµë‹ˆë‹¤.", "ERR");
        return;
      }

      const endLat = routeCenter.getLat();
      const endLng = routeCenter.getLng();

      const pack = overlayById.get(selectedRouteId);
      const routeName = pack.row.full_code || "ë¼ìš°íŠ¸";

      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

      let naviUrl;
      if (isMobile) {
        naviUrl = `kakaomap://route?sp=${startLat},${startLng}&ep=${endLat},${endLng}&by=CAR`;
      } else {
        naviUrl = `https://map.kakao.com/link/from/${encodeURIComponent(deliveryName)},${startLat},${startLng}/to/${encodeURIComponent(routeName)},${endLat},${endLng}`;
      }

      window.open(naviUrl, "_blank");
      setStatus(`ì¹´ì¹´ì˜¤ë‚´ë¹„ ì‹¤í–‰: ${deliveryName} â†’ ${routeName}`, "OK");
      log(`ê²½ë¡œ ì•ˆë‚´: ${deliveryName} (${startLat.toFixed(4)}, ${startLng.toFixed(4)}) â†’ ${routeName} (${endLat.toFixed(4)}, ${endLng.toFixed(4)})`);
    });
  }

  // ====== ì…ì°¨ì§€ ì €ì¥/ë¹„ìš°ê¸° ======
  async function saveDeliveryOnly(clear=false) {
    try {
      const camp = campInput.value.trim();
      const code = codeInput.value.trim();
      if (!camp) { setStatus("campê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }
      if (!code) { setStatus("codeê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤.", "ERR"); return; }

      let id = selectedRouteId;

      if (id && typeof id === "string" && id.startsWith("tmp_")) {
        const actualRow = routeRows.find(r =>
          (r.camp||"") === camp && (r.full_code||"") === code
        );
        if (actualRow && typeof actualRow.id === "number") {
          id = actualRow.id;
        } else {
          id = undefined;
        }
      }

      const payload = {
        camp,
        code,
        delivery_location_name: clear ? null : (deliveryNameInput.value.trim() || null),
        delivery_location_address: clear ? null : (deliveryAddrInput.value.trim() || null),
      };

      if (typeof id === "number") {
        payload.id = id;
      }

      setStatus(clear ? "ì…ì°¨ì§€ ë¹„ìš°ê¸° ì €ì¥" : "ì…ì°¨ì§€ ì €ì¥", "OK");
      await apiJson("POST", ROUTE_ENDPOINT, payload);
      setStatus(clear ? "ì…ì°¨ì§€ ë¹„ìš°ê¸° ì™„ë£Œ" : "ì…ì°¨ì§€ ì €ì¥ ì™„ë£Œ", "OK");
      await loadRoutes();
    } catch (e) {
      console.error(e);
      setStatus(`ì…ì°¨ì§€ ì €ì¥ ì‹¤íŒ¨: ${e.message}`, "ERR");
    }
  }

  // ====== OSM ì •ë ¬(Overpass) ======
  async function alignWithOsm() {
    try {
      clearOsm();

      const b = map.getBounds();
      const sw = b.getSouthWest();
      const ne = b.getNorthEast();

      const bbox = `${sw.getLng()},${sw.getLat()},${ne.getLng()},${ne.getLat()}`;
      const url = new URL(OSM_ENDPOINT);
      url.searchParams.set("bbox", bbox);

      setStatus(`GET /osm ìš”ì²­: ${url.toString()}`, "OK");
      const data = await apiGet(url.toString());

      const roads = data?.roads || [];
      const buildings = data?.buildings || [];

      for (const r of roads) {
        if (!r.coords || r.coords.length < 2) continue;
        const path = r.coords.map(([lng,lat]) => new kakao.maps.LatLng(lat,lng));
        const pl = new kakao.maps.Polyline({
          path,
          strokeWeight: 2,
          strokeColor: "#ffffff",
          strokeOpacity: 0.35,
          strokeStyle: "solid",
          zIndex: 0
        });
        pl.setMap(map);
        osmOverlays.push(pl);
      }

      for (const g of buildings) {
        if (!g.coords || g.coords.length < 3) continue;
        const path = g.coords.map(([lng,lat]) => new kakao.maps.LatLng(lat,lng));
        const pg = new kakao.maps.Polygon({
          path,
          strokeWeight: 1,
          strokeColor: "#ffffff",
          strokeOpacity: 0.18,
          strokeStyle: "solid",
          fillColor: "#ffffff",
          fillOpacity: 0.05,
          zIndex: 0
        });
        pg.setMap(map);
        osmOverlays.push(pg);
      }

      setStatus(`OSM í‘œì‹œ ì™„ë£Œ: roads ${roads.length}, buildings ${buildings.length}`, "OK");
    } catch (e) {
      console.error(e);
      setStatus(`OSM ì •ë ¬ ì‹¤íŒ¨: ${e.message}`, "ERR");
    }
  }

  // ====== ë¼ë²¨ í† ê¸€ ======
  function toggleLabels() {
    labelOn = !labelOn;
    labelToggleBtn.textContent = labelOn ? "ë¼ìš°íŠ¸ ë¼ë²¨ ON" : "ë¼ìš°íŠ¸ ë¼ë²¨ OFF";

    for (const [id, pack] of overlayById.entries()) {
      pack.labels.forEach(l => l.setMap(null));
      pack.labels = [];

      if (!labelOn) continue;

      const row = pack.row;
      const code = row.full_code || "";
      const color = row.color || colorFor(code);

      for (const p of pack.polygons) {
        const path = p.getPath();
        if (!path || path.length < 3) continue;
        const c = centroidOfLatLngs(path);
        const label = createLabelOverlay(code, c, color);
        label.setMap(map);
        pack.labels.push(label);
      }
    }
  }

  // ====== ì´ˆê¸°í™” ======
  function resetMap() {
    clearAllOverlays();
    clearOsm();
    stopDraw(true);
    hint("", false);
    setStatus("ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ.", "OK");
  }

  // ====== (ì¶”ê°€) KST yyyymmddHHMM ======
  function kstYYYYMMDDHHMM() {
    const now = new Date();
    const kst = new Date(now.getTime() + 9 * 60 * 60 * 1000);
    const yyyy = String(kst.getUTCFullYear());
    const mm = String(kst.getUTCMonth() + 1).padStart(2, "0");
    const dd = String(kst.getUTCDate()).padStart(2, "0");
    const HH = String(kst.getUTCHours()).padStart(2, "0");
    const MM = String(kst.getUTCMinutes()).padStart(2, "0");
    return `${yyyy}${mm}${dd}${HH}${MM}`;
  }

  // ====== ê³µìœ  ë§í¬ ìƒì„± ======
  function generateShareLink() {
    const camp = campInput.value.trim();
    const code = codeInput.value.trim();

    if (!camp) {
      setStatus("ìº í”„ ì •ë³´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.", "WARN");
      return;
    }

    const shareUrl = new URL("/share.html", location.origin);
    shareUrl.searchParams.set("camp", camp);
    if (code) {
      shareUrl.searchParams.set("code", code);
    }

    shareUrl.searchParams.set("v", kstYYYYMMDDHHMM());

    const url = shareUrl.toString();

    navigator.clipboard.writeText(url).then(() => {
      setStatus("ê³µìœ  ë§í¬ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!", "OK");

      const confirmed = confirm(
        `ê³µìœ  ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\n\n${url}\n\nìƒˆ íƒ­ì—ì„œ ë¯¸ë¦¬ë³´ê¸°ë¥¼ ì—¬ì‹œê² ìŠµë‹ˆê¹Œ?`
      );

      if (confirmed) {
        window.open(url, "_blank");
      }
    }).catch(err => {
      prompt("ê³µìœ  ë§í¬ (Ctrl+Cë¡œ ë³µì‚¬):", url);
      setStatus("ê³µìœ  ë§í¬ë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤.", "OK");
    });

    log(`ê³µìœ  ë§í¬ ìƒì„±: ${url}`);
  }

  // ====== (ì¶”ê°€) ìœ„ì„± í† ê¸€ ======
  function setMapTypeSatellite(on) {
    isSatellite = !!on;
    if (!map) return;
    map.setMapTypeId(
      isSatellite ? kakao.maps.MapTypeId.HYBRID : kakao.maps.MapTypeId.ROADMAP
    );
    if (toggleMapTypeBtn) toggleMapTypeBtn.textContent = isSatellite ? "ì¼ë°˜" : "ìœ„ì„±";
  }

  // ====== (ì¶”ê°€) ë¡œë“œë·° ======
  function ensureRoadview() {
    if (roadview && roadviewClient) return;
    const container = $("roadview");
    if (!container) return;
    roadview = new kakao.maps.Roadview(container);
    roadviewClient = new kakao.maps.RoadviewClient();
  }

  function setRoadviewOverlay(on) {
    if (!map) return;
    try {
      if (on) map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
      else map.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
    } catch (e) {
      console.warn("ROADVIEW ì˜¤ë²„ë ˆì´ í† ê¸€ ì‹¤íŒ¨", e);
    }
  }

  function setRoadviewAt(latlng) {
    ensureRoadview();
    if (!roadviewClient || !roadview) return;

    const radii = [80, 200, 500, 1200];
    const tryFind = (i) => {
      const r = radii[i];
      roadviewClient.getNearestPanoId(latlng, r, (panoId) => {
        if (panoId === null || panoId === undefined) {
          if (i < radii.length - 1) return tryFind(i + 1);
          alert("ì´ ìœ„ì¹˜ ê·¼ì²˜ì—ëŠ” ë¡œë“œë·°ê°€ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        roadviewOpen = true;
        if (mapWrapEl) mapWrapEl.classList.add("roadview-open");

        if (roadview && typeof roadview.relayout === "function") {
          setTimeout(() => roadview.relayout(), 0);
        }
        roadview.setPanoId(panoId, latlng);
      });
    };
    tryFind(0);
  }

  function setRoadviewOn(on) {
    roadviewOn = !!on;
    if (!roadviewOn) roadviewOpen = false;

    if (roadviewHintEl) roadviewHintEl.style.display = roadviewOn ? "inline-flex" : "none";
    if (toggleRoadviewBtn) toggleRoadviewBtn.textContent = roadviewOn ? "ë¡œë“œë·° ì¢…ë£Œ" : "ë¡œë“œë·°";

    if (!roadviewOn && mapWrapEl) mapWrapEl.classList.remove("roadview-open");

    if (map) {
      const c = map.getCenter();
      map.relayout();
      map.setCenter(c);
    }

    if (roadviewOn) {
      // í¸ì§‘/ê·¸ë¦¬ê¸° ì¤‘ ì¶©ëŒ ë°©ì§€: ë¡œë“œë·° ì¼œë©´ í¸ì§‘/ê·¸ë¦¬ê¸° ì¢…ë£Œ
      stopDraw(true);
      stopEditing();

      setRoadviewOverlay(true);

      if (!roadviewClickHandler && map) {
        roadviewClickHandler = (mouseEvent) => {
          if (!roadviewOn) return;
          if (mouseEvent && mouseEvent.latLng) setRoadviewAt(mouseEvent.latLng);
        };
        kakao.maps.event.addListener(map, "click", roadviewClickHandler);
      }
    } else {
      setRoadviewOverlay(false);
      if (roadviewClickHandler && map) {
        kakao.maps.event.removeListener(map, "click", roadviewClickHandler);
      }
      roadviewClickHandler = null;
    }

    if (roadviewOn && roadviewOpen) {
      ensureRoadview();
      if (roadview && typeof roadview.relayout === "function") roadview.relayout();
    }
  }

  // ====== (ì¶”ê°€) ì£¼ì†Œê²€ìƒ‰ ëª¨ë‹¬ ======
  function openSearchModal() {
    if (!places) {
      setStatus("Places ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ì‹¤íŒ¨", "ERR");
      return;
    }
    searchModalOpen = true;
    if (searchModalEl) searchModalEl.style.display = "flex";
    if (searchQueryInput) {
      searchQueryInput.focus();
      searchQueryInput.select();
    }
    // ë¡œë“œë·°ëŠ” ê²€ìƒ‰ ì¤‘ UXê°€ ê¼¬ì´ê¸° ì‰¬ì›Œì„œ OFF
    setRoadviewOn(false);
  }

  function closeSearchModal(silent=false) {
    searchModalOpen = false;
    lastPagination = null;
    if (searchPagerEl) {
      searchPagerEl.style.display = "none";
      searchPagerEl.innerHTML = "";
    }
    if (searchResultsEl && !silent) searchResultsEl.innerHTML = "";
    if (searchModalEl) searchModalEl.style.display = "none";
  }

  function ensureSearchMarker() {
    if (!searchMarker) {
      searchMarker = new kakao.maps.Marker({ zIndex: 999 });
    }
    if (!searchInfo) {
      searchInfo = new kakao.maps.InfoWindow({ zIndex: 999, removable: true });
    }
  }

  function renderSearchResults(items, pagination, metaText) {
    searchResultsEl.innerHTML = "";

    if (metaText) {
      const meta = document.createElement("div");
      meta.className = "small";
      meta.style.color = "var(--muted)";
      meta.style.margin = "0 0 10px";
      meta.textContent = metaText;
      searchResultsEl.appendChild(meta);
    }

    if (!items || !items.length) {
      const empty = document.createElement("div");
      empty.className = "resultItem";
      empty.style.cursor = "default";
      empty.innerHTML = `
        <div class="resultName">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
        <div class="resultMeta">ë‹¤ë¥¸ í‚¤ì›Œë“œë¡œ ë‹¤ì‹œ ê²€ìƒ‰í•´ë³´ì„¸ìš”.</div>
      `;
      searchResultsEl.appendChild(empty);
      if (searchPagerEl) {
        searchPagerEl.style.display = "none";
        searchPagerEl.innerHTML = "";
      }
      return;
    }

    items.forEach((p, idx) => {
      const div = document.createElement("div");
      div.className = "resultItem";

      const name = p.place_name || p.address_name || p.road_address?.address_name || "ì´ë¦„ ì—†ìŒ";
      const addr = p.road_address_name || p.address_name || "";
      const road = p.road_address_name && p.address_name && p.road_address_name !== p.address_name
        ? `ë„ë¡œëª…: ${p.road_address_name}`
        : "";
      const phone = p.phone ? `ì „í™”: ${p.phone}` : "";
      const cat = p.category_group_name || p.category_name || "";

      div.innerHTML = `
        <div class="resultTop">
          <div class="resultName">${escapeHtml(name)}</div>
          <span class="resultTag">${idx + 1}</span>
        </div>
        <div class="resultMeta">
          ${addr ? `ì§€ë²ˆ: ${escapeHtml(addr)}` : ""}
          ${road ? `<br/>${escapeHtml(road)}` : ""}
          ${cat ? `<br/>ë¶„ë¥˜: ${escapeHtml(cat)}` : ""}
          ${phone ? `<br/>${escapeHtml(phone)}` : ""}
        </div>
      `;

      div.onclick = () => {
        const x = Number(p.x);
        const y = Number(p.y);
        if (!isFinite(x) || !isFinite(y)) return;

        const pos = new kakao.maps.LatLng(y, x);
        map.setCenter(pos);
        map.setLevel(3);

        ensureSearchMarker();
        searchMarker.setPosition(pos);
        searchMarker.setMap(map);

        const iw = `<div style="padding:8px 10px;font-weight:900;font-size:13px;color:#111827;">
          ${escapeHtml(name)}
          <div style="margin-top:4px;font-weight:700;font-size:12px;color:#374151;">
            ${escapeHtml(addr || road || "")}
          </div>
        </div>`;
        searchInfo.setContent(iw);
        searchInfo.open(map, searchMarker);

        closeSearchModal(true);
        setStatus(`ì£¼ì†Œê²€ìƒ‰ ì´ë™: ${name}`, "OK");
      };

      searchResultsEl.appendChild(div);
    });

    lastPagination = pagination || null;

    if (pagination && typeof pagination.gotoPage === "function") {
      searchPagerEl.style.display = "flex";
      searchPagerEl.innerHTML = "";

      const prev = document.createElement("button");
      prev.textContent = "ì´ì „";
      prev.disabled = pagination.current <= 1;
      prev.onclick = () => pagination.gotoPage(pagination.current - 1);

      const next = document.createElement("button");
      next.textContent = "ë‹¤ìŒ";
      next.disabled = pagination.current >= pagination.last;
      next.onclick = () => pagination.gotoPage(pagination.current + 1);

      const info = document.createElement("span");
      info.className = "small";
      info.style.color = "var(--muted)";
      info.textContent = `${pagination.current} / ${pagination.last}`;

      searchPagerEl.appendChild(prev);
      searchPagerEl.appendChild(info);
      searchPagerEl.appendChild(next);
    } else {
      searchPagerEl.style.display = "none";
      searchPagerEl.innerHTML = "";
    }
  }

  function doSearchKeyword(q, page=1) {
    if (!q) return;

    setStatus(`ì£¼ì†Œê²€ìƒ‰: "${q}"`, "OK");

    const center = map.getCenter();
    const opts = {
      page,
      size: 15
    };

    // ì¹´ì¹´ì˜¤ì§€ë„ì²˜ëŸ¼ "í˜„ ì§€ë„ ì¤‘ì‹¬ ê¸°ì¤€"ìœ¼ë¡œ ë” ê·¸ëŸ´ë“¯í•˜ê²Œ ë‚˜ì˜¤ë„ë¡
    if (center) {
      opts.location = center;
      opts.radius = 20000; // 20km
      if (kakao.maps.services.SortBy && kakao.maps.services.SortBy.DISTANCE) {
        opts.sort = kakao.maps.services.SortBy.DISTANCE;
      }
    }

    places.keywordSearch(q, (data, status, pagination) => {
      if (status === kakao.maps.services.Status.OK && Array.isArray(data) && data.length) {
        renderSearchResults(data, pagination, `í‚¤ì›Œë“œ ê²€ìƒ‰ ê²°ê³¼ ${data.length}ê°œ`);
        return;
      }

      // ZERO_RESULT ë˜ëŠ” ê¸°íƒ€: ì£¼ì†Œê²€ìƒ‰ fallback
      geocoder.addressSearch(q, (result, st) => {
        if (st === kakao.maps.services.Status.OK && result && result.length) {
          const r = result[0];
          const fake = [{
            place_name: r.address_name || q,
            address_name: r.address_name || "",
            road_address_name: r.road_address?.address_name || "",
            x: r.x,
            y: r.y,
            category_name: "ì£¼ì†Œ"
          }];
          renderSearchResults(fake, null, "í‚¤ì›Œë“œ ê²°ê³¼ ì—†ìŒ â†’ ì£¼ì†Œê²€ìƒ‰ ê²°ê³¼ 1ê°œ");
        } else {
          renderSearchResults([], null, "ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ");
        }
      });
    }, opts);
  }

  // ====== ì£¼ì†Œê²€ìƒ‰ ë²„íŠ¼ ì•¡ì…˜(ê¸°ì¡´ prompt ì œê±°) ======
  function searchAddressUI() {
    openSearchModal();
  }

  // ====== ì§€ë„ ì´ë²¤íŠ¸(ê·¸ë¦¬ê¸° ëª¨ë“œ + ì»¤ìŠ¤í…€ ë“œë˜ê·¸) ======
  function attachMapEvents() {
    kakao.maps.event.addListener(map, "click", (mouseEvent) => {
      // ë¡œë“œë·° ONì´ë©´ draw click ë¬´ì‹œ(ë¡œë“œë·° í•¸ë“¤ëŸ¬ê°€ ì²˜ë¦¬)
      if (roadviewOn) return;
      // ê²€ìƒ‰ ëª¨ë‹¬ ì—´ë ¤ ìˆìœ¼ë©´ ë¬´ì‹œ
      if (searchModalOpen) return;

      if (!drawMode) return;
      const latlng = mouseEvent.latLng;
      addDrawPoint(latlng);
    });

    kakao.maps.event.addListener(map, "rightclick", () => {
      if (roadviewOn) return;
      if (searchModalOpen) return;

      if (!drawMode) return;
      popDrawPoint();
    });

    const handleMouseMove = (e) => {
      if (!draggingVertex) return;

      const mapDiv = map.getNode();
      const rect = mapDiv.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const proj = map.getProjection();
      const point = new kakao.maps.Point(x, y);
      const newPos = proj.coordsFromContainerPoint(point);

      const { marker, polygon, index } = draggingVertex;

      marker.setPosition(newPos);

      const currentPath = polygon.getPath();
      const pathArray = [];
      if (currentPath && typeof currentPath.getLength === 'function') {
        for (let j = 0; j < currentPath.getLength(); j++) {
          pathArray.push(j === index ? newPos : currentPath.getAt(j));
        }
      } else if (Array.isArray(currentPath)) {
        for (let j = 0; j < currentPath.length; j++) {
          pathArray.push(j === index ? newPos : currentPath[j]);
        }
      }
      polygon.setPath(pathArray);

      updateSelectedLabels();
    };

    const handleMouseUp = () => {
      if (!draggingVertex) return;

      draggingVertex = null;
      map.setDraggable(true);
      rebuildHandles();
    };

    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);

    window.addEventListener("keydown", (e) => {
      // ê²€ìƒ‰ ëª¨ë‹¬ ìš°ì„  ì²˜ë¦¬
      if (searchModalOpen) {
        if (e.key === "Escape") {
          closeSearchModal();
          setStatus("ì£¼ì†Œê²€ìƒ‰ ë‹«í˜", "OK");
          return;
        }
        if (e.key === "Enter") {
          if (document.activeElement === searchQueryInput) {
            const q = (searchQueryInput.value || "").trim();
            if (q) doSearchKeyword(q, 1);
            e.preventDefault();
            return;
          }
        }
      }

      if (drawMode) {
        if (e.key === "Escape") {
          stopDraw();
          setStatus("ê·¸ë¦¬ê¸° ì·¨ì†Œ", "WARN");
        } else if (e.key === "Enter") {
          finishDraw();
        }
      } else if (e.key === "Escape") {
        if (selectedRouteId) {
          stopEditing();
          selectedRouteId = null;
          selectedInfo.textContent = "ì„ íƒ: ì—†ìŒ";
          setStatus("í¸ì§‘ ëª¨ë“œ í•´ì œ", "OK");
        }
      }
    });
  }

  // ====== ì´ˆê¸° êµ¬ë™ ======
  function init() {
    kakao.maps.load(() => {
      const center = new kakao.maps.LatLng(37.4936, 126.9019);
      map = new kakao.maps.Map($("map"), { center, level: 6 });

      geocoder = new kakao.maps.services.Geocoder();
      places = new kakao.maps.services.Places();

      VERTEX_IMG = makeHandleImage("#ffffff", "#0b1220");
      MID_IMG = makeHandleImage("#93a4c7", "#0b1220");

      attachMapEvents();

      // ë¦¬ì‚¬ì´ì¦ˆ ëŒ€ì‘ (ë¡œë“œë·° í¬í•¨)
      window.addEventListener("resize", () => {
        if (!map) return;
        const c = map.getCenter();
        map.relayout();
        map.setCenter(c);
        if (roadviewOn && roadview && typeof roadview.relayout === "function") {
          roadview.relayout();
        }
      });

      loadBtn.addEventListener("click", loadRoutes);
      drawNewBtn.addEventListener("click", () => beginDraw("new"));
      drawAddBtn.addEventListener("click", () => beginDraw("add"));
      addrBtn.addEventListener("click", searchAddressUI);

      saveBtn.addEventListener("click", saveCurrent);
      deletePolyBtn.addEventListener("click", deletePolygon);
      alignBtn.addEventListener("click", alignWithOsm);
      labelToggleBtn.addEventListener("click", toggleLabels);
      resetBtn.addEventListener("click", resetMap);

      vendorSaveBtn.addEventListener("click", () => saveVendorOnly(false));
      vendorClearBtn.addEventListener("click", () => saveVendorOnly(true));

      deliveryNaviBtn.addEventListener("click", openKakaoNavi);
      deliverySaveBtn.addEventListener("click", () => saveDeliveryOnly(false));
      deliveryClearBtn.addEventListener("click", () => saveDeliveryOnly(true));

      shareBtn.addEventListener("click", generateShareLink);

      // ìœ„ì„±/ë¡œë“œë·° ë²„íŠ¼
      if (toggleMapTypeBtn) toggleMapTypeBtn.addEventListener("click", () => setMapTypeSatellite(!isSatellite));
      if (toggleRoadviewBtn) toggleRoadviewBtn.addEventListener("click", () => setRoadviewOn(!roadviewOn));

      // ê²€ìƒ‰ ëª¨ë‹¬ ì´ë²¤íŠ¸
      if (searchDoBtn) searchDoBtn.addEventListener("click", () => {
        const q = (searchQueryInput.value || "").trim();
        if (!q) return;
        doSearchKeyword(q, 1);
      });
      if (searchCloseBtn) searchCloseBtn.addEventListener("click", () => closeSearchModal());
      if (searchModalEl) {
        searchModalEl.addEventListener("mousedown", (e) => {
          // ë°”ê¹¥ í´ë¦­ ë‹«ê¸°(ì¹´ë“œ ì™¸ë¶€)
          if (e.target === searchModalEl) closeSearchModal();
        });
      }

      setStatus("ì§€ë„ ë¡œë“œ ì™„ë£Œ", "OK");

      loadRoutes().catch((err) => {
        log("ìë™ ë¡œë“œ ì‹¤íŒ¨. ë°±ì—”ë“œ API í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
        setStatus("ìë™ ë¡œë“œ ì‹¤íŒ¨ (ë°±ì—”ë“œ API ì˜¤ë¥˜). ìƒˆë¡œ ê·¸ë¦¬ê¸°ëŠ” ê°€ëŠ¥í•©ë‹ˆë‹¤.", "WARN");
      });
    });
  }

  window.addEventListener("error", (ev) => {
    const msg = ev?.message || "Script error.";
    log(`ERR window.error: ${msg}`);
  });

  init();
})();
</script>
</body>
</html>
