<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>CoupangLand (프론트 임시 MVP)</title>
  <meta name="description" content="시/도→시군구→동 단위로 대리점/라우트 현황을 폴리곤 기반으로 조회합니다. (백엔드 없음 / localStorage 저장)" />
  <meta name="robots" content="noindex,nofollow" />

  <style>
    :root{
      /* Light theme */
      --bg:#f6f8fb;
      --panel:#ffffff;
      --panel2:#ffffff;
      --line:rgba(15,23,42,.10);
      --line2:rgba(15,23,42,.16);
      --text:#0b1220;
      --muted:rgba(15,23,42,.70);
      --muted2:rgba(15,23,42,.55);

      --accent:#6d5cff;
      --accent2:#1388ff;
      --danger:#e11d48;
      --ok:#16a34a;

      --shadow:0 10px 28px rgba(15,23,42,.10);
      --shadow2:0 6px 18px rgba(15,23,42,.08);
      --radius:18px;
      --radius2:14px;
      --radius3:12px;

      --chip:#f2f5fb;
      --chip2:#eef2ff;
      --btn:#f3f6fc;
      --btnH:#e9eef9;
      --input:#ffffff;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif;
      background:
        radial-gradient(900px 600px at 15% 0%, rgba(109,92,255,.12), transparent 60%),
        radial-gradient(900px 600px at 85% 0%, rgba(19,136,255,.10), transparent 60%),
        var(--bg);
      color:var(--text);
    }
    a{ color:inherit; }
    .wrap{
      max-width: 1400px;
      margin: 0 auto;
      padding: 18px 18px 26px;
    }

    /* header */
    .topbar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      padding: 14px 16px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.82);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .brand{
      display:flex;
      gap:12px;
      align-items:flex-start;
    }
    .dot{
      width:10px; height:10px;
      border-radius:999px;
      margin-top:6px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.45) 35%, rgba(255,255,255,0) 70%), var(--accent);
      box-shadow: 0 0 14px rgba(109,92,255,.38);
    }
    .brand h1{
      margin:0;
      font-size: 18px;
      letter-spacing: .2px;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .pill{
      font-size:12px;
      color:rgba(15,23,42,.82);
      border:1px solid var(--line2);
      background: rgba(109,92,255,.10);
      padding: 4px 10px;
      border-radius: 999px;
      font-weight: 800;
    }
    .subtitle{
      margin-top:6px;
      color:var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }
    .btn{
      appearance:none;
      border:1px solid var(--line2);
      background: var(--btn);
      color:var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: .15s ease;
      font-weight: 900;
      font-size: 13px;
      box-shadow: 0 1px 0 rgba(15,23,42,.05);
    }
    .btn:hover{ transform: translateY(-1px); background: var(--btnH); }
    .btn:active{ transform: translateY(0); }
    .btn.primary{
      border-color: rgba(109,92,255,.45);
      box-shadow: 0 0 0 1px rgba(109,92,255,.12) inset, 0 1px 0 rgba(15,23,42,.05);
      background: linear-gradient(180deg, rgba(109,92,255,.14), rgba(109,92,255,.08));
    }
    .btn.danger{
      border-color: rgba(225,29,72,.40);
      box-shadow: 0 0 0 1px rgba(225,29,72,.10) inset, 0 1px 0 rgba(15,23,42,.05);
      background: linear-gradient(180deg, rgba(225,29,72,.12), rgba(225,29,72,.06));
    }

    /* layout */
    .grid{
      margin-top: 14px;
      display:grid;
      grid-template-columns: 560px 1fr;
      gap: 14px;
      align-items: stretch;
    }
    @media (max-width: 1100px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      border:1px solid var(--line);
      background: rgba(255,255,255,.86);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height: 720px;
    }
    .cardHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 12px 14px;
      border-bottom:1px solid var(--line);
      background: rgba(255,255,255,.92);
    }
    .cardHeader h2{
      margin:0;
      font-size: 14px;
      letter-spacing:.2px;
      font-weight: 1000;
    }
    .badge{
      font-size:12px;
      border:1px solid var(--line2);
      color:rgba(15,23,42,.80);
      background: rgba(255,255,255,.70);
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 900;
    }
    .cardBody{
      padding: 12px 14px 14px;
    }

    /* search */
    .row{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .row + .row{ margin-top: 10px; }
    .input{
      width:100%;
      border:1px solid var(--line2);
      background: var(--input);
      color: var(--text);
      padding: 11px 12px;
      border-radius: 12px;
      outline:none;
      font-size: 13px;
      box-shadow: 0 1px 0 rgba(15,23,42,.04);
    }
    .input::placeholder{ color: rgba(15,23,42,.45); }
    .miniBtn{
      border:1px solid var(--line2);
      background: var(--btn);
      color: var(--text);
      padding: 11px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 1000;
      min-width: 72px;
      box-shadow: 0 1px 0 rgba(15,23,42,.05);
    }
    .miniBtn:hover{ background: var(--btnH); }

    /* chips */
    .chips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .chip{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 7px 10px;
      border-radius: 999px;
      background: var(--chip);
      border:1px solid var(--line2);
      color: rgba(15,23,42,.92);
      font-size: 12px;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 1px 0 rgba(15,23,42,.04);
    }
    .chip strong{
      font-weight: 1000;
      font-size: 12px;
    }
    .chip.active{
      border-color: rgba(109,92,255,.55);
      background: rgba(109,92,255,.12);
      box-shadow: 0 0 0 1px rgba(109,92,255,.12) inset, 0 1px 0 rgba(15,23,42,.04);
    }
    .chip .count{
      font-size: 11px;
      color: rgba(15,23,42,.72);
      border:1px solid rgba(15,23,42,.16);
      padding: 2px 7px;
      border-radius: 999px;
      background: rgba(255,255,255,.70);
      font-weight: 900;
    }

    /* map */
    .mapWrap{
      margin-top: 10px;
      border-radius: var(--radius2);
      border:1px solid var(--line);
      overflow:hidden;
      background: rgba(255,255,255,.70);
      height: 560px; /* bigger */
      position:relative;
      box-shadow: var(--shadow2);
    }
    @media (max-width: 600px){
      .mapWrap{ height: 470px; }
    }
    #map{
      width:100%;
      height:100%;
    }
    .mapHint{
      position:absolute;
      left:12px;
      right:12px;
      bottom:12px;
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid rgba(15,23,42,.16);
      background: rgba(255,255,255,.86);
      color: rgba(15,23,42,.78);
      font-size: 12px;
      line-height: 1.35;
      backdrop-filter: blur(8px);
      pointer-events:none;
      box-shadow: var(--shadow2);
    }
    .mapHint b{ color: rgba(15,23,42,.92); }

    /* list boxes */
    .sectionTitle{
      margin: 12px 0 8px;
      font-size: 13px;
      font-weight: 1000;
      letter-spacing: .2px;
    }
    .list{
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: rgba(255,255,255,.72);
      overflow:hidden;
      box-shadow: 0 1px 0 rgba(15,23,42,.03);
    }
    .listItem{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 10px 12px;
      border-top: 1px solid rgba(15,23,42,.06);
      cursor:pointer;
      user-select:none;
    }
    .listItem:first-child{ border-top:0; }
    .listItem:hover{ background: rgba(109,92,255,.06); }
    .liLeft{
      display:flex;
      gap:10px;
      align-items:center;
      min-width:0;
    }
    .liName{
      font-weight: 1000;
      font-size: 13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .liSub{
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .liRight{
      display:flex;
      gap:8px;
      align-items:center;
      flex-shrink:0;
    }
    .pillCount{
      font-size: 11px;
      border:1px solid rgba(15,23,42,.16);
      padding: 3px 8px;
      border-radius: 999px;
      color: rgba(15,23,42,.78);
      background: rgba(255,255,255,.78);
      font-weight: 900;
    }

    /* textarea */
    textarea{
      width:100%;
      min-height: 130px;
      resize: vertical;
      border:1px solid var(--line2);
      background: rgba(255,255,255,.92);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      outline:none;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 1px 0 rgba(15,23,42,.04);
    }
    .muted{
      color: var(--muted2);
      font-size: 12px;
      line-height: 1.35;
    }
    .tiny{
      margin-top: 8px;
      color: rgba(15,23,42,.62);
      font-size: 11px;
      line-height: 1.35;
    }

    /* right detail */
    .detailEmpty{
      border:1px dashed rgba(15,23,42,.22);
      border-radius: var(--radius2);
      padding: 14px;
      background: rgba(255,255,255,.70);
      color: rgba(15,23,42,.72);
      font-size: 13px;
    }
    .kv{
      display:grid;
      grid-template-columns: 130px 1fr;
      gap:10px;
      padding: 10px 12px;
      border-top:1px solid rgba(15,23,42,.06);
    }
    .kv:first-child{ border-top:0; }
    .k{
      color: rgba(15,23,42,.70);
      font-size: 12px;
      font-weight: 1000;
    }
    .v{
      font-size: 12px;
      color: rgba(15,23,42,.92);
      word-break: break-word;
      font-weight: 800;
    }
    .divider{
      height:1px;
      background: rgba(15,23,42,.08);
      margin: 12px 0;
    }

    /* overlay label */
    .regionLabel{
      padding: 5px 10px;
      border-radius: 999px;
      border:1px solid rgba(15,23,42,.18);
      background: rgba(255,255,255,.90);
      color: rgba(15,23,42,.92);
      font-size: 12px;
      font-weight: 1000;
      box-shadow: var(--shadow2);
      backdrop-filter: blur(6px);
      white-space:nowrap;
    }
    .regionLabel small{
      font-weight: 1000;
      color: rgba(19,136,255,.95);
      margin-left:6px;
    }

    /* toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(255,255,255,.92);
      border:1px solid rgba(15,23,42,.16);
      color: rgba(15,23,42,.92);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: .2s ease;
      z-index: 9999;
      font-weight: 900;
    }
    .toast.show{ opacity:1; }
  </style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="dot"></div>
      <div>
        <h1>CoupangLand <span class="pill">프론트 임시 MVP</span></h1>
        <div class="subtitle">
          시/도 지도 기반 → 시/군/구 → 동 단위로 대리점/라우트 현황을 드릴다운 조회합니다. (백엔드 없음 / localStorage 저장)
        </div>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="btnResetView" type="button">전체 보기</button>
      <button class="btn" id="btnCopySummary" type="button">현재 화면 요약 복사</button>
      <button class="btn danger" id="btnClearAll" type="button">데이터 초기화</button>
    </div>
  </div>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="cardHeader">
        <h2>지도 기반 조회</h2>
        <span class="badge" id="badgeData">데이터: 0건</span>
      </div>
      <div class="cardBody">
        <div class="row">
          <input class="input" id="q" placeholder="검색: 예) 영등포구 / 대림동 / 용인시 수지구 / 투네스트" />
          <button class="miniBtn" id="btnSearch" type="button">검색</button>
        </div>

        <div class="chips" id="chipsScope"></div>
        <div class="chips" id="chipsVendors"></div>

        <div class="mapWrap">
          <div id="map"></div>
          <div class="mapHint" id="mapHint">
            <b>사용법</b>: 폴리곤을 클릭하면 아래 단계로 내려갑니다. (시/도 → 시군구 → 동)<br/>
            업체 필터(마루웰/투네스트 등)로 조회 범위를 좁힐 수 있습니다.
          </div>
        </div>

        <div class="sectionTitle" id="listTitle">목록</div>
        <div class="list" id="listBox"></div>

        <div class="divider"></div>

        <div class="sectionTitle">데이터 입력/수정 (관리용)</div>
        <textarea id="raw" spellcheck="false" placeholder="예)
서울특별시 영등포구 대림동 | 마루웰
서울특별시 강서구 염창동 | 투네스트
경기도 용인시 수지구 동천동 | 투네스트

- 구/동만 들어오면(예: '영등포구 대림동') 가능한 범위에서 자동 추정합니다.
- 같은 라인이 여러 번 있어도 유니크로 정리됩니다."></textarea>

        <div class="row">
          <button class="btn primary" id="btnApply" type="button">파싱/적용</button>
          <button class="btn" id="btnSample" type="button">샘플 로드</button>
          <button class="btn" id="btnExport" type="button">유니크 목록 내보내기</button>
        </div>

        <div class="tiny" id="statsLine">-</div>
        <div class="tiny">
          경계 데이터 소스: southkorea/southkorea-maps(시/도·시군구), raqoon886/Local_HangJeongDong(동/행정동).
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="cardHeader">
        <h2>현재 선택 상세</h2>
        <span class="badge" id="badgeSel">-</span>
      </div>
      <div class="cardBody">
        <div class="detailEmpty" id="detailBox">
          선택된 조건에 데이터가 없습니다.<br/><br/>
          <div class="muted">
            구현 의도(요청하신 로직):
            <ul style="margin:8px 0 0 18px; padding:0; color:rgba(15,23,42,.65);">
              <li>시/도 클릭 시: 해당 시/도에 존재하는 업체(예: 마루웰/투네스트) 집계 노출</li>
              <li>시군구 클릭 시: 해당 시군구에 있는 업체만 노출</li>
              <li>동 클릭 시: 해당 동에 있는 업체/라우트만 노출</li>
            </ul>
          </div>
        </div>

        <div class="divider"></div>

        <div class="sectionTitle">디버그/메모</div>
        <div class="muted" id="debugNote" style="white-space:pre-wrap;">
- 이 MVP는 “정확한 경계 데이터”를 카카오지도 위에 올리는 구조입니다.
- 동(행정동) 경계는 용량이 커서 “선택된 시/도만” 로드합니다.
- 데이터에 ‘서울특별시’ 같은 시/도 표기가 빠져도, 가능한 범위에서 자동 추정합니다.
        </div>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<!-- topojson-client -->
<script src="https://unpkg.com/topojson-client@3/dist/topojson-client.min.js"></script>

<!-- Kakao 지도 SDK -->
<script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=add4ce93b38c0ff9d9b9053728e067b3"></script>

<script>
(function(){
  "use strict";

  /*********************
   * CONFIG / SOURCES
   *********************/
  const SOURCES = {
    provincesGeo: "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2012/json/provinces-geo-simple.json",
    municipalitiesTopo: "https://raw.githubusercontent.com/southkorea/southkorea-maps/master/kostat/2018/json/skorea-municipalities-2018-topo-simple.json",
    hangjeongdongBase: "https://raw.githubusercontent.com/raqoon886/Local_HangJeongDong/master/hangjeongdong_"
  };

  const SIDO_FILE = {
    "서울특별시":"서울특별시",
    "부산광역시":"부산광역시",
    "대구광역시":"대구광역시",
    "인천광역시":"인천광역시",
    "광주광역시":"광주광역시",
    "대전광역시":"대전광역시",
    "울산광역시":"울산광역시",
    "세종특별자치시":"세종특별자치시",
    "경기도":"경기도",
    "강원특별자치도":"강원특별자치도",
    "강원도":"강원도",
    "충청북도":"충청북도",
    "충청남도":"충청남도",
    "전북특별자치도":"전북특별자치도",
    "전라북도":"전라북도",
    "전라남도":"전라남도",
    "경상북도":"경상북도",
    "경상남도":"경상남도",
    "제주특별자치도":"제주특별자치도"
  };

  const SIDO_ALIASES = new Map([
    ["서울","서울특별시"], ["서울시","서울특별시"], ["서울특별시","서울특별시"],
    ["부산","부산광역시"], ["부산시","부산광역시"], ["부산광역시","부산광역시"],
    ["대구","대구광역시"], ["대구시","대구광역시"], ["대구광역시","대구광역시"],
    ["인천","인천광역시"], ["인천시","인천광역시"], ["인천광역시","인천광역시"],
    ["광주","광주광역시"], ["광주시","광주광역시"], ["광주광역시","광주광역시"],
    ["대전","대전광역시"], ["대전시","대전광역시"], ["대전광역시","대전광역시"],
    ["울산","울산광역시"], ["울산시","울산광역시"], ["울산광역시","울산광역시"],
    ["세종","세종특별자치시"], ["세종시","세종특별자치시"], ["세종특별자치시","세종특별자치시"],
    ["경기","경기도"], ["경기도","경기도"],
    ["강원","강원도"], ["강원도","강원도"], ["강원특별자치도","강원특별자치도"],
    ["충북","충청북도"], ["충청북도","충청북도"],
    ["충남","충청남도"], ["충청남도","충청남도"],
    ["전북","전라북도"], ["전라북도","전라북도"], ["전북특별자치도","전북특별자치도"],
    ["전남","전라남도"], ["전라남도","전라남도"],
    ["경북","경상북도"], ["경상북도","경상북도"],
    ["경남","경상남도"], ["경상남도","경상남도"],
    ["제주","제주특별자치도"], ["제주도","제주특별자치도"], ["제주특별자치도","제주특별자치도"]
  ]);

  const DEFAULT_VENDOR = "마루웰";
  const STORAGE_KEY = "coupangland_routes_v1";
  const STORAGE_RAW_KEY = "coupangland_raw_v1";

  /*********************
   * STATE
   *********************/
  const state = {
    level: "SIDO", // SIDO | SIGUNGU | DONG
    sido: null,
    sigungu: null,
    dong: null,

    vendor: null, // null means ALL

    entries: [],
    uniqueKeys: new Set(),

    map: null,
    polygons: [],
    overlays: [],

    provincesGeo: null,
    municipalitiesTopo: null,
    municipalitiesGeo: null,
    sigunguToSido: new Map(),
    dongGeoBySido: new Map(),

    lastSearch: ""
  };

  /*********************
   * DOM
   *********************/
  const el = {
    badgeData: document.getElementById("badgeData"),
    chipsScope: document.getElementById("chipsScope"),
    chipsVendors: document.getElementById("chipsVendors"),
    listTitle: document.getElementById("listTitle"),
    listBox: document.getElementById("listBox"),
    detailBox: document.getElementById("detailBox"),
    badgeSel: document.getElementById("badgeSel"),
    q: document.getElementById("q"),
    btnSearch: document.getElementById("btnSearch"),
    btnResetView: document.getElementById("btnResetView"),
    btnCopySummary: document.getElementById("btnCopySummary"),
    btnClearAll: document.getElementById("btnClearAll"),
    raw: document.getElementById("raw"),
    btnApply: document.getElementById("btnApply"),
    btnSample: document.getElementById("btnSample"),
    btnExport: document.getElementById("btnExport"),
    statsLine: document.getElementById("statsLine"),
    toast: document.getElementById("toast")
  };

  /*********************
   * UTIL
   *********************/
  function toast(msg){
    el.toast.textContent = msg;
    el.toast.classList.add("show");
    setTimeout(()=> el.toast.classList.remove("show"), 1600);
  }

  function safeJsonParse(s, fallback){
    try{ return JSON.parse(s); }catch(e){ return fallback; }
  }

  function normalizeWS(s){
    return (s||"").toString().replace(/\s+/g," ").trim();
  }

  function normalizeDongName(d){
    let x = (d||"").toString().trim();
    x = x.replace(/제?\s*\d+\s*동$/,"동");
    x = x.replace(/\d+동$/,"동");
    x = x.replace(/\s+/g,"");
    return x;
  }

  function isSidoToken(tok){
    if(!tok) return false;
    return tok.endsWith("도") || tok.endsWith("시") || tok.endsWith("특별시") || tok.endsWith("광역시") || tok.endsWith("특별자치시") || tok.endsWith("특별자치도");
  }
  function isSigunguToken(tok){
    if(!tok) return false;
    return tok.endsWith("시") || tok.endsWith("군") || tok.endsWith("구");
  }
  function isDongToken(tok){
    if(!tok) return false;
    return tok.endsWith("동") || tok.endsWith("읍") || tok.endsWith("면") || tok.endsWith("리");
  }

  function canonicalSido(sidoRaw){
    const s = normalizeWS(sidoRaw);
    return SIDO_ALIASES.get(s) || s;
  }

  function encodePathComponent(s){
    return encodeURIComponent(s);
  }

  function buildDongUrl(sido){
    const key = SIDO_FILE[sido] || sido;
    return SOURCES.hangjeongdongBase + encodePathComponent(key) + ".geojson";
  }

  function uniq(arr){ return Array.from(new Set(arr)); }

  function groupCount(items){
    const m = new Map();
    for(const k of items){
      m.set(k, (m.get(k)||0)+1);
    }
    return m;
  }

  function sortByCountThenName(map){
    return Array.from(map.entries()).sort((a,b)=>{
      if(b[1]!==a[1]) return b[1]-a[1];
      return a[0].localeCompare(b[0], "ko");
    });
  }

  function copyToClipboard(text){
    if(navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(text);
    }
    const ta = document.createElement("textarea");
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
    return Promise.resolve();
  }

  /*********************
   * DATA PARSING
   *********************/
  function parseLinesToEntries(rawText){
    const lines = (rawText||"").split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
    const out = [];

    for(const line of lines){
      let locPart = line;
      let vendorPart = null;

      if(line.includes("|")){
        const parts = line.split("|").map(p=>p.trim()).filter(Boolean);
        locPart = parts[0] || "";
        vendorPart = parts[1] || null;
      }else if(line.includes(",")){
        const parts = line.split(",").map(p=>p.trim()).filter(Boolean);
        if(parts.length>=2){
          locPart = parts[0];
          vendorPart = parts.slice(1).join(" ");
        }
      }

      const vendor = normalizeWS(vendorPart || DEFAULT_VENDOR) || DEFAULT_VENDOR;
      const tokens = normalizeWS(locPart).split(" ").filter(Boolean);

      let sido = null;
      let sigungu = null;
      let dong = null;

      if(tokens.length === 0) continue;

      if(isSidoToken(tokens[0]) || SIDO_ALIASES.has(tokens[0])){
        sido = canonicalSido(tokens[0]);
        if(tokens.length >= 3){
          if(tokens.length === 3){
            sigungu = tokens[1];
            dong = tokens[2];
          }else{
            dong = tokens[tokens.length-1];
            sigungu = tokens.slice(1, tokens.length-1).join(" ");
          }
        }else{
          continue;
        }
      }else{
        if(tokens.length === 2){
          sigungu = tokens[0];
          dong = tokens[1];
        }else{
          dong = tokens[tokens.length-1];
          sigungu = tokens.slice(0, tokens.length-1).join(" ");
        }
      }

      if(!sigungu || !dong) continue;

      out.push({
        vendor,
        sido,
        sigungu: normalizeWS(sigungu),
        dong: normalizeWS(dong)
      });
    }

    return { entries: out };
  }

  function rebuildUnique(entries){
    state.uniqueKeys.clear();
    const uniqEntries = [];
    for(const e of entries){
      const key = [e.vendor, e.sido || "", e.sigungu || "", e.dong || ""].join("||");
      if(!state.uniqueKeys.has(key)){
        state.uniqueKeys.add(key);
        uniqEntries.push(e);
      }
    }
    state.entries = uniqEntries;
  }

  /*********************
   * BOUNDARY LOADING
   *********************/
  async function fetchJson(url){
    const r = await fetch(url, { cache:"force-cache" });
    if(!r.ok) throw new Error("HTTP " + r.status + " " + url);
    return r.json();
  }

  function featureName(props){
    if(!props) return "";
    return (
      props.name ||
      props.NAME ||
      props.Name ||
      props.adm_nm ||
      props.sido ||
      props.sidonm ||
      props.SIDO_NM ||
      props.sigungu ||
      props.sggnm ||
      props.SGG_NM ||
      props.EMD_NM ||
      props.emdnm ||
      props.CTP_KOR_NM ||
      props.SIG_KOR_NM ||
      ""
    ).toString().trim();
  }

  function parseFullNameGuess(fullName){
    const t = normalizeWS(fullName).split(" ").filter(Boolean);
    if(t.length<2) return { sido:null, sigungu:null };
    const sido = canonicalSido(t[0]);
    const sigungu = t.slice(1).join(" ");
    return { sido, sigungu };
  }

  async function ensureProvinces(){
    if(state.provincesGeo) return state.provincesGeo;
    const j = await fetchJson(SOURCES.provincesGeo);
    state.provincesGeo = j;
    return j;
  }

  async function ensureMunicipalities(){
    if(state.municipalitiesGeo) return state.municipalitiesGeo;

    const topo = await fetchJson(SOURCES.municipalitiesTopo);
    state.municipalitiesTopo = topo;

    const objKey = Object.keys(topo.objects||{})[0];
    if(!objKey) throw new Error("TopoJSON objects 없음");

    const geo = topojson.feature(topo, topo.objects[objKey]);
    state.municipalitiesGeo = geo;

    const tempMap = new Map(); // sigunguName -> Set(sido)
    for(const f of (geo.features||[])){
      const nm = featureName(f.properties) || "";
      const parsed = parseFullNameGuess(nm);
      if(parsed.sido && parsed.sigungu){
        const sig = parsed.sigungu;
        if(!tempMap.has(sig)) tempMap.set(sig, new Set());
        tempMap.get(sig).add(parsed.sido);
      }
    }
    state.sigunguToSido.clear();
    for(const [sig, set] of tempMap.entries()){
      if(set.size === 1){
        state.sigunguToSido.set(sig, Array.from(set)[0]);
      }
    }

    return geo;
  }

  async function ensureDongGeo(sido){
    if(!sido) throw new Error("sido 없음");
    const key = canonicalSido(sido);
    if(state.dongGeoBySido.has(key)) return state.dongGeoBySido.get(key);

    const url = buildDongUrl(key);
    const j = await fetchJson(url);
    state.dongGeoBySido.set(key, j);
    return j;
  }

  /*********************
   * INFER / NORMALIZE ENTRIES
   *********************/
  function inferMissingSido(){
    let changed = 0;
    for(const e of state.entries){
      if(e.sido) continue;
      const inferred = state.sigunguToSido.get(e.sigungu);
      if(inferred){
        e.sido = inferred;
        changed++;
      }
    }
    return changed;
  }

  /*********************
   * FILTERING / AGG
   *********************/
  function selectionLabel(){
    const parts = [];
    if(state.sido) parts.push(state.sido);
    if(state.sigungu) parts.push(state.sigungu);
    if(state.dong) parts.push(state.dong);
    if(parts.length === 0) return "전체";
    return parts.join(" / ");
  }

  function entryMatchesSelection(e){
    if(state.vendor && e.vendor !== state.vendor) return false;
    if(state.sido && e.sido !== state.sido) return false;
    if(state.sigungu && e.sigungu !== state.sigungu) return false;
    if(state.dong && normalizeDongName(e.dong) !== normalizeDongName(state.dong)) return false;
    return true;
  }

  function getFiltered(){
    return state.entries.filter(entryMatchesSelection);
  }

  function aggByLevel(level, entries){
    const keys = [];
    for(const e of entries){
      if(level==="SIDO"){
        if(e.sido) keys.push(e.sido);
      }else if(level==="SIGUNGU"){
        if(e.sigungu) keys.push(e.sigungu);
      }else{
        if(e.dong) keys.push(e.dong);
      }
    }
    return groupCount(keys);
  }

  function aggVendors(entries){
    const keys = entries.map(e=>e.vendor);
    return groupCount(keys);
  }

  function uniqueLocationCount(entries){
    const s = new Set();
    for(const e of entries){
      s.add([e.vendor, e.sido||"", e.sigungu||"", normalizeDongName(e.dong||"")].join("||"));
    }
    return s.size;
  }

  /*********************
   * KAKAO MAP DRAWING
   *********************/
  function clearMapOverlays(){
    for(const p of state.polygons){
      try{ p.setMap(null); }catch(e){}
    }
    for(const o of state.overlays){
      try{ o.setMap(null); }catch(e){}
    }
    state.polygons = [];
    state.overlays = [];
  }

  function geoCoordsToLatLngPath(coords){
    const path = [];
    for(const pt of coords){
      if(!pt || pt.length < 2) continue;
      path.push(new kakao.maps.LatLng(pt[1], pt[0]));
    }
    return path;
  }

  function geomToPaths(geom){
    if(!geom) return [];
    const type = geom.type;
    const c = geom.coordinates;
    const out = [];

    if(type === "Polygon"){
      if(Array.isArray(c) && c[0]){
        out.push(geoCoordsToLatLngPath(c[0]));
      }
    }else if(type === "MultiPolygon"){
      for(const poly of (c||[])){
        if(poly && poly[0]){
          out.push(geoCoordsToLatLngPath(poly[0]));
        }
      }
    }
    return out;
  }

  function boundsFromPath(path){
    const b = new kakao.maps.LatLngBounds();
    for(const ll of path){
      b.extend(ll);
    }
    return b;
  }

  function centroidFromPath(path){
    let sumLat = 0, sumLng = 0, n = 0;
    for(const ll of path){
      sumLat += ll.getLat();
      sumLng += ll.getLng();
      n++;
    }
    if(n===0) return null;
    return new kakao.maps.LatLng(sumLat/n, sumLng/n);
  }

  function makeLabelOverlay(position, name, count){
    const div = document.createElement("div");
    div.className = "regionLabel";
    div.textContent = name;
    if(typeof count === "number"){
      const sm = document.createElement("small");
      sm.textContent = String(count);
      div.appendChild(sm);
    }
    return new kakao.maps.CustomOverlay({
      position,
      content: div,
      yAnchor: 1
    });
  }

  /* Increased visibility */
  function colorForCount(count){
    if(count >= 10) return "rgba(19,136,255,.30)";
    if(count >= 5) return "rgba(109,92,255,.28)";
    if(count >= 1) return "rgba(15,23,42,.10)";
    return "rgba(15,23,42,.04)";
  }
  function strokeForActive(active){
    return active ? "rgba(109,92,255,.98)" : "rgba(19,136,255,.82)";
  }
  function fillOpacityForActive(active){
    return active ? 0.46 : 0.32;
  }

  function drawGeoFeatures(geo, options){
    clearMapOverlays();

    const counts = options.countsMap || new Map();
    const activeName = options.activeName || null;

    let overallBounds = null;

    for(const f of (geo.features||[])){
      const nm = (options.getName ? options.getName(f) : featureName(f.properties)) || "";
      if(!nm) continue;

      const paths = geomToPaths(f.geometry);
      if(paths.length===0) continue;

      const count = counts.get(nm) || 0;
      const isActive = (activeName && nm === activeName);

      for(const path of paths){
        if(path.length < 3) continue;

        const poly = new kakao.maps.Polygon({
          path,
          strokeWeight: 3,               // thicker
          strokeColor: strokeForActive(isActive),
          strokeOpacity: 0.98,
          strokeStyle: "solid",
          fillColor: colorForCount(count),
          fillOpacity: fillOpacityForActive(isActive)
        });

        poly.setMap(state.map);
        state.polygons.push(poly);

        const b = boundsFromPath(path);
        if(!overallBounds) overallBounds = b;
        else overallBounds.extend(b.getSouthWest()), overallBounds.extend(b.getNorthEast());

        if(options.onClick){
          kakao.maps.event.addListener(poly, "click", function(){
            options.onClick(nm, f);
          });
        }
      }

      const representativePath = paths[0];
      const center = centroidFromPath(representativePath);
      if(center && (count > 0 || nm === activeName)){
        const ov = makeLabelOverlay(center, nm, count);
        ov.setMap(state.map);
        state.overlays.push(ov);
      }
    }

    if(overallBounds){
      state.map.setBounds(overallBounds);
    }
  }

  /*********************
   * UI RENDER
   *********************/
  function renderBadge(){
    el.badgeData.textContent = "데이터: " + state.entries.length + "건";
  }

  function escapeHtml(s){
    return (s||"").toString()
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }

  function renderScopeChips(){
    const items = [];
    items.push({ key:"ALL", label:"전체", active: !state.sido && !state.sigungu && !state.dong });
    if(state.sido) items.push({ key:"SIDO", label: state.sido, active: !!state.sido && !state.sigungu && !state.dong });
    if(state.sigungu) items.push({ key:"SIGUNGU", label: state.sigungu, active: !!state.sigungu && !state.dong });
    if(state.dong) items.push({ key:"DONG", label: state.dong, active: !!state.dong });

    const canBack = !!(state.sido || state.sigungu || state.dong);

    el.chipsScope.innerHTML = "";
    for(const it of items){
      const c = document.createElement("div");
      c.className = "chip" + (it.active ? " active" : "");
      c.innerHTML = "<strong>" + escapeHtml(it.label) + "</strong>";
      c.addEventListener("click", ()=>{
        if(it.key==="ALL"){
          setSelection({ level:"SIDO", sido:null, sigungu:null, dong:null });
        }else if(it.key==="SIDO"){
          setSelection({ level:"SIGUNGU", sido:state.sido, sigungu:null, dong:null });
        }else if(it.key==="SIGUNGU"){
          setSelection({ level:"DONG", sido:state.sido, sigungu:state.sigungu, dong:null });
        }
      });
      el.chipsScope.appendChild(c);
    }

    if(canBack){
      const c = document.createElement("div");
      c.className = "chip";
      c.innerHTML = "<strong>← 한 단계 위</strong>";
      c.addEventListener("click", ()=>{
        if(state.dong){
          setSelection({ level:"DONG", sido:state.sido, sigungu:state.sigungu, dong:null });
        }else if(state.sigungu){
          setSelection({ level:"SIGUNGU", sido:state.sido, sigungu:null, dong:null });
        }else if(state.sido){
          setSelection({ level:"SIDO", sido:null, sigungu:null, dong:null });
        }
      });
      el.chipsScope.appendChild(c);
    }
  }

  function renderVendorChips(){
    const filteredForVendorAgg = state.entries.filter(e=>{
      if(state.sido && e.sido !== state.sido) return false;
      if(state.sigungu && e.sigungu !== state.sigungu) return false;
      if(state.dong && normalizeDongName(e.dong) !== normalizeDongName(state.dong)) return false;
      return true;
    });

    const m = aggVendors(filteredForVendorAgg);
    const rows = sortByCountThenName(m);

    el.chipsVendors.innerHTML = "";

    const allCount = uniqueLocationCount(filteredForVendorAgg);
    const allChip = document.createElement("div");
    allChip.className = "chip" + (!state.vendor ? " active" : "");
    allChip.innerHTML = "<strong>전체 업체</strong> <span class='count'>" + allCount + "</span>";
    allChip.addEventListener("click", ()=>{
      state.vendor = null;
      refresh();
    });
    el.chipsVendors.appendChild(allChip);

    for(const [vendor, count] of rows){
      const c = document.createElement("div");
      c.className = "chip" + (state.vendor === vendor ? " active" : "");
      c.innerHTML = "<strong>" + escapeHtml(vendor) + "</strong> <span class='count'>" + count + "</span>";
      c.addEventListener("click", ()=>{
        state.vendor = (state.vendor === vendor) ? null : vendor;
        refresh();
      });
      el.chipsVendors.appendChild(c);
    }
  }

  function renderList(){
    const filtered = getFiltered();
    el.listBox.innerHTML = "";

    let mode = "SIDO";
    if(state.sido && !state.sigungu) mode = "SIGUNGU";
    if(state.sigungu && !state.dong) mode = "DONG";
    if(state.dong) mode = "DETAIL";

    if(mode === "SIDO"){
      el.listTitle.textContent = "시/도";
      const m = aggByLevel("SIDO", filtered);
      const rows = sortByCountThenName(m);
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>표시할 데이터가 없습니다.</div></div>";
        return;
      }
      for(const [name, count] of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(name)}</div>
              <div class="liSub">클릭해서 시군구 보기</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">${count}</span></div>
        `;
        item.addEventListener("click", ()=>{
          setSelection({ level:"SIGUNGU", sido:name, sigungu:null, dong:null });
        });
        el.listBox.appendChild(item);
      }
    }else if(mode === "SIGUNGU"){
      el.listTitle.textContent = "시/군/구 (선택: " + state.sido + ")";
      const m = aggByLevel("SIGUNGU", filtered);
      const rows = sortByCountThenName(m);
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>선택된 시/도에 데이터가 없습니다.</div></div>";
        return;
      }
      for(const [name, count] of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(name)}</div>
              <div class="liSub">클릭해서 동 보기</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">${count}</span></div>
        `;
        item.addEventListener("click", ()=>{
          setSelection({ level:"DONG", sido:state.sido, sigungu:name, dong:null });
        });
        el.listBox.appendChild(item);
      }
    }else if(mode === "DONG"){
      el.listTitle.textContent = "동/읍/면 (선택: " + state.sigungu + ")";
      const m = aggByLevel("DONG", filtered);
      const rows = sortByCountThenName(m);
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>선택된 시군구에 데이터가 없습니다.</div></div>";
        return;
      }
      for(const [name, count] of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(name)}</div>
              <div class="liSub">클릭해서 업체/상세 보기</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">${count}</span></div>
        `;
        item.addEventListener("click", ()=>{
          setSelection({ level:"DONG", sido:state.sido, sigungu:state.sigungu, dong:name });
        });
        el.listBox.appendChild(item);
      }
    }else{
      el.listTitle.textContent = "상세 (선택: " + state.dong + ")";
      const rows = filtered.slice().sort((a,b)=>{
        const A = a.vendor.localeCompare(b.vendor, "ko");
        if(A!==0) return A;
        const B = (a.sigungu||"").localeCompare(b.sigungu||"", "ko");
        if(B!==0) return B;
        return (a.dong||"").localeCompare(b.dong||"", "ko");
      });
      if(rows.length===0){
        el.listBox.innerHTML = "<div class='listItem'><div class='liName'>해당 동에 데이터가 없습니다.</div></div>";
        return;
      }
      for(const e of rows){
        const item = document.createElement("div");
        item.className = "listItem";
        item.innerHTML = `
          <div class="liLeft">
            <div>
              <div class="liName">${escapeHtml(e.vendor)}</div>
              <div class="liSub">${escapeHtml((e.sido||"?") + " / " + e.sigungu + " / " + e.dong)}</div>
            </div>
          </div>
          <div class="liRight"><span class="pillCount">1</span></div>
        `;
        el.listBox.appendChild(item);
      }
    }
  }

  function kvRow(k,v){
    return `
      <div class="kv">
        <div class="k">${escapeHtml(k)}</div>
        <div class="v">${escapeHtml(v)}</div>
      </div>
    `;
  }

  function renderDetail(){
    const filtered = getFiltered();
    el.badgeSel.textContent = selectionLabel() + (state.vendor ? (" / " + state.vendor) : "");

    if(filtered.length===0){
      el.detailBox.className = "detailEmpty";
      el.detailBox.innerHTML = "선택된 조건에 데이터가 없습니다.";
      return;
    }

    const vendors = sortByCountThenName(aggVendors(filtered));
    const uniqCnt = uniqueLocationCount(filtered);

    const byDong = aggByLevel("DONG", filtered);
    const topDong = sortByCountThenName(byDong).slice(0, 12);

    const html = [];
    html.push("<div class='list' style='margin-bottom:12px;'>");
    html.push(kvRow("선택 범위", selectionLabel()));
    html.push(kvRow("업체 필터", state.vendor ? state.vendor : "전체"));
    html.push(kvRow("유니크(업체+지역)", String(uniqCnt)));
    html.push("</div>");

    html.push("<div class='sectionTitle'>업체 분포</div>");
    html.push("<div class='list'>");
    for(const [v, c] of vendors){
      html.push(kvRow(v, String(c)));
    }
    html.push("</div>");

    html.push("<div class='divider'></div>");
    html.push("<div class='sectionTitle'>상위 동(Top 12)</div>");
    html.push("<div class='list'>");
    for(const [d, c] of topDong){
      html.push(kvRow(d, String(c)));
    }
    html.push("</div>");

    el.detailBox.className = "";
    el.detailBox.innerHTML = html.join("");
  }

  function renderStatsLine(extra){
    const rawLines = (el.raw.value||"").split(/\r?\n/).filter(x=>x.trim()).length;
    el.statsLine.textContent = `원본 라인 ${rawLines} / 유니크(업체+지역) ${state.entries.length}` + (extra ? (" / " + extra) : "");
  }

  /*********************
   * SELECTION / FLOW
   *********************/
  function setSelection(next){
    state.level = next.level || state.level;
    state.sido = next.sido ?? state.sido;
    state.sigungu = next.sigungu ?? state.sigungu;
    state.dong = next.dong ?? state.dong;
    refresh();
  }

  async function refresh(){
    renderBadge();
    renderScopeChips();
    renderVendorChips();
    renderList();
    renderDetail();
    renderStatsLine();

    await renderMapBySelection();
    persist();
  }

  function persist(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state.entries));
    localStorage.setItem(STORAGE_RAW_KEY, el.raw.value || "");
  }

  function restore(){
    const saved = safeJsonParse(localStorage.getItem(STORAGE_KEY), []);
    if(Array.isArray(saved) && saved.length){
      state.entries = saved.map(x=>({
        vendor: normalizeWS(x.vendor||DEFAULT_VENDOR) || DEFAULT_VENDOR,
        sido: x.sido ? canonicalSido(x.sido) : null,
        sigungu: normalizeWS(x.sigungu||""),
        dong: normalizeWS(x.dong||"")
      })).filter(x=>x.sigungu && x.dong);
      rebuildUnique(state.entries);
    }
    const rawSaved = localStorage.getItem(STORAGE_RAW_KEY);
    if(rawSaved){
      el.raw.value = rawSaved;
    }
  }

  function resetView(){
    state.level = "SIDO";
    state.sido = null;
    state.sigungu = null;
    state.dong = null;
    state.vendor = null;
    el.q.value = "";
    refresh();
  }

  /*********************
   * MAP: render by selection level
   *********************/
  function ensureMap(){
    if(state.map) return;
    const center = new kakao.maps.LatLng(36.5, 127.8);
    state.map = new kakao.maps.Map(document.getElementById("map"), {
      center,
      level: 13
    });
  }

  async function renderMapBySelection(){
    ensureMap();

    if(!state.sido){
      try{
        const provinces = await ensureProvinces();
        await ensureMunicipalities();
        inferMissingSido();
        rebuildUnique(state.entries);

        const filtered = getFiltered();
        const countsMap = aggByLevel("SIDO", filtered);

        drawGeoFeatures(provinces, {
          getName: (f)=>{
            const nm = featureName(f.properties);
            return canonicalSido(nm);
          },
          countsMap,
          activeName: null,
          onClick: (sidoName)=>{
            setSelection({ level:"SIGUNGU", sido: canonicalSido(sidoName), sigungu:null, dong:null });
          }
        });
      }catch(err){
        clearMapOverlays();
        toast("시/도 경계 로드 실패");
      }
      return;
    }

    try{
      await ensureMunicipalities();
      inferMissingSido();
      rebuildUnique(state.entries);

      const filtered = getFiltered();
      const sigCount = aggByLevel("SIGUNGU", filtered);

      const all = state.municipalitiesGeo;
      const feat = [];
      for(const f of (all.features||[])){
        const nm = featureName(f.properties);
        const parsed = parseFullNameGuess(nm);
        if(parsed.sido && canonicalSido(parsed.sido) === canonicalSido(state.sido)){
          const clone = Object.assign({}, f);
          clone.__displayName = parsed.sigungu;
          feat.push(clone);
        }
      }

      if(feat.length > 0 && !state.sigungu){
        const geo = { type:"FeatureCollection", features: feat };
        const countsMap = new Map();
        for(const [k,v] of sigCount.entries()){
          countsMap.set(k, v);
        }

        drawGeoFeatures(geo, {
          getName: (f)=> f.__displayName || featureName(f.properties),
          countsMap,
          activeName: null,
          onClick: (sigName)=>{
            setSelection({ level:"DONG", sido: state.sido, sigungu: sigName, dong:null });
          }
        });
        return;
      }

      await renderDongLevel();
    }catch(err){
      await renderDongLevel().catch(()=>{
        clearMapOverlays();
        toast("경계 데이터 로드 실패");
      });
    }
  }

  async function renderDongLevel(){
    if(!state.sido){
      await renderMapBySelection();
      return;
    }
    const dongGeo = await ensureDongGeo(state.sido);
    inferMissingSido();
    rebuildUnique(state.entries);

    const filtered = getFiltered();
    const targetSigungu = state.sigungu ? normalizeWS(state.sigungu) : null;

    const dongCount = aggByLevel("DONG", filtered);

    const countsMapNorm = new Map();
    for(const [d,c] of dongCount.entries()){
      countsMapNorm.set(normalizeDongName(d), c);
    }

    const features = [];
    for(const f of (dongGeo.features||[])){
      const nm = featureName(f.properties);
      const adm = normalizeWS(nm);

      if(targetSigungu){
        if(!adm.includes(targetSigungu)) continue;
      }
      const clone = Object.assign({}, f);
      clone.__admName = adm;
      features.push(clone);
    }

    const geo = { type:"FeatureCollection", features };

    drawGeoFeatures(geo, {
      getName: (f)=>{
        const adm = f.__admName || featureName(f.properties);
        const toks = normalizeWS(adm).split(" ");
        const last = toks[toks.length-1] || adm;
        return last;
      },
      countsMap: new Map(Array.from(countsMapNorm.entries()).map(([k,v])=>[k,v])),
      activeName: null,
      onClick: (dongName)=>{
        if(!state.sigungu){
          toast("시군구를 먼저 선택하세요");
          return;
        }
        setSelection({ level:"DONG", sido: state.sido, sigungu: state.sigungu, dong: dongName });
      }
    });

    if(state.dong){
      toast("동 선택: " + state.dong);
    }
  }

  /*********************
   * SEARCH
   *********************/
  function doSearch(){
    const q = normalizeWS(el.q.value);
    if(!q){
      toast("검색어를 입력하세요");
      return;
    }
    state.lastSearch = q;

    const allVendors = uniq(state.entries.map(e=>e.vendor));
    let vendorHit = null;
    for(const v of allVendors){
      if(v && q.includes(v)){
        vendorHit = v;
        break;
      }
    }
    if(vendorHit){
      state.vendor = vendorHit;
    }

    const tokens = q.split(" ").filter(Boolean);

    let sido = null, sigungu = null, dong = null;

    for(const t of tokens){
      if(SIDO_ALIASES.has(t) || isSidoToken(t)){
        sido = canonicalSido(t);
        break;
      }
    }

    for(let i=tokens.length-1; i>=0; i--){
      const t = tokens[i];
      if(!dong && isDongToken(t)) dong = t;
      if(!sigungu && isSigunguToken(t)) sigungu = t;
    }

    if(tokens.length>=2){
      for(let i=0;i<tokens.length-1;i++){
        const a=tokens[i], b=tokens[i+1];
        if(isSigunguToken(a) && isSigunguToken(b)){
          sigungu = a + " " + b;
          break;
        }
      }
    }

    if(!sido && sigungu){
      const inferred = state.sigunguToSido.get(sigungu);
      if(inferred) sido = inferred;
    }

    if(sido && sigungu && dong){
      setSelection({ level:"DONG", sido, sigungu, dong });
    }else if(sido && sigungu){
      setSelection({ level:"DONG", sido, sigungu, dong:null });
    }else if(sido){
      setSelection({ level:"SIGUNGU", sido, sigungu:null, dong:null });
    }else{
      toast("지역을 특정할 수 없습니다(예: '서울특별시 강서구 염창동')");
      refresh();
    }
  }

  /*********************
   * EVENTS
   *********************/
  el.btnApply.addEventListener("click", async ()=>{
    const { entries } = parseLinesToEntries(el.raw.value);
    rebuildUnique(entries);

    try{
      await ensureMunicipalities();
      const changed = inferMissingSido();
      rebuildUnique(state.entries);
      renderStatsLine("시도 자동추정 " + changed + "건");
      toast("적용 완료 (유니크 " + state.entries.length + ")");
      refresh();
    }catch(e){
      renderStatsLine("경계 로드 실패로 시도 자동추정 불가");
      toast("적용 완료(경계 로드 실패)");
      refresh();
    }

    persist();
  });

  el.btnSample.addEventListener("click", ()=>{
    el.raw.value =
`영등포구 대림동 | 마루웰
영등포구 대림동 | 마루웰
분당구 대장동 | 투네스트
용인시 수지구 동천동 | 투네스트
영등포구 신길동 | 마루웰
대구광역시 중구 칠성동 | 마루웰
대구광역시 중구 동인동 | 마루웰
서울특별시 강서구 염창동 | 투네스트
서울특별시 강서구 염창동 | 마루웰
경기도 용인시 수지구 동천동 | 마루웰`;
    toast("샘플 로드");
    renderStatsLine();
  });

  el.btnExport.addEventListener("click", ()=>{
    const lines = state.entries
      .slice()
      .sort((a,b)=>{
        const A=(a.sido||"").localeCompare(b.sido||"", "ko");
        if(A!==0) return A;
        const B=(a.sigungu||"").localeCompare(b.sigungu||"", "ko");
        if(B!==0) return B;
        const C=normalizeDongName(a.dong||"").localeCompare(normalizeDongName(b.dong||""), "ko");
        if(C!==0) return C;
        return (a.vendor||"").localeCompare(b.vendor||"", "ko");
      })
      .map(e=>{
        const loc = [e.sido||"", e.sigungu||"", e.dong||""].filter(Boolean).join(" ");
        return loc + " | " + e.vendor;
      });
    const text = lines.join("\n");
    copyToClipboard(text).then(()=> toast("유니크 목록 복사됨"));
  });

  el.btnSearch.addEventListener("click", doSearch);
  el.q.addEventListener("keydown", (ev)=>{
    if(ev.key==="Enter") doSearch();
  });

  el.btnResetView.addEventListener("click", resetView);

  el.btnCopySummary.addEventListener("click", ()=>{
    const filtered = getFiltered();
    const uniqCnt = uniqueLocationCount(filtered);
    const vendors = sortByCountThenName(aggVendors(filtered));
    const topDong = sortByCountThenName(aggByLevel("DONG", filtered)).slice(0, 10);

    const summary =
`[CoupangLand 요약]
선택: ${selectionLabel()}
업체필터: ${state.vendor ? state.vendor : "전체"}
유니크(업체+지역): ${uniqCnt}

[업체 분포]
${vendors.map(([v,c])=>`- ${v}: ${c}`).join("\n") || "- (없음)"}

[Top 동]
${topDong.map(([d,c])=>`- ${d}: ${c}`).join("\n") || "- (없음)"}
`;
    copyToClipboard(summary).then(()=> toast("요약 복사됨"));
  });

  el.btnClearAll.addEventListener("click", ()=>{
    if(!confirm("localStorage의 CoupangLand 데이터를 모두 삭제할까요?")) return;
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(STORAGE_RAW_KEY);
    state.entries = [];
    state.uniqueKeys.clear();
    el.raw.value = "";
    resetView();
    toast("초기화 완료");
  });

  /*********************
   * INIT
   *********************/
  async function init(){
    ensureMap();
    restore();

    renderBadge();
    renderScopeChips();
    renderVendorChips();
    renderList();
    renderDetail();
    renderStatsLine();

    try{
      await ensureMunicipalities();
      const changed = inferMissingSido();
      if(changed>0){
        rebuildUnique(state.entries);
        persist();
      }
    }catch(e){
      // ignore
    }

    await refresh();
  }

  init();

})();
</script>
</body>
</html>
